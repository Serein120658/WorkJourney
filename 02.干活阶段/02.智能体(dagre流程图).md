## G6图表

官方文档：[G6·图可视化引擎](https://g6.antv.antgroup.com/)

在上一个智能体练习中，我们用到了G6图中的力导向图，但是发现其版本有点低，导致了设置边不生效的问题，如下：

![image-20250811111018190](02.智能体(dagre流程图).assets/image-20250811111018190.png)

优化结构：

![image-20250811153045642](02.智能体(dagre流程图).assets/image-20250811153045642.png)

根据文档，设置type会更改边的形状，

### 思路及实现

通过查看官方文档，按照需要的数据接口

在js文件中获得了数据后，创建一个全局的变量来存储数据，期间涉及到数据处理

也就是在layuitable加载的时候，**编写一个方法用于准备渲染G6图表的数据 **<font color=red>(需要说明的情况针对不同的图表，返回的数据格式是不一样的)</font> 如下(是针对Dagre流程图所需要的数据格式)：

```js
  function prepareRelationDataDagre(nodeList) {
        if (!nodeList || nodeList.length === 0) {
            return { nodes: [], edges: [] };
        }

        const nodes = [];
        const edges = [];
        const nodeMap = new Map();

        // 创建节点映射
        nodeList.forEach(node => {
            nodeMap.set(node.id, node);
        });

        // 生成节点数据 - 针对Dagre布局优化
        nodeList.forEach(node => {
            nodes.push({
                id: node.id.toString(),
                label: node.node_name || `节点${node.id}`,
                type: 'rect', // 使用矩形节点
                size: [100, 50], // [width, height] - 适合流程图的大小
                style: {
                    fill: getNodeColor(node.node_type),
                    stroke: '#666',
                    lineWidth: 1,
                    radius: 6 // 圆角
                },
                labelCfg: {
                    style: {
                        fill: '#fff',
                        fontSize: 11,
                        fontWeight: 'bold',
                        textAlign: 'center',
                        textBaseline: 'middle'
                    }
                },
                // 存储完整的节点信息用于显示详情
                nodeData: node
            });
        });

        // 生成边数据（基于parent_id关系）
        nodeList.forEach(node => {
            if (node.parent_id && node.parent_id !== '0' && nodeMap.has(parseInt(node.parent_id))) {
                edges.push({
                    source: node.parent_id.toString(),
                    target: node.id.toString(),
                    type: 'cubic', // 使用折线边  TODO  使用贝塞尔曲线
                    style: {
                        stroke: '#666',
                        lineWidth: 2,
                        endArrow: {
                            path: 'M 0,0 L 10,4 L 10,-4 Z',
                            fill: '#666'
                        }
                    }
                });
            }
        });

        return { nodes, edges };
    }
```

再使用前面创建的全局变量去接受对应的数据，然后再到新的方法中去创建G6图表实例,用于渲染图表。渲染图表可以使用  layer中type为1  也就是content可以直接问<div> 标签，或者内容的，具体内容如下：



## 智能体部分之权限完善

存在的问题

1. 在之前的熟悉中，我们只知道了perm这个参数是用于添加权限的，它直接决定了在页面上是否显示或者可以CRUD的，但是改如何添加呢？这是添加完权限的

   ![image-20250811175808280](02.智能体(dagre流程图).assets/image-20250811175808280.png)

2. 权限实现原理是啥呢？

   给用户添加权限

在菜单管理里面添加对应的权限

![image-20250811175855344](02.智能体(dagre流程图).assets/image-20250811175855344.png)



## 智能体存在的小缺陷

由于最开始的要求是流程图，但是给做成了力导图，索性添加个按钮，根据用户的点击来确定需要查看节点的那种形式。如图：

![image-20250811145214627](02.智能体(dagre流程图).assets/image-20250811145214627.png)

根据官方的参考样式：会存在一个节点有两个或者多个父节点，但是在我们设计的数据库中是不存在一个节点有多个父节点的，如果要解决这种问题？该如何重新设计数据库呢？或者说还有什么更优的方案？



### 方案一、重新设计数据库

好处: 后续便于维护，而且更加的直观

不好处: 得改大量的前端代码，原本的修改逻辑也得变化，就导致了整体的逻辑都需要重新去思考和实现

#### 想法

这种方式就是创建一个新表去实现多对多的关系，原有的节点表去除parent_id字段

对应的表结构 

```sql
CREATE TABLE w_agent_node_relation (
    id int4 PRIMARY KEY,
    parent_node_id int4,
    child_node_id int4,
    relation_type varchar(20), -- 关系类型（可选）
    created_time timestamp,
    FOREIGN KEY (parent_node_id) REFERENCES w_agent_node(id),
    FOREIGN KEY (child_node_id) REFERENCES w_agent_node(id)
);
```



### 方案二、在前端创建时添加虚拟节点

好处：不需要修改数据结构

坏处：如果别的地方需要展示的时候，前端又得创建虚拟的节点，最大的 不方便的地方就是，根据从数据库里面得到的数据，那种情况是需要子节点有多个父节点的？这是最难判断的，前端也不好搞

#### 参考代码：

```js
function convertTreeToDAG(treeNodes) {
    const dagNodes = [];
    const dagEdges = [];
    const nodeMap = new Map();
    
    // 处理需要多个父节点的情况
    treeNodes.forEach(node => {
        // 如果这个节点需要连接到多个父节点
        if (node.hasMultipleParents) {
            // 为每个父连接创建虚拟节点
            node.parentIds.forEach((parentId, index) => {
                const virtualNodeId = `${node.id}_virtual_${index}`;
                
                // 创建虚拟节点
                dagNodes.push({
                    id: virtualNodeId,
                    ...node,
                    isVirtual: true
                });
                
                // 创建边
                dagEdges.push({
                    source: parentId,
                    target: virtualNodeId
                });
            });
        } else {
            // 普通节点直接添加
            dagNodes.push(node);
            if (node.parent_id) {
                dagEdges.push({
                    source: node.parent_id,
                    target: node.id
                });
            }
        }
    });
    
    return { nodes: dagNodes, edges: dagEdges };
}
```



## 明日待做

将前面的节点换为HTML节点



