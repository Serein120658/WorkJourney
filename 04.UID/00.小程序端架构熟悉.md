# uni-app 接口请求封装详细文档

## 概述

该项目基于 uni-app 框架，封装了三种不同的接口请求方式，分别用于不同的业务场景。通过 `App.vue` 中的 `globalData` 对象，将这些方法注册到全局 `uni` 对象上，使得在任何页面都可以直接使用。

## 全局方法注册

在 `App.vue` 的 `onLaunch` 生命周期中，将封装的方法注册到全局：

```javascript
// 注册方法到 uni 全局对象
uni.sm = this.globalData.sm;           // 标准接口请求
uni.smsync = this.globalData.smsync;   // 同步接口请求（返回Promise）
uni.smaction = this.globalData.smaction; // 控制器方法请求
uni.alert = this.globalData.alert;     // 全局弹窗
uni.msg = this.globalData.msg;         // 消息提示
uni.svs = this.globalData.services;    // 服务配置
```

## 三种请求方式详解

### 1. `sm()` - 标准接口请求方法

**用途**: 调用后端业务方法的标准方式，使用传统的回调函数处理结果。

#### 方法签名

```javascript
uni.sm(callback, params, options)
```

#### 参数说明

| 参数       | 类型     | 必填 | 说明                                                   |
| ---------- | -------- | ---- | ------------------------------------------------------ |
| `callback` | Function | 是   | 回调函数，格式为 `(result, error, fullResponse) => {}` |
| `params`   | Array    | 是   | 请求参数数组，第一个元素为方法名                       |
| `options`  | Object   | 否   | 请求配置选项                                           |

#### options 配置项

| 属性    | 类型   | 说明                              |
| ------- | ------ | --------------------------------- |
| `route` | String | 微服务路由名称，如 'zxx_home_biz' |
| `msgid` | String | 消息ID                            |
| `trans` | String | 事务标识                          |
| `rpc`   | String | 远程调用标识                      |

#### 使用示例

##### 前端

```javascript
// 基本用法 - 获取用户详情
uni.sm(function(result, error) {
    if (error) {
        return uni.msg(error);
    }
    console.log('用户详情:', result);
}, ["user.selectdetail", userId], {route: uni.svs.zxx_home_biz});

// 复杂参数用法 - 更新用户信息
uni.sm(function(result, error) {
    if (error) {
        return uni.msg(error);
    }
    uni.msg('保存成功');
}, [
    "user.updateuser", 
    JSON.stringify({name: '张三'}),  // JSON字符串参数
    uni.msgwhere({id: [123]})        // 查询条件
], {route: uni.svs.zxx_home_biz});
```

##### 后端



#### 内部处理流程

1. **参数编码**: 将参数数组进行特殊编码，用 `%15` 分隔参数，`%18` 分隔多个请求
2. **Token处理**: 自动添加存储的认证token
3. **请求发送**: 向 `/Enter` 端点发送请求
4. **响应处理**: 解析返回数据并执行回调

### 2. `smsync()` - 同步接口请求方法

**用途**: 基于 Promise 的异步请求方式，便于使用 async/await 语法。

#### 方法签名

```javascript
const {re, err, obj} = await uni.smsync(params, options)
```

#### 返回值

```javascript
{
    re: result,      // 业务数据结果
    err: error,      // 错误信息
    obj: fullResponse // 完整响应对象
}
```

#### 使用示例

```javascript
// async/await 用法
async loadUserData() {
    try {
        const {re, err} = await uni.smsync(
            ["user.selectdetail", this.userId], 
            {route: uni.svs.zxx_home_biz}
        );
        
        if (err) {
            uni.msg(err);
            return;
        }
        
        this.userInfo = re;
    } catch (error) {
        console.error('请求失败:', error);
    }
}

// Promise 用法
uni.smsync(["user.getlist"], {route: uni.svs.zxx_home_biz})
    .then(({re, err}) => {
        if (!err) {
            this.userList = re;
        }
    })
    .catch(error => {
        console.error('请求异常:', error);
    });
```

### 3. `smaction()` - 控制器方法请求

**用途**: 直接调用后端控制器的 RESTful 接口，适合标准的 HTTP API 调用。

#### 方法签名

```javascript
uni.smaction(callback, params, options)
```

#### options 配置项（必填）

| 属性         | 类型    | 必填 | 说明                        |
| ------------ | ------- | ---- | --------------------------- |
| `route`      | String  | 是   | 微服务路由名称              |
| `action`     | String  | 是   | 控制器路径，如 'user/login' |
| `method`     | String  | 否   | HTTP方法，默认 'GET'        |
| `datastring` | Boolean | 否   | 是否将参数转为JSON字符串    |

#### 使用示例

```javascript
// GET 请求 - 获取数据
uni.smaction(function(result, error) {
    if (error) {
        return uni.msg(error);
    }
    this.dataList = result;
}, {
    page: 1,
    size: 10
}, {
    route: uni.svs.zxx_home_biz,
    action: 'data/list'
});

// POST 请求 - 提交数据
uni.smaction(function(result, error) {
    if (error) {
        return uni.msg(error);
    }
    uni.msg('保存成功');
}, {
    name: '张三',
    age: 25
}, {
    route: uni.svs.zxx_home_biz,
    action: 'user/save',
    method: 'POST',
    datastring: true  // 将参数转为JSON字符串发送
});

// 退出登录示例
uni.smaction(function(result, error) {
    if (error) {
        return uni.msg(error);
    }
    // 清除用户信息并跳转
    app.globalData.objuserinfo = {};
    uni.reLaunch({
        url: '/pages/tabBar/home/index'
    });
}, {}, {
    route: uni.svs.auth,
    action: 'exit',
    method: 'POST'
});
```

## 认证机制

### Token 处理

所有请求都会自动添加认证信息：

```javascript
var token = uni.getStorageSync('token');
if(token) {
    // sm/smsync 方法添加到请求参数
    data.Authorization = 'Bearer ' + token;
    
    // smaction 方法添加到请求参数
    params.Authorization = 'Bearer ' + token;
}
```

### Session 处理（微信小程序）

```javascript
// 微信小程序使用 Cookie 方式
_this.globalData.headers['Cookie'] = 'JSESSIONID=' + sessionId;
```

## 辅助方法

### 消息提示方法

```javascript
// 普通消息提示
uni.msg("操作成功");

// 确认对话框
uni.confirm("确认删除吗？", function(res) {
    if (res.confirm) {
        // 用户点击确认
    }
});

// 输入对话框
uni.prompt("请输入姓名", "默认值", function(res) {
    console.log('输入内容:', res.content);
});

// 普通提示框
uni.alert("提示", "操作完成");
```

### 查询条件构建

```javascript
// 构建 WHERE 条件
const whereCondition = uni.msgwhere(
    {id: [1, 2, 3]},      // 第一个条件对象
    {status: 'active'}     // 第二个条件对象
);
// 结果: {"msg_where": {"id": [1,2,3], "status": "active"}}

// 构建数组 WHERE 条件
const arrayCondition = uni.msgArrwhere([
    {name: 'like', value: '%张%'},
    {age: '>', value: 18}
]);

// 构建多参数连接
const joinParams = uni.msgpJoin(['param1', 'param2', 'param3']);
// 结果: [['param1'], ['param2'], ['param3']]
```

## 错误处理机制

### 统一错误处理

```javascript
// 登录失效自动跳转
if (response.error == "nologin") {
    return uni.navigateTo({
        url: "/pages/login/login"
    });
}

// 服务器错误提示
if (response.error || response.code == 500) {
    console.error('请求错误:', response);
    callback(null, response.error || response.msg, response);
}
```

### 网络请求失败处理

```javascript
fail: function(res) {
    callback(null, '请求失败');
}
```

## 实际使用案例分析

### 案例1：用户信息修改（myinfo.vue）

```javascript
// 保存用户信息
save(param) {
    uni.sm(function(result, error) {
        if (error) {
            return uni.msg(error);
        }
        
        uni.msg('保存成功');
        
        // 特殊处理：修改姓名时同步到后台缓存
        if (param.truename) {
            app.globalData.objuserinfo.truename = param.truename;
            
            // 同步信息到缓存服务
            uni.smaction(function() {
                // 同步完成
            }, {
                key: 'truename', 
                value: param.truename
            }, {
                route: uni.svs.zxx_home_biz, 
                action: 'mine/syncinfo'
            });
        }
    }, [
        "user.updateuser", 
        JSON.stringify(param), 
        uni.msgwhere({id: [this.myinfo.id]})
    ], {
        route: uni.svs.zxx_home_biz
    });
}
```

### 案例2：登录流程

```javascript
applogin: function(param, successCallback, errorCallback) {
    var requestOptions = {
        route: uni.svs.auth,
        action: 'login/wxlogin',
        method: 'POST',
        datastring: true
    };
    
    this.smaction((result, error, response) => {
        uni.hideLoading();
        
        if (error) {
            // 处理登录失败
            if (param.logintype == "autologin" && errorCallback) {
                errorCallback(); // Token登录失败，尝试其他方式
            } else {
                console.log('未登录:', response);
                // 跳转到登录页面
                setTimeout(function() {
                    uni.reLaunch({
                        url: "/pages/login/login"
                    });
                }, 1000);
            }
        } else {
            // 登录成功，保存用户信息
            _this.globalData.getUserInfoBack(result);
            successCallback && successCallback();
        }
    }, param, requestOptions);
}
```

## 最佳实践建议

### 1. 选择合适的请求方法

- **`sm()`**: 传统业务逻辑调用，参数复杂的场景
- **`smsync()`**: 需要使用 async/await 的现代异步场景
- **`smaction()`**: RESTful API 调用，标准 HTTP 接口

### 2. 错误处理

```javascript
// 始终进行错误检查
uni.sm(function(result, error) {
    if (error) {
        return uni.msg(error); // 统一错误提示
    }
    // 处理成功逻辑
}, params, options);
```

### 3. 参数构建

```javascript
// 复杂对象参数要转为JSON字符串
const complexParam = JSON.stringify({
    user: {name: '张三', age: 25},
    settings: {theme: 'dark'}
});

uni.sm(callback, ["method.name", complexParam], options);
```

### 4. 条件查询

```javascript
// 使用辅助方法构建查询条件
const condition = uni.msgwhere(
    {status: 'active'}, 
    {created_time: ['>', '2023-01-01']}
);

uni.sm(callback, ["data.search", condition], options);
```

## 总结

这套接口封装提供了灵活而统一的数据请求方式，通过三种不同的方法满足各种业务场景需求。核心特点包括：

1. **统一的认证机制** - 自动处理 Token 和 Session
2. **灵活的参数处理** - 支持简单参数和复杂对象
3. **完善的错误处理** - 统一的错误处理和用户提示
4. **多种调用方式** - 支持回调和 Promise 两种异步模式
5. **丰富的辅助方法** - 提供查询构建和消息提示等实用功能

通过这套封装，开发者可以专注于业务逻辑实现，而无需关心底层的网络请求细节。