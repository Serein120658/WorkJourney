# ReadWriteLockActivity.java 详细解读

## 概述

这是一个Android RFID UHF标签读写器的Activity类，实现了对RFID标签的读取、写入、锁定和销毁(Kill)等核心功能。

### 源码 shit

```java
package com.pda.testuhfapi;

import androidx.appcompat.app.AppCompatActivity;

import android.annotation.SuppressLint;
import android.app.Activity;
import android.app.AlertDialog;
import android.content.DialogInterface;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.AdapterView;
import android.widget.Button;
import android.widget.EditText;
import android.widget.Spinner;
import android.widget.TextView;
import android.widget.Toast;

import com.pda.uhf.UHFEngine;
import com.pda.uhf.UHFParamsOperator;
import com.pda.uhf.UHFUtils;
import com.pda.uhf.model.params.AntPowerConfResult;
import com.uhf.api.cls.Reader;

import java.util.Locale;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ReadWriteLockActivity extends Activity {

    private TextView rw_tid_text = null;
    private EditText rw_epc_edit = null;

    private Button rw_gettid_btn = null;

    private Button rw_read_btn = null;
    private Spinner rw_mem_bank_read_spinner = null;
    private TextView rw_address_read_edittext = null;
    private TextView rw_read_length_edittext = null;
    private TextView rw_password_read_edittext = null;
    private TextView rw_read_rsp_text = null;
    private Spinner filter_mem_bank_spinner = null;
    private EditText filter_address_edittext = null;
    private EditText filterdata_edittext = null;

    private Spinner rw_mem_bank_write_spinner = null;
    private Button rw_write_btn = null;
    private EditText rw_address_write_edittext = null;
    private EditText rw_password_write_edittext = null;
    private EditText rw_data_write_edittext = null;
    private TextView rw_write_rsp_text = null;

    private Spinner lock_item_spinner = null;
    private Spinner lock_type_spinner = null;
    private EditText rw_password_lock_edittext = null;
    private Button rw_lock_btn = null;

    private EditText rw_password_kill_edittext = null;
    private Button rw_kill_btn = null;

    @SuppressLint("WrongViewCast")
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_read_write_lock);

        rw_tid_text = findViewById(R.id.rw_tid_text);
        rw_epc_edit = findViewById(R.id.rw_epc_edit);
        rw_epc_edit.setText(DefaultConfigure.currentEpc);

        rw_gettid_btn = findViewById(R.id.rw_gettid_btn);
        rw_gettid_btn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                //根据EPC数据读取TID
                byte[] rdata = new byte[12];//读取存放的存储空间
                byte[] rpaswd = {0x00,0x00,0x00,0x00};//密钥，如果标签有密钥填入自己的密钥，如果没有用全0
                Reader.TagFilter_ST g2tf = new Reader.TagFilter_ST();//创建过滤起
                //转换成EPC字节数组
                byte[] fdata = new byte[DefaultConfigure.currentEpc.length() / 2];
                UHFUtils.Str2Hex(DefaultConfigure.currentEpc, DefaultConfigure.currentEpc.length(), fdata);

                //Log.e("###",Util.bytes2hex(fdata));
                //Log.e("###",Util.bytes2hex(rpaswd));

                g2tf.fdata = fdata;
                g2tf.flen = fdata.length * 8;//长度单位是bit，所以用字节数乘以8
                g2tf.isInvert = 0;


                g2tf.bank = InventoryModeParams.BANK.EPC;//设置过滤的分区为EPC
                g2tf.startaddr = 32;//开始地址，EPC分区前32个bit是PC等数据，所以跳过前32个bit
                Reader.READER_ERR er = UHFParamsOperator.getInstance().setTagFilter(g2tf);//设置过滤条件
                if (er == Reader.READER_ERR.MT_OK_ERR) {
                    Log.e("###","设置过滤成功！");
                }
                //读tid （2），起始块 0  块数 6
                int rbank = InventoryModeParams.BANK.TID;//读取分区是TID
                int startblock = 0;//开始地址，TID的开始地址是0，如果要跳过前面的字节，设置这个数值，单位是bit
                int blockcount = 6;//设置读取的块数，读取是以块读取，每个块是2个字节，6个块就是12个字节，96个bit

                //最多循环读三次，如果三次都失败，认为读取失败
                for(int index = 0;index < 3;index++) {
                    er = UHFEngine.getEngine().getTagData(
                            1,//读取的天线，只有一个天线，设置为1
                            (char) rbank,
                            startblock,
                            blockcount,
                            rdata,
                            rpaswd,
                            (short) 1000//读取超时时间
                    );
                    if(er == Reader.READER_ERR.MT_OK_ERR)
                        break;
                }

                if (er == Reader.READER_ERR.MT_OK_ERR) {
                    //Log.e("###","TID:"+Util.bytes2hex(rdata));
                    ReadWriteLockActivity.this.runOnUiThread(new Runnable() {
                        @Override
                        public void run() {

                            rw_tid_text.setText(Util.bytes2hex(rdata).toUpperCase(Locale.ROOT));
                            Toast.makeText(getApplicationContext(),"Read TID success!",Toast.LENGTH_SHORT).show();
                        }
                    });

                }else{
                    ReadWriteLockActivity.this.runOnUiThread(new Runnable() {
                        @Override
                        public void run() {
                            Toast.makeText(getApplicationContext(),"Read TID failed!",Toast.LENGTH_SHORT).show();
                        }
                    });
                }
                UHFParamsOperator.getInstance().setTagFilter(null);//读取完毕，恢复过滤设置
            }



        });



        rw_mem_bank_read_spinner = findViewById(R.id.rw_mem_bank_read_spinner);

        rw_mem_bank_read_spinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
            @Override
            public void onItemSelected(AdapterView<?> adapterView, View view, int i, long l) {
                if(i == 1)
                    rw_address_read_edittext.setText("2");
                else
                    rw_address_read_edittext.setText("0");
            }

            @Override
            public void onNothingSelected(AdapterView<?> adapterView) {

            }
        });
        rw_address_read_edittext = findViewById(R.id.rw_address_read_edittext);
        rw_read_length_edittext = findViewById(R.id.rw_read_length_edittext);
        rw_password_read_edittext = findViewById(R.id.rw_password_read_edittext);
        rw_read_btn = findViewById(R.id.rw_read_btn);
        rw_read_rsp_text = findViewById(R.id.rw_read_rsp_text);
        rw_read_btn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                int startaddr = Integer.valueOf(rw_address_read_edittext.getText().toString().trim());
                int blocks = Integer.valueOf(rw_read_length_edittext.getText().toString().trim());
                byte[] rpaswd = new byte[rw_password_read_edittext.getText().length()/2];
                UHFUtils.Str2Hex(rw_password_read_edittext.getText().toString(), rw_password_read_edittext.getText().toString().length(), rpaswd);
                byte[] rdata = new byte[blocks*2];//读取存放的存储空间
                Reader.READER_ERR er = null;
                /*
                int readlength = Integer.valueOf(rw_read_length_edittext.getText().toString().trim());






                Reader.TagFilter_ST g2tf = new Reader.TagFilter_ST();//创建过滤器
                //转换成字节数组
                byte[] fdata = new byte[DefaultConfigure.currentEpc.length() / 2];
                UHFUtils.Str2Hex(filterdata_edittext.getText().toString(), filterdata_edittext.getText().toString().length(), fdata);

                g2tf.fdata = fdata;
                g2tf.flen = fdata.length * 8;//长度单位是bit，所以用字节数乘以8
                g2tf.isInvert = 0;

                //g2tf.bank = InventoryModeParams.BANK.EPC;//设置过滤的分区为EPC
                g2tf.bank = filter_mem_bank_spinner.getSelectedItemPosition();
                //g2tf.startaddr = 32;//开始地址，EPC分区前32个bit是PC等数据，所以跳过前32个bit

                g2tf.startaddr = Integer.valueOf(filter_address_edittext.getText().toString())*2*8;//一个块2个字节，每个字节8个bit


                Reader.READER_ERR er = UHFParamsOperator.getInstance().setTagFilter(g2tf);//设置过滤条件
                if (er == Reader.READER_ERR.MT_OK_ERR) {
                    Log.e("###","设置过滤成功！");
                }

                 */
                if(!setFilter()){
                    Toast.makeText(getApplicationContext(),"设置过滤失败！",Toast.LENGTH_SHORT).show();
                    return;
                }
                int startblock = startaddr;//开始地址，TID的开始地址是0，如果要跳过前面的字节，设置这个数值，单位是bit
                int blockcount = blocks;//设置读取的块数，读取是以块读取，每个块是2个字节，6个块就是12个字节，96个bit
                int rbank = 0;
//               TODO  这里也有问题  读取有时候成 有时候成不了
                switch (rw_mem_bank_read_spinner.getSelectedItemPosition()){
                    case 0://read reserved
                        rbank = InventoryModeParams.BANK.Reserved;//读取分区是reserved(保留区)
                        break;
                    case 1://read epc
                        //读epc （1），起始块 2  块数 6
                        rbank = InventoryModeParams.BANK.EPC;//读取分区是EPC
                        break;
                    case 2://read tid
                        //读tid （2），起始块 0  块数 6
                        rbank = InventoryModeParams.BANK.TID;//读取分区是TID
                        break;
                    case 3://read user
                        //读user （3），起始块 0  块数 6
                        rbank = InventoryModeParams.BANK.USER;//读取分区是USER
                        break;
                }
                //最多循环读三次，如果三次都失败，认为读取失败
                for(int index = 0;index < 3;index++) {
                    er = UHFEngine.getEngine().getTagData(
                            1,//读取的天线，只有一个天线，设置为1
                            (char) rbank,
                            startblock,
                            blockcount,
                            rdata,
                            rpaswd,
                            (short) 1000//读取超时时间
                    );
                    if(er == Reader.READER_ERR.MT_OK_ERR)
                        break;
                }
                if (er == Reader.READER_ERR.MT_OK_ERR) {
                    //Log.e("###","TID:"+Util.bytes2hex(rdata));
                    ReadWriteLockActivity.this.runOnUiThread(new Runnable() {
                        @Override
                        public void run() {
                            rw_read_rsp_text.setText(Util.bytes2hex(rdata).toUpperCase(Locale.ROOT));
                            Toast.makeText(getApplicationContext(),"Read success!",Toast.LENGTH_SHORT).show();
                        }
                    });

                }else{
                    ReadWriteLockActivity.this.runOnUiThread(new Runnable() {
                        @Override
                        public void run() {
                            Toast.makeText(getApplicationContext(),"Read failed!",Toast.LENGTH_SHORT).show();
                        }
                    });
                }
                //UHFParamsOperator.getInstance().setTagFilter(null);//读取完毕，恢复过滤设置为null
                resetFilter();
            }
        });

        filter_mem_bank_spinner = findViewById(R.id.filter_mem_bank_spinner);
        filter_address_edittext = findViewById(R.id.filter_address_edittext);
        filterdata_edittext = findViewById(R.id.filterdata_edittext);
        filterdata_edittext.setText(DefaultConfigure.currentEpc);
        filter_mem_bank_spinner.setSelection(1);//默认EPC
        filter_address_edittext.setText("2");
        filter_mem_bank_spinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
            @Override
            public void onItemSelected(AdapterView<?> adapterView, View view, int i, long l) {
                if(i == 1)
                    filter_address_edittext.setText("2");
                else
                    filter_address_edittext.setText("0");
            }

            @Override
            public void onNothingSelected(AdapterView<?> adapterView) {

            }
        });


        rw_mem_bank_write_spinner = findViewById(R.id.rw_mem_bank_write_spinner);
        rw_mem_bank_write_spinner.setSelection(1);//默认选择EPC
        rw_password_write_edittext = findViewById(R.id.rw_password_write_edittext);
        rw_address_write_edittext = findViewById(R.id.rw_address_write_edittext);
        rw_data_write_edittext = findViewById(R.id.rw_data_write_edittext);
        rw_write_rsp_text = findViewById(R.id.rw_write_rsp_text);
        rw_write_btn = findViewById(R.id.rw_write_btn);

        rw_mem_bank_write_spinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
            @Override
            public void onItemSelected(AdapterView<?> adapterView, View view, int i, long l) {
                if(i == 1)
                    rw_address_write_edittext.setText("2");
                else
                    rw_address_write_edittext.setText("0");
            }

            @Override
            public void onNothingSelected(AdapterView<?> adapterView) {

            }
        });

//        todo 写一直失败  ！！！！
        rw_write_btn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                if(!setFilter()){
                    ReadWriteLockActivity.this.runOnUiThread(new Runnable() {
                        @Override
                        public void run() {
                            Toast.makeText(getApplicationContext(),"设置过滤失败！",Toast.LENGTH_SHORT).show();
                        }
                    });

                    return;
                }

                int wbank = 0;//要写的分区
                switch (rw_mem_bank_write_spinner.getSelectedItemPosition()){
                    case 0://write reserved
                        wbank = InventoryModeParams.BANK.Reserved;//写入分区是reserved(保留区)
                        break;
                    case 1://write epc
                        //写epc （1），起始块 2  块数 6
                        wbank = InventoryModeParams.BANK.EPC;//写入分区是EPC
                        break;
                    case 2://write user.because tid cannot be writed,so skip tip
                        //写user （3），起始块 0  块数 6
                        wbank = InventoryModeParams.BANK.USER;//写入分区是USER,由于TID不能写，所以列表中没有TID
                        break;
                }
                int write_startaddr = Integer.valueOf(rw_address_write_edittext.getText().toString().trim());
                byte[] wpaswd = new byte[rw_password_write_edittext.getText().length()/2];
                UHFUtils.Str2Hex(rw_password_write_edittext.getText().toString(), rw_password_write_edittext.getText().toString().length(), wpaswd);
                String wdataString = rw_data_write_edittext.getText().toString();
                byte[] wdata = new byte[wdataString.length()/2];//写入存放的存储空间
                UHFUtils.Str2Hex(wdataString, wdataString.length(), wdata);
                int trycount = 3;
                Reader.READER_ERR er = null;
                do {
                    er = UHFEngine.getEngine().writeTagData(1,
                            (char) wbank,
                            write_startaddr,
                            wdata,
                            wdata.length,
                            wpaswd,
                            (short) 1000);

                    trycount--;
                    if (trycount < 1)
                        break;
                } while (er != Reader.READER_ERR.MT_OK_ERR);
                resetFilter();//恢复过滤
                if (er == Reader.READER_ERR.MT_OK_ERR) {
                    //Log.e("###","TID:"+Util.bytes2hex(rdata));
                    ReadWriteLockActivity.this.runOnUiThread(new Runnable() {
                        @Override
                        public void run() {
                            //rw_read_rsp_text.setText(Util.bytes2hex(rdata).toUpperCase(Locale.ROOT));
                            Toast.makeText(getApplicationContext(),"Write success!",Toast.LENGTH_SHORT).show();
                        }
                    });

                }else{
                    ReadWriteLockActivity.this.runOnUiThread(new Runnable() {
                        @Override
                        public void run() {
                            Toast.makeText(getApplicationContext(),"Write failed!",Toast.LENGTH_SHORT).show();
                        }
                    });
                }
            }

        });

        lock_item_spinner = findViewById(R.id.lock_item_spinner);

        lock_type_spinner = findViewById(R.id.lock_type_spinner);

        rw_password_lock_edittext = findViewById(R.id.rw_password_lock_edittext);
        rw_lock_btn = findViewById(R.id.rw_lock_btn);
        rw_lock_btn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {

                AlertDialog.Builder builder = new AlertDialog.Builder(ReadWriteLockActivity.this);
                builder.setTitle(R.string.warning); // 设置对话框标题
                builder.setMessage(R.string.lockwarning); // 设置对话框内容
                builder.setPositiveButton(R.string.commit, new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        Reader.Lock_Obj lobj = null;
                        Reader.Lock_Type ltyp = null;
                        int lbank = lock_item_spinner.getSelectedItemPosition();
                        int ltype = lock_type_spinner.getSelectedItemPosition();
                        if (lbank == 0) {
                            lobj = Reader.Lock_Obj.LOCK_OBJECT_ACCESS_PASSWD;
                            if (ltype == 0)
                                ltyp = Reader.Lock_Type.ACCESS_PASSWD_UNLOCK;
                            else if (ltype == 1)
                                ltyp = Reader.Lock_Type.ACCESS_PASSWD_LOCK;
                            else if (ltype == 2)
                                ltyp = Reader.Lock_Type.ACCESS_PASSWD_PERM_LOCK;

                        } else if (lbank == 1) {
                            lobj = Reader.Lock_Obj.LOCK_OBJECT_KILL_PASSWORD;
                            if (ltype == 0)
                                ltyp = Reader.Lock_Type.KILL_PASSWORD_UNLOCK;
                            else if (ltype == 1)
                                ltyp = Reader.Lock_Type.KILL_PASSWORD_LOCK;
                            else if (ltype == 2)
                                ltyp = Reader.Lock_Type.KILL_PASSWORD_PERM_LOCK;
                        } else if (lbank == 2) {
                            lobj = Reader.Lock_Obj.LOCK_OBJECT_BANK1;
                            if (ltype == 0)
                                ltyp = Reader.Lock_Type.BANK1_UNLOCK;
                            else if (ltype == 1)
                                ltyp = Reader.Lock_Type.BANK1_LOCK;
                            else if (ltype == 2)
                                ltyp = Reader.Lock_Type.BANK1_PERM_LOCK;
                        } else if (lbank == 3) {
                            lobj = Reader.Lock_Obj.LOCK_OBJECT_BANK2;
                            if (ltype == 0)
                                ltyp = Reader.Lock_Type.BANK2_UNLOCK;
                            else if (ltype == 1)
                                ltyp = Reader.Lock_Type.BANK2_LOCK;
                            else if (ltype == 2)
                                ltyp = Reader.Lock_Type.BANK2_PERM_LOCK;
                        } else if (lbank == 4) {
                            lobj = Reader.Lock_Obj.LOCK_OBJECT_BANK3;
                            if (ltype == 0)
                                ltyp = Reader.Lock_Type.BANK3_UNLOCK;
                            else if (ltype == 1)
                                ltyp = Reader.Lock_Type.BANK3_LOCK;
                            else if (ltype == 2)
                                ltyp = Reader.Lock_Type.BANK3_PERM_LOCK;
                        }

                        byte[] lockpaswd = new byte[4];

                        if (!rw_password_lock_edittext.getText().toString().equals("")) {
                            UHFUtils.Str2Hex(rw_password_lock_edittext.getText().toString(),
                                    rw_password_lock_edittext.getText().toString().length(), lockpaswd);
                        }
                        if(!setFilter()){
                            ReadWriteLockActivity.this.runOnUiThread(new Runnable() {
                                @Override
                                public void run() {
                                    Toast.makeText(getApplicationContext(),"设置过滤失败！",Toast.LENGTH_SHORT).show();
                                }
                            });

                            return;
                        }
                        Reader.READER_ERR er = UHFEngine.getEngine().lockTag(
                                1,
                                (byte) lobj.value(),
                                (short) ltyp.value(),
                                lockpaswd,
                                (short) 1000);
                        if (er == Reader.READER_ERR.MT_OK_ERR) {
                            ReadWriteLockActivity.this.runOnUiThread(new Runnable() {
                                @Override
                                public void run() {
                                    Toast.makeText(getApplicationContext(),"Lock Success!",Toast.LENGTH_SHORT).show();
                                }
                            });

                        } else {
                            ReadWriteLockActivity.this.runOnUiThread(new Runnable() {
                                @Override
                                public void run() {
                                    Toast.makeText(getApplicationContext(),"Lock failed!",Toast.LENGTH_SHORT).show();
                                }
                            });
                        }
                        resetFilter();
                    }
                });
                builder.setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        dialog.cancel();
                    }
                });

                AlertDialog alertDialog = builder.create();
                alertDialog.show(); // 显示对话框


            }
        });

        rw_password_kill_edittext = findViewById(R.id.rw_password_kill_edittext);
        rw_kill_btn = findViewById(R.id.rw_kill_btn);
        rw_kill_btn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {


                AlertDialog.Builder builder = new AlertDialog.Builder(ReadWriteLockActivity.this);
                builder.setTitle(R.string.warning); // 设置对话框标题
                builder.setMessage(R.string.killwarning); // 设置对话框内容
                builder.setPositiveButton(R.string.commit, new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        byte[] killpaswd = new byte[4];

                        if (!rw_password_kill_edittext.getText().toString().equals("")) {
                            UHFUtils.Str2Hex(rw_password_kill_edittext.getText().toString(),
                                    rw_password_kill_edittext.getText().toString().length(), killpaswd);
                        }
                        if(!setFilter()){
                            ReadWriteLockActivity.this.runOnUiThread(new Runnable() {
                                @Override
                                public void run() {
                                    Toast.makeText(getApplicationContext(),"设置过滤失败！",Toast.LENGTH_SHORT).show();
                                }
                            });

                            return;
                        }
                        Reader.READER_ERR er = UHFEngine.getEngine().killTag(
                                1,
                                killpaswd,
                                (short) 1000);

                        if (er == Reader.READER_ERR.MT_OK_ERR) {
                            ReadWriteLockActivity.this.runOnUiThread(new Runnable() {
                                @Override
                                public void run() {
                                    Toast.makeText(getApplicationContext(),"Kill success!",Toast.LENGTH_SHORT).show();
                                }
                            });
                        } else {
                            ReadWriteLockActivity.this.runOnUiThread(new Runnable() {
                                @Override
                                public void run() {
                                    Toast.makeText(getApplicationContext(),"Kill failed!",Toast.LENGTH_SHORT).show();
                                }
                            });
                        }
                        resetFilter();
                    }
                });
                builder.setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        dialog.cancel();
                    }
                });

                AlertDialog alertDialog = builder.create();
                alertDialog.show(); // 显示对话框
            }

        });
    }

    private boolean setFilter(){
        //int readlength = Integer.valueOf(rw_read_length_edittext.getText().toString().trim());
        //int startaddr = Integer.valueOf(rw_address_read_edittext.getText().toString().trim());
        int blocks = Integer.valueOf(rw_read_length_edittext.getText().toString().trim());
        //byte[] rpaswd = new byte[rw_password_read_edittext.getText().length()/2];
        //UHFUtils.Str2Hex(rw_password_read_edittext.getText().toString(), rw_password_read_edittext.getText().toString().length(), rpaswd);

        byte[] rdata = new byte[blocks*2];//读取存放的存储空间

        Reader.TagFilter_ST g2tf = new Reader.TagFilter_ST();//创建过滤器
        //转换成字节数组
        if(filterdata_edittext.getText().toString().length() == 0 || filterdata_edittext.getText().toString().length()%2 != 0){
            return false;
        }
        byte[] fdata = new byte[filterdata_edittext.getText().toString().length() / 2];
        UHFUtils.Str2Hex(filterdata_edittext.getText().toString(), filterdata_edittext.getText().toString().length(), fdata);

        g2tf.fdata = fdata;
        g2tf.flen = fdata.length * 8;//长度单位是bit，所以用字节数乘以8
        g2tf.isInvert = 0;

        //g2tf.bank = InventoryModeParams.BANK.EPC;//设置过滤的分区为EPC
        g2tf.bank = filter_mem_bank_spinner.getSelectedItemPosition();
        //g2tf.startaddr = 32;//开始地址，EPC分区前32个bit是PC等数据，所以跳过前32个bit

        g2tf.startaddr = Integer.valueOf(filter_address_edittext.getText().toString())*2*8;//一个块2个字节，每个字节8个bit


        Reader.READER_ERR er = UHFParamsOperator.getInstance().setTagFilter(g2tf);//设置过滤条件
        if (er == Reader.READER_ERR.MT_OK_ERR) {
            Log.e("###","设置过滤成功！");
            return true;
        }
        return false;
    }
    private void resetFilter(){
        UHFParamsOperator.getInstance().setTagFilter(null);//读取完毕，恢复过滤设置为null
    }

    protected void onResume() {
        //上电
        UHFEngine.getEngine().powerOn();
        //连接模块
        Reader.READER_ERR er = UHFEngine.getEngine().connectModule(DefaultConfigure.UART_DEV_PATH, 1);
        if(er == Reader.READER_ERR.MT_OK_ERR){
            DefaultConfigure.defaultInitModule();
            //AntPowerConfResult result = UHFParamsOperator.getInstance().getAntPowerConf();
            Log.e("####","connect success!");
        }else{
            Log.e("####","connect failed!");

        }
        super.onResume();
    }

    @Override
    protected void onPause() {
        //断开连接
        UHFEngine.getEngine().disconnectModule();
        //下电
        UHFEngine.getEngine().powerOff();
        super.onPause();
    }

}
```

### 重构后

```java
package com.pda.testuhfapi;

import androidx.appcompat.app.AppCompatActivity;

import android.annotation.SuppressLint;
import android.app.Activity;
import android.app.AlertDialog;
import android.content.DialogInterface;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.AdapterView;
import android.widget.Button;
import android.widget.EditText;
import android.widget.Spinner;
import android.widget.TextView;
import android.widget.Toast;

import com.pda.uhf.UHFEngine;
import com.pda.uhf.UHFParamsOperator;
import com.pda.uhf.UHFUtils;
import com.pda.uhf.model.params.AntPowerConfResult;
import com.uhf.api.cls.Reader;

import java.util.Locale;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * RFID标签读写锁定Activity - 重构版
 * 功能：实现RFID标签的读取、写入、锁定和销毁操作
 */
public class ReadWriteLockActivity extends Activity {

    private static final String TAG = "ReadWriteLockActivity";
    
    // ==================== 常量定义 ====================
    
    /** 默认密码 - 全0表示无密码保护 */
    private static final byte[] DEFAULT_PASSWORD = {0x00, 0x00, 0x00, 0x00};
    
    /** 最大重试次数 */
    private static final int MAX_RETRY_COUNT = 3;
    
    /** 操作超时时间(毫秒) */
    private static final short OPERATION_TIMEOUT = 1000;
    
    /** 天线编号 - 单天线设备固定为1 */
    private static final int ANTENNA_ID = 1;
    
    /** TID读取块数 - 6块=12字节=96bit */
    private static final int TID_BLOCK_COUNT = 6;
    
    /** EPC区默认起始地址 - 跳过PC数据(前2块) */
    private static final int EPC_DEFAULT_START_ADDRESS = 2;
    
    /** TID区起始地址 */
    private static final int TID_START_ADDRESS = 0;
    
    /** EPC区过滤起始位 - 跳过PC的16bit */
    private static final int EPC_FILTER_START_BIT = 32;
    
    // ==================== UI组件 ====================
    
    // TID相关
    private TextView tidDisplayText;
    private EditText epcInputEdit;
    private Button getTidButton;

    // 读取操作相关
    private Button readButton;
    private Spinner readMemBankSpinner;
    private TextView readAddressText;
    private TextView readLengthText;
    private TextView readPasswordText;
    private TextView readResponseText;

    // 过滤器相关
    private Spinner filterMemBankSpinner;
    private EditText filterAddressEdit;
    private EditText filterDataEdit;

    // 写入操作相关
    private Spinner writeMemBankSpinner;
    private Button writeButton;
    private EditText writeAddressEdit;
    private EditText writePasswordEdit;
    private EditText writeDataEdit;
    private TextView writeResponseText;

    // 锁定操作相关
    private Spinner lockItemSpinner;
    private Spinner lockTypeSpinner;
    private EditText lockPasswordEdit;
    private Button lockButton;

    // 销毁操作相关
    private EditText killPasswordEdit;
    private Button killButton;
    
    // ==================== 生命周期方法 ====================

    @SuppressLint("WrongViewCast")
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_read_write_lock);

        initializeViews();
        setupEventListeners();
        initializeDefaultValues();
    }

    @Override
    protected void onResume() {
        super.onResume();
        connectRFIDModule();
    }

    @Override
    protected void onPause() {
        super.onPause();
        disconnectRFIDModule();
    }

    // ==================== 初始化方法 ====================

    /**
     * 初始化所有UI组件
     */
    private void initializeViews() {
        // TID相关
        tidDisplayText = findViewById(R.id.rw_tid_text);
        epcInputEdit = findViewById(R.id.rw_epc_edit);
        getTidButton = findViewById(R.id.rw_gettid_btn);

        // 读取操作
        readButton = findViewById(R.id.rw_read_btn);
        readMemBankSpinner = findViewById(R.id.rw_mem_bank_read_spinner);
        readAddressText = findViewById(R.id.rw_address_read_edittext);
        readLengthText = findViewById(R.id.rw_read_length_edittext);
        readPasswordText = findViewById(R.id.rw_password_read_edittext);
        readResponseText = findViewById(R.id.rw_read_rsp_text);

        // 过滤器
        filterMemBankSpinner = findViewById(R.id.filter_mem_bank_spinner);
        filterAddressEdit = findViewById(R.id.filter_address_edittext);
        filterDataEdit = findViewById(R.id.filterdata_edittext);

        // 写入操作
        writeMemBankSpinner = findViewById(R.id.rw_mem_bank_write_spinner);
        writeButton = findViewById(R.id.rw_write_btn);
        writeAddressEdit = findViewById(R.id.rw_address_write_edittext);
        writePasswordEdit = findViewById(R.id.rw_password_write_edittext);
        writeDataEdit = findViewById(R.id.rw_data_write_edittext);
        writeResponseText = findViewById(R.id.rw_write_rsp_text);

        // 锁定操作
        lockItemSpinner = findViewById(R.id.lock_item_spinner);
        lockTypeSpinner = findViewById(R.id.lock_type_spinner);
        lockPasswordEdit = findViewById(R.id.rw_password_lock_edittext);
        lockButton = findViewById(R.id.rw_lock_btn);

        // 销毁操作
        killPasswordEdit = findViewById(R.id.rw_password_kill_edittext);
        killButton = findViewById(R.id.rw_kill_btn);
    }

    /**
     * 设置所有事件监听器
     */
    private void setupEventListeners() {
        getTidButton.setOnClickListener(v -> handleGetTidOperation());
        readButton.setOnClickListener(v -> handleReadOperation());
        writeButton.setOnClickListener(v -> handleWriteOperation());
        lockButton.setOnClickListener(v -> handleLockOperation());
        killButton.setOnClickListener(v -> handleKillOperation());

        setupSpinnerListeners();
    }

    /**
     * 设置Spinner的监听器
     */
    private void setupSpinnerListeners() {
        // 读取内存区域选择监听
        readMemBankSpinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
            @Override
            public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
                // EPC区从块2开始(跳过PC数据)，其他区从块0开始
                readAddressText.setText(position == 1 ? "2" : "0");
            }

            @Override
            public void onNothingSelected(AdapterView<?> parent) {
            }
        });

        // 过滤器内存区域选择监听
        filterMemBankSpinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
            @Override
            public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
                // EPC区过滤地址从块2开始，其他区从块0开始
                filterAddressEdit.setText(position == 1 ? "2" : "0");
            }

            @Override
            public void onNothingSelected(AdapterView<?> parent) {
            }
        });

        // 写入内存区域选择监听
        writeMemBankSpinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
            @Override
            public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
                // EPC区写入地址从块2开始，其他区从块0开始
                writeAddressEdit.setText(position == 1 ? "2" : "0");
            }

            @Override
            public void onNothingSelected(AdapterView<?> parent) {
            }
        });
    }

    /**
     * 初始化默认值
     */
    private void initializeDefaultValues() {
        epcInputEdit.setText(DefaultConfigure.currentEpc);
        filterDataEdit.setText(DefaultConfigure.currentEpc);
        
        // 默认选择EPC区进行过滤和写入
        filterMemBankSpinner.setSelection(1);
        writeMemBankSpinner.setSelection(1);
        
        // 设置默认地址
        filterAddressEdit.setText("2");
        writeAddressEdit.setText("2");
    }

    // ==================== RFID模块连接管理 ====================

    /**
     * 连接RFID模块
     * 在Activity恢复时调用
     */
    private void connectRFIDModule() {
        // 给模块上电
        UHFEngine.getEngine().powerOn();
        
        // 连接UART设备
        Reader.READER_ERR result = UHFEngine.getEngine().connectModule(
                DefaultConfigure.UART_DEV_PATH, 
                1
        );
        
        if (result == Reader.READER_ERR.MT_OK_ERR) {
            DefaultConfigure.defaultInitModule();
            Log.i(TAG, "RFID模块连接成功");
        } else {
            Log.e(TAG, "RFID模块连接失败");
            showToast("RFID模块连接失败");
        }
    }

    /**
     * 断开RFID模块
     * 在Activity暂停时调用
     */
    private void disconnectRFIDModule() {
        // 断开连接
        UHFEngine.getEngine().disconnectModule();
        
        // 给模块下电
        UHFEngine.getEngine().powerOff();
        
        Log.i(TAG, "RFID模块已断开");
    }

    // ==================== TID读取操作 ====================

    /**
     * 处理TID读取操作
     * 根据EPC数据读取标签的TID（Tag Identifier）
     */
    private void handleGetTidOperation() {
        new Thread(() -> {
            try {
                // 准备数据缓冲区 - TID通常为12字节(96bit)
                byte[] tidData = new byte[TID_BLOCK_COUNT * 2];
                
                // 设置基于EPC的过滤器
                if (!setupEpcFilter()) {
                    showToastOnUiThread("设置EPC过滤器失败");
                    return;
                }
                
                // 执行TID读取操作（最多重试3次）
                Reader.READER_ERR result = performReadWithRetry(
                        InventoryModeParams.BANK.TID,
                        TID_START_ADDRESS,
                        TID_BLOCK_COUNT,
                        tidData,
                        DEFAULT_PASSWORD
                );
                
                // 重置过滤器
                resetFilter();
                
                // 处理结果
                if (result == Reader.READER_ERR.MT_OK_ERR) {
                    String tidHex = Util.bytes2hex(tidData).toUpperCase(Locale.ROOT);
                    updateTidDisplay(tidHex, true);
                } else {
                    updateTidDisplay(null, false);
                }
                
            } catch (Exception e) {
                Log.e(TAG, "TID读取异常", e);
                showToastOnUiThread("TID读取异常: " + e.getMessage());
            }
        }).start();
    }

    /**
     * 设置基于EPC的过滤器
     * 用于精确定位特定标签
     * 
     * @return 是否设置成功
     */
    private boolean setupEpcFilter() {
        String currentEpc = DefaultConfigure.currentEpc;
        
        // 将EPC字符串转换为字节数组
        byte[] epcBytes = new byte[currentEpc.length() / 2];
        UHFUtils.Str2Hex(currentEpc, currentEpc.length(), epcBytes);
        
        // 创建过滤器配置
        Reader.TagFilter_ST filter = new Reader.TagFilter_ST();
        filter.fdata = epcBytes;
        filter.flen = epcBytes.length * 8;  // 长度单位是bit
        filter.isInvert = 0;  // 不反转
        filter.bank = InventoryModeParams.BANK.EPC;  // 在EPC区进行过滤
        filter.startaddr = EPC_FILTER_START_BIT;  // 跳过PC数据(前32bit)
        
        // 应用过滤器
        Reader.READER_ERR result = UHFParamsOperator.getInstance().setTagFilter(filter);
        
        if (result == Reader.READER_ERR.MT_OK_ERR) {
            Log.d(TAG, "EPC过滤器设置成功");
            return true;
        } else {
            Log.e(TAG, "EPC过滤器设置失败: " + result);
            return false;
        }
    }

    /**
     * 更新TID显示
     * 
     * @param tidHex TID的十六进制字符串
     * @param success 是否成功
     */
    private void updateTidDisplay(String tidHex, boolean success) {
        runOnUiThread(() -> {
            if (success && tidHex != null) {
                tidDisplayText.setText(tidHex);
                showToast("TID读取成功!");
            } else {
                showToast("TID读取失败!");
            }
        });
    }

    // ==================== 通用读取操作 ====================

    /**
     * 处理读取操作
     * 读取标签的指定内存区域
     */
    private void handleReadOperation() {
        new Thread(() -> {
            try {
                // 获取读取参数
                int startAddress = Integer.parseInt(readAddressText.getText().toString().trim());
                int blockCount = Integer.parseInt(readLengthText.getText().toString().trim());
                int memoryBank = getMemoryBankFromSpinner(readMemBankSpinner);
                
                // 解析访问密码
                byte[] password = parsePassword(readPasswordText.getText().toString());
                
                // 准备数据缓冲区 - 每块2字节
                byte[] readData = new byte[blockCount * 2];
                
                // 设置过滤器
                if (!setupCustomFilter()) {
                    showToastOnUiThread("设置过滤器失败!");
                    return;
                }
                
                // 执行读取操作（最多重试3次）
                Reader.READER_ERR result = performReadWithRetry(
                        memoryBank,
                        startAddress,
                        blockCount,
                        readData,
                        password
                );
                
                // 重置过滤器
                resetFilter();
                
                // 处理结果
                if (result == Reader.READER_ERR.MT_OK_ERR) {
                    String dataHex = Util.bytes2hex(readData).toUpperCase(Locale.ROOT);
                    updateReadDisplay(dataHex, true);
                } else {
                    updateReadDisplay(null, false);
                }
                
            } catch (NumberFormatException e) {
                Log.e(TAG, "参数格式错误", e);
                showToastOnUiThread("参数格式错误");
            } catch (Exception e) {
                Log.e(TAG, "读取操作异常", e);
                showToastOnUiThread("读取异常: " + e.getMessage());
            }
        }).start();
    }

    /**
     * 执行带重试机制的读取操作
     * 
     * @param bank 内存区域
     * @param startBlock 起始块地址
     * @param blockCount 块数量
     * @param dataBuffer 数据缓冲区
     * @param password 访问密码
     * @return 操作结果
     */
    private Reader.READER_ERR performReadWithRetry(int bank, int startBlock, 
                                                    int blockCount, byte[] dataBuffer, 
                                                    byte[] password) {
        Reader.READER_ERR result = null;
        
        // 最多重试3次
        for (int attempt = 0; attempt < MAX_RETRY_COUNT; attempt++) {
            result = UHFEngine.getEngine().getTagData(
                    ANTENNA_ID,
                    (char) bank,
                    startBlock,
                    blockCount,
                    dataBuffer,
                    password,
                    OPERATION_TIMEOUT
            );
            
            if (result == Reader.READER_ERR.MT_OK_ERR) {
                Log.d(TAG, "读取成功 (尝试次数: " + (attempt + 1) + ")");
                break;
            }
            
            Log.w(TAG, "读取失败，尝试次数: " + (attempt + 1) + ", 错误: " + result);
        }
        
        return result;
    }

    /**
     * 更新读取结果显示
     * 
     * @param dataHex 读取数据的十六进制字符串
     * @param success 是否成功
     */
    private void updateReadDisplay(String dataHex, boolean success) {
        runOnUiThread(() -> {
            if (success && dataHex != null) {
                readResponseText.setText(dataHex);
                showToast("读取成功!");
            } else {
                showToast("读取失败!");
            }
        });
    }

    // ==================== 写入操作 ====================

    /**
     * 处理写入操作
     * 向标签的指定内存区域写入数据
     */
    private void handleWriteOperation() {
        new Thread(() -> {
            try {
                // 获取写入参数
                int startAddress = Integer.parseInt(writeAddressEdit.getText().toString().trim());
                int memoryBank = getMemoryBankFromSpinner(writeMemBankSpinner);
                String dataHexString = writeDataEdit.getText().toString().trim();
                
                // 验证数据格式
                if (!isValidHexString(dataHexString)) {
                    showToastOnUiThread("数据格式错误，请输入有效的十六进制字符串");
                    return;
                }
                
                // 解析密码和数据
                byte[] password = parsePassword(writePasswordEdit.getText().toString());
                byte[] writeData = hexStringToBytes(dataHexString);
                
                // 设置过滤器
                if (!setupCustomFilter()) {
                    showToastOnUiThread("设置过滤器失败!");
                    return;
                }
                
                // 执行写入操作（最多重试3次）
                Reader.READER_ERR result = performWriteWithRetry(
                        memoryBank,
                        startAddress,
                        writeData,
                        password
                );
                
                // 重置过滤器
                resetFilter();
                
                // 处理结果
                if (result == Reader.READER_ERR.MT_OK_ERR) {
                    showToastOnUiThread("写入成功!");
                } else {
                    showToastOnUiThread("写入失败! 错误: " + result);
                }
                
            } catch (NumberFormatException e) {
                Log.e(TAG, "参数格式错误", e);
                showToastOnUiThread("参数格式错误");
            } catch (Exception e) {
                Log.e(TAG, "写入操作异常", e);
                showToastOnUiThread("写入异常: " + e.getMessage());
            }
        }).start();
    }

    /**
     * 执行带重试机制的写入操作
     * 
     * @param bank 内存区域
     * @param startAddress 起始地址
     * @param data 写入数据
     * @param password 访问密码
     * @return 操作结果
     */
    private Reader.READER_ERR performWriteWithRetry(int bank, int startAddress, 
                                                     byte[] data, byte[] password) {
        Reader.READER_ERR result = null;
        
        // 最多重试3次
        for (int attempt = 0; attempt < MAX_RETRY_COUNT; attempt++) {
            result = UHFEngine.getEngine().writeTagData(
                    ANTENNA_ID,
                    (char) bank,
                    startAddress,
                    data,
                    data.length,
                    password,
                    OPERATION_TIMEOUT
            );
            
            if (result == Reader.READER_ERR.MT_OK_ERR) {
                Log.d(TAG, "写入成功 (尝试次数: " + (attempt + 1) + ")");
                break;
            }
            
            Log.w(TAG, "写入失败，尝试次数: " + (attempt + 1) + ", 错误: " + result);
        }
        
        return result;
    }

    // ==================== 锁定操作 ====================

    /**
     * 处理锁定操作
     * 锁定标签的特定内存区域或密码
     * 警告：永久锁定操作不可逆！
     */
    private void handleLockOperation() {
        // 显示警告对话框
        new AlertDialog.Builder(this)
                .setTitle(R.string.warning)
                .setMessage(R.string.lockwarning)
                .setPositiveButton(R.string.commit, (dialog, which) -> executeLockOperation())
                .setNegativeButton(R.string.cancel, (dialog, which) -> dialog.cancel())
                .show();
    }

    /**
     * 执行锁定操作
     */
    private void executeLockOperation() {
        new Thread(() -> {
            try {
                // 获取锁定参数
                int lockItemIndex = lockItemSpinner.getSelectedItemPosition();
                int lockTypeIndex = lockTypeSpinner.getSelectedItemPosition();
                
                // 确定锁定对象和类型
                LockConfig lockConfig = getLockConfig(lockItemIndex, lockTypeIndex);
                if (lockConfig == null) {
                    showToastOnUiThread("锁定配置错误");
                    return;
                }
                
                // 解析访问密码
                byte[] password = parsePassword(lockPasswordEdit.getText().toString());
                
                // 设置过滤器
                if (!setupCustomFilter()) {
                    showToastOnUiThread("设置过滤器失败!");
                    return;
                }
                
                // 执行锁定操作
                Reader.READER_ERR result = UHFEngine.getEngine().lockTag(
                        ANTENNA_ID,
                        (byte) lockConfig.lockObject.value(),
                        (short) lockConfig.lockType.value(),
                        password,
                        OPERATION_TIMEOUT
                );
                
                // 重置过滤器
                resetFilter();
                
                // 处理结果
                if (result == Reader.READER_ERR.MT_OK_ERR) {
                    showToastOnUiThread("锁定成功!");
                } else {
                    showToastOnUiThread("锁定失败! 错误: " + result);
                }
                
            } catch (Exception e) {
                Log.e(TAG, "锁定操作异常", e);
                showToastOnUiThread("锁定异常: " + e.getMessage());
            }
        }).start();
    }

    /**
     * 锁定配置类
     */
    private static class LockConfig {
        Reader.Lock_Obj lockObject;
        Reader.Lock_Type lockType;
        
        LockConfig(Reader.Lock_Obj obj, Reader.Lock_Type type) {
            this.lockObject = obj;
            this.lockType = type;
        }
    }

    /**
     * 根据选择获取锁定配置
     * 
     * @param itemIndex 锁定项目索引 (0=访问密码, 1=销毁密码, 2=EPC区, 3=TID区, 4=USER区)
     * @param typeIndex 锁定类型索引 (0=解锁, 1=锁定, 2=永久锁定)
     * @return 锁定配置对象
     */
    private LockConfig getLockConfig(int itemIndex, int typeIndex) {
        Reader.Lock_Obj lockObj = null;
        Reader.Lock_Type lockType = null;
        
        // 根据锁定项目确定对象
        switch (itemIndex) {
            case 0:  // 访问密码
                lockObj = Reader.Lock_Obj.LOCK_OBJECT_ACCESS_PASSWD;
                lockType = getAccessPasswordLockType(typeIndex);
                break;
            case 1:  // 销毁密码
                lockObj = Reader.Lock_Obj.LOCK_OBJECT_KILL_PASSWORD;
                lockType = getKillPasswordLockType(typeIndex);
                break;
            case 2:  // EPC区 (BANK1)
                lockObj = Reader.Lock_Obj.LOCK_OBJECT_BANK1;
                lockType = getBank1LockType(typeIndex);
                break;
            case 3:  // TID区 (BANK2)
                lockObj = Reader.Lock_Obj.LOCK_OBJECT_BANK2;
                lockType = getBank2LockType(typeIndex);
                break;
            case 4:  // USER区 (BANK3)
                lockObj = Reader.Lock_Obj.LOCK_OBJECT_BANK3;
                lockType = getBank3LockType(typeIndex);
                break;
        }
        
        if (lockObj != null && lockType != null) {
            return new LockConfig(lockObj, lockType);
        }
        return null;
    }

    private Reader.Lock_Type getAccessPasswordLockType(int typeIndex) {
        switch (typeIndex) {
            case 0: return Reader.Lock_Type.ACCESS_PASSWD_UNLOCK;
            case 1: return Reader.Lock_Type.ACCESS_PASSWD_LOCK;
            case 2: return Reader.Lock_Type.ACCESS_PASSWD_PERM_LOCK;
            default: return null;
        }
    }

    private Reader.Lock_Type getKillPasswordLockType(int typeIndex) {
        switch (typeIndex) {
            case 0: return Reader.Lock_Type.KILL_PASSWORD_UNLOCK;
            case 1: return Reader.Lock_Type.KILL_PASSWORD_LOCK;
            case 2: return Reader.Lock_Type.KILL_PASSWORD_PERM_LOCK;
            default: return null;
        }
    }

    private Reader.Lock_Type getBank1LockType(int typeIndex) {
        switch (typeIndex) {
            case 0: return Reader.Lock_Type.BANK1_UNLOCK;
            case 1: return Reader.Lock_Type.BANK1_LOCK;
            case 2: return Reader.Lock_Type.BANK1_PERM_LOCK;
            default: return null;
        }
    }

    private Reader.Lock_Type getBank2LockType(int typeIndex) {
        switch (typeIndex) {
            case 0: return Reader.Lock_Type.BANK2_UNLOCK;
            case 1: return Reader.Lock_Type.BANK2_LOCK;
            case 2: return Reader.Lock_Type.BANK2_PERM_LOCK;
            default: return null;
        }
    }

    private Reader.Lock_Type getBank3LockType(int typeIndex) {
        switch (typeIndex) {
            case 0: return Reader.Lock_Type.BANK3_UNLOCK;
            case 1: return Reader.Lock_Type.BANK3_LOCK;
            case 2: return Reader.Lock_Type.BANK3_PERM_LOCK;
            default: return null;
        }
    }

    // ==================== 销毁操作 ====================

    /**
     * 处理销毁操作
     * 永久销毁标签，使其无法再被读取或写入
     * 警告：此操作不可逆！
     */
    private void handleKillOperation() {
        // 显示警告对话框
        new AlertDialog.Builder(this)
                .setTitle(R.string.warning)
                .setMessage(R.string.killwarning)
                .setPositiveButton(R.string.commit, (dialog, which) -> executeKillOperation())
                .setNegativeButton(R.string.cancel, (dialog, which) -> dialog.cancel())
                .show();
    }

    /**
     * 执行销毁操作
     */
    private void executeKillOperation() {
        new Thread(() -> {
            try {
                // 解析销毁密码 - 必须提供正确的Kill Password
                byte[] killPassword = parsePassword(killPasswordEdit.getText().toString());
                
                // 设置过滤器
                if (!setupCustomFilter()) {
                    showToastOnUiThread("设置过滤器失败!");
                    return;
                }
                
                // 执行销毁操作
                Reader.READER_ERR result = UHFEngine.getEngine().killTag(
                        ANTENNA_ID,
                        killPassword,
                        OPERATION_TIMEOUT
                );
                
                // 重置过滤器
                resetFilter();
                
                // 处理结果
                if (result == Reader.READER_ERR.MT_OK_ERR) {
                    showToastOnUiThread("标签销毁成功!");
                } else {
                    showToastOnUiThread("标签销毁失败! 错误: " + result);
                }
                
            } catch (Exception e) {
                Log.e(TAG, "销毁操作异常", e);
                showToastOnUiThread("销毁异常: " + e.getMessage());
            }
        }).start();
    }

    // ==================== 过滤器管理 ====================

    /**
     * 设置自定义过滤器
     * 根据UI中的过滤参数设置过滤器
     * 
     * @return 是否设置成功
     */
    private boolean setupCustomFilter() {
        try {
            // 获取过滤数据
            String filterDataHex = filterDataEdit.getText().toString().trim();
            
            // 验证过滤数据
            if (!isValidHexString(filterDataHex)) {
                Log.e(TAG, "过滤数据格式无效");
                return false;
            }
            
            // 转换为字节数组
            byte[] filterData = hexStringToBytes(filterDataHex);
            
            // 获取过滤参数
            int filterBank = filterMemBankSpinner.getSelectedItemPosition();
            int filterAddress = Integer.parseInt(filterAddressEdit.getText().toString().trim());
            
            // 创建过滤器配置
            Reader.TagFilter_ST filter = new Reader.TagFilter_ST();
            filter.fdata = filterData;
            filter.flen = filterData.length * 8;  // 长度单位是bit
            filter.isInvert = 0;  // 不反转
            filter.bank = filterBank;
            // 地址转换: 块地址 -> 字节地址 -> bit地址
            // 公式: 块数 * 2字节/块 * 8bit/字节
            filter.startaddr = filterAddress * 2 * 8;
            
            // 应用过滤器
            Reader.READER_ERR result = UHFParamsOperator.getInstance().setTagFilter(filter);
            
            if (result == Reader.READER_ERR.MT_OK_ERR) {
                Log.d(TAG, "过滤器设置成功");
                return true;
            } else {
                Log.e(TAG, "过滤器设置失败: " + result);
                return false;
            }
            
        } catch (NumberFormatException e) {
            Log.e(TAG, "过滤地址格式错误", e);
            return false;
        } catch (Exception e) {
            Log.e(TAG, "设置过滤器异常", e);
            return false;
        }
    }

    /**
     * 重置过滤器
     * 清除过滤条件，允许所有标签响应
     */
    private void resetFilter() {
        UHFParamsOperator.getInstance().setTagFilter(null);
        Log.d(TAG, "过滤器已重置");
    }

    // ==================== 工具方法 ====================

    /**
     * 从Spinner获取内存区域代码
     * 
     * @param spinner Spinner对象
     * @return 内存区域代码
     */
    private int getMemoryBankFromSpinner(Spinner spinner) {
        int position = spinner.getSelectedItemPosition();
        
        // 读取Spinner: 0=Reserved, 1=EPC, 2=TID, 3=USER
        // 写入Spinner: 0=Reserved, 1=EPC, 2=USER (TID不可写)
        switch (position) {
            case 0:
                return InventoryModeParams.BANK.Reserved;
            case 1:
                return InventoryModeParams.BANK.EPC;
            case 2:
                // 如果是写入Spinner，位置2是USER区
                // 如果是读取Spinner，位置2是TID区
                if (spinner == writeMemBankSpinner) {
                    return InventoryModeParams.BANK.USER;
                } else {
                    return InventoryModeParams.BANK.TID;
                }
            case 3:
                return InventoryModeParams.BANK.USER;
            default:
                return InventoryModeParams.BANK.EPC;
        }
    }

    /**
     * 解析密码字符串为字节数组
     * 
     * @param passwordHex 密码的十六进制字符串
     * @return 密码字节数组，如果为空则返回默认密码(全0)
     */
    private byte[] parsePassword(String passwordHex) {
        if (passwordHex == null || passwordHex.trim().isEmpty()) {
            return DEFAULT_PASSWORD;
        }
        
        String trimmedPassword = passwordHex.trim();
        byte[] password = new byte[trimmedPassword.length() / 2];
        UHFUtils.Str2Hex(trimmedPassword, trimmedPassword.length(), password);
        
        return password;
    }

    /**
     * 验证是否为有效的十六进制字符串
     * 
     * @param hexString 待验证的字符串
     * @return 是否有效
     */
    private boolean isValidHexString(String hexString) {
        if (hexString == null || hexString.isEmpty()) {
            return false;
        }
        
        // 长度必须是偶数
        if (hexString.length() % 2 != 0) {
            Log.w(TAG, "十六进制字符串长度必须是偶数");
            return false;
        }
        
        // 只能包含0-9、A-F、a-f
        if (!hexString.matches("[0-9A-Fa-f]+")) {
            Log.w(TAG, "包含非十六进制字符");
            return false;
        }
        
        return true;
    }

    /**
     * 十六进制字符串转字节数组
     * 
     * @param hexString 十六进制字符串
     * @return 字节数组
     */
    private byte[] hexStringToBytes(String hexString) {
        byte[] bytes = new byte[hexString.length() / 2];
        UHFUtils.Str2Hex(hexString, hexString.length(), bytes);
        return bytes;
    }

    /**
     * 在UI线程显示Toast消息
     * 
     * @param message 消息内容
     */
    private void showToastOnUiThread(String message) {
        runOnUiThread(() -> showToast(message));
    }

    /**
     * 显示Toast消息
     * 
     * @param message 消息内容
     */
    private void showToast(String message) {
        Toast.makeText(getApplicationContext(), message, Toast.LENGTH_SHORT).show();
    }

    // ==================== 内存区域常量类 ====================
    
    /**
     * 内存区域参数类
     * 定义RFID标签的内存区域代码
     */
    public static class InventoryModeParams {
        public static class BANK {
            /** Reserved区 - 存储访问密码和销毁密码 */
            public static final int Reserved = 0;
            
            /** EPC区 - 存储电子产品码 */
            public static final int EPC = 1;
            
            /** TID区 - 存储标签唯一标识符(只读) */
            public static final int TID = 2;
            
            /** USER区 - 用户自定义数据区 */
            public static final int USER = 3;
        }
    }
}
```

------

## 一、类的基本结构

### 1.1 继承关系

```java
public class ReadWriteLockActivity extends Activity
```

- 继承自`Activity`，是Android的基础活动类

### 1.2 主要UI组件

```java
// TID相关
private TextView rw_tid_text;          // 显示TID数据
private EditText rw_epc_edit;          // 输入EPC数据
private Button rw_gettid_btn;          // 获取TID按钮

// 读取相关
private Button rw_read_btn;                      // 读取按钮
private Spinner rw_mem_bank_read_spinner;        // 选择读取的内存区域
private TextView rw_address_read_edittext;       // 读取起始地址
private TextView rw_read_length_edittext;        // 读取长度
private TextView rw_password_read_edittext;      // 读取密码
private TextView rw_read_rsp_text;               // 显示读取结果

// 过滤器相关
private Spinner filter_mem_bank_spinner;         // 过滤器内存区域
private EditText filter_address_edittext;        // 过滤器地址
private EditText filterdata_edittext;            // 过滤数据

// 写入相关
private Spinner rw_mem_bank_write_spinner;       // 选择写入的内存区域
private Button rw_write_btn;                     // 写入按钮
private EditText rw_address_write_edittext;      // 写入起始地址
private EditText rw_password_write_edittext;     // 写入密码
private EditText rw_data_write_edittext;         // 写入数据
private TextView rw_write_rsp_text;              // 显示写入结果

// 锁定相关
private Spinner lock_item_spinner;               // 锁定项目
private Spinner lock_type_spinner;               // 锁定类型
private EditText rw_password_lock_edittext;      // 锁定密码
private Button rw_lock_btn;                      // 锁定按钮

// 销毁相关
private EditText rw_password_kill_edittext;      // 销毁密码
private Button rw_kill_btn;                      // 销毁按钮
```

------

## 二、核心功能详解

### 2.1 读取TID功能

#### 功能描述

根据EPC数据读取RFID标签的TID(Tag Identifier，标签标识符)

#### 实现流程

```java
rw_gettid_btn.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View view) {
        // 1. 准备数据缓冲区
        byte[] rdata = new byte[12];  // 存储读取的12字节TID数据
        byte[] rpaswd = {0x00,0x00,0x00,0x00};  // 密码（全0表示无密码）
        
        // 2. 创建并配置过滤器
        Reader.TagFilter_ST g2tf = new Reader.TagFilter_ST();
        
        // 3. 将EPC字符串转换为字节数组
        byte[] fdata = new byte[DefaultConfigure.currentEpc.length() / 2];
        UHFUtils.Str2Hex(DefaultConfigure.currentEpc, 
                        DefaultConfigure.currentEpc.length(), fdata);
        
        // 4. 设置过滤器参数
        g2tf.fdata = fdata;
        g2tf.flen = fdata.length * 8;  // 长度单位是bit
        g2tf.isInvert = 0;
        g2tf.bank = InventoryModeParams.BANK.EPC;  // 过滤区域为EPC
        g2tf.startaddr = 32;  // 跳过EPC前32bit的PC数据
        
        // 5. 应用过滤器
        Reader.READER_ERR er = UHFParamsOperator.getInstance().setTagFilter(g2tf);
        
        // 6. 读取TID参数设置
        int rbank = InventoryModeParams.BANK.TID;  // 读取TID区域
        int startblock = 0;   // 起始地址为0
        int blockcount = 6;   // 读取6个块(12字节，96bit)
        
        // 7. 最多尝试3次读取
        for(int index = 0; index < 3; index++) {
            er = UHFEngine.getEngine().getTagData(
                    1,              // 天线编号
                    (char) rbank,   // 内存区域
                    startblock,     // 起始块
                    blockcount,     // 块数量
                    rdata,          // 数据缓冲区
                    rpaswd,         // 访问密码
                    (short) 1000    // 超时时间(ms)
            );
            if(er == Reader.READER_ERR.MT_OK_ERR)
                break;  // 成功则退出循环
        }
        
        // 8. 处理结果并更新UI
        if (er == Reader.READER_ERR.MT_OK_ERR) {
            runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    rw_tid_text.setText(Util.bytes2hex(rdata).toUpperCase());
                    Toast.makeText(getApplicationContext(),
                                 "Read TID success!", Toast.LENGTH_SHORT).show();
                }
            });
        } else {
            // 失败提示
        }
        
        // 9. 重置过滤器
        UHFParamsOperator.getInstance().setTagFilter(null);
    }
});
```

#### 关键知识点

- **内存区域**: TID区域从地址0开始
- **块单位**: 每块2字节，6块=12字节=96bit
- **过滤机制**: 通过EPC过滤特定标签
- **重试机制**: 最多尝试3次提高成功率

------

### 2.2 通用读取功能

#### 功能描述

读取RFID标签的不同内存区域(Reserved、EPC、TID、USER)

#### 实现流程

```java
rw_read_btn.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View view) {
        // 1. 获取UI输入参数
        int startaddr = Integer.valueOf(
            rw_address_read_edittext.getText().toString().trim());
        int blocks = Integer.valueOf(
            rw_read_length_edittext.getText().toString().trim());
        
        // 2. 解析密码
        byte[] rpaswd = new byte[rw_password_read_edittext.getText().length()/2];
        UHFUtils.Str2Hex(rw_password_read_edittext.getText().toString(), 
                        rw_password_read_edittext.getText().toString().length(), 
                        rpaswd);
        
        // 3. 准备数据缓冲区
        byte[] rdata = new byte[blocks*2];
        
        // 4. 设置过滤器
        if(!setFilter()){
            Toast.makeText(getApplicationContext(),
                         "设置过滤失败！", Toast.LENGTH_SHORT).show();
            return;
        }
        
        // 5. 根据选择确定读取的内存区域
        int rbank = 0;
        switch (rw_mem_bank_read_spinner.getSelectedItemPosition()){
            case 0:  // Reserved区
                rbank = InventoryModeParams.BANK.Reserved;
                break;
            case 1:  // EPC区
                rbank = InventoryModeParams.BANK.EPC;
                break;
            case 2:  // TID区
                rbank = InventoryModeParams.BANK.TID;
                break;
            case 3:  // USER区
                rbank = InventoryModeParams.BANK.USER;
                break;
        }
        
        // 6. 最多尝试3次读取
        for(int index = 0; index < 3; index++) {
            er = UHFEngine.getEngine().getTagData(
                    1,              // 天线编号
                    (char) rbank,   // 内存区域
                    startaddr,      // 起始块
                    blocks,         // 块数量
                    rdata,          // 数据缓冲区
                    rpaswd,         // 访问密码
                    (short) 1000    // 超时时间
            );
            if(er == Reader.READER_ERR.MT_OK_ERR)
                break;
        }
        
        // 7. 更新UI显示结果
        if (er == Reader.READER_ERR.MT_OK_ERR) {
            runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    rw_read_rsp_text.setText(
                        Util.bytes2hex(rdata).toUpperCase(Locale.ROOT));
                    Toast.makeText(getApplicationContext(),
                                 "Read success!", Toast.LENGTH_SHORT).show();
                }
            });
        } else {
            // 失败处理
        }
        
        // 8. 重置过滤器
        resetFilter();
    }
});
```

#### RFID标签内存结构

| 区域     | 编号 | 说明   | 典型用途                 |
| -------- | ---- | ------ | ------------------------ |
| Reserved | 0    | 保留区 | 存储访问密码和销毁密码   |
| EPC      | 1    | EPC区  | 存储电子产品码           |
| TID      | 2    | TID区  | 存储标签唯一标识符(只读) |
| USER     | 3    | 用户区 | 用户自定义数据           |

------

### 2.3 写入功能

#### 功能描述

向RFID标签的指定内存区域写入数据

#### 实现流程

```java
rw_write_btn.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View view) {
        // 1. 设置过滤器
        if(!setFilter()){
            Toast.makeText(getApplicationContext(),
                         "设置过滤失败！", Toast.LENGTH_SHORT).show();
            return;
        }
        
        // 2. 确定写入的内存区域
        int wbank = 0;
        switch (rw_mem_bank_write_spinner.getSelectedItemPosition()){
            case 0:  // Reserved区
                wbank = InventoryModeParams.BANK.Reserved;
                break;
            case 1:  // EPC区
                wbank = InventoryModeParams.BANK.EPC;
                break;
            case 2:  // USER区（TID不可写，所以跳过）
                wbank = InventoryModeParams.BANK.USER;
                break;
        }
        
        // 3. 获取写入参数
        int write_startaddr = Integer.valueOf(
            rw_address_write_edittext.getText().toString().trim());
        
        // 4. 解析写入密码
        byte[] wpaswd = new byte[rw_password_write_edittext.getText().length()/2];
        UHFUtils.Str2Hex(rw_password_write_edittext.getText().toString(), 
                        rw_password_write_edittext.getText().toString().length(), 
                        wpaswd);
        
        // 5. 解析写入数据
        String wdataString = rw_data_write_edittext.getText().toString();
        byte[] wdata = new byte[wdataString.length()/2];
        UHFUtils.Str2Hex(wdataString, wdataString.length(), wdata);
        
        // 6. 最多尝试3次写入
        int trycount = 3;
        Reader.READER_ERR er = null;
        do {
            er = UHFEngine.getEngine().writeTagData(
                    1,              // 天线编号
                    (char) wbank,   // 内存区域
                    write_startaddr,// 起始地址
                    wdata,          // 写入数据
                    wdata.length,   // 数据长度
                    wpaswd,         // 访问密码
                    (short) 1000    // 超时时间
            );
            
            trycount--;
            if (trycount < 1)
                break;
        } while (er != Reader.READER_ERR.MT_OK_ERR);
        
        // 7. 重置过滤器
        resetFilter();
        
        // 8. 显示结果
        if (er == Reader.READER_ERR.MT_OK_ERR) {
            // 成功提示
        } else {
            // 失败提示
        }
    }
});
```

#### 注意事项

- **TID区不可写**: 列表中没有TID选项
- **数据格式**: 写入数据必须是16进制字符串
- **重试机制**: 写入操作重试3次
- **密码保护**: 如果标签设置了访问密码，需要提供正确密码

------

### 2.4 锁定功能

#### 功能描述

锁定RFID标签的特定内存区域或密码，防止未授权访问或修改

#### 锁定类型

| 锁定状态  | 说明                       |
| --------- | -------------------------- |
| UNLOCK    | 解锁状态，可读可写         |
| LOCK      | 锁定状态，需要密码才能访问 |
| PERM_LOCK | 永久锁定，无法恢复         |

#### 可锁定的对象

| 对象          | 说明       |
| ------------- | ---------- |
| ACCESS_PASSWD | 访问密码   |
| KILL_PASSWORD | 销毁密码   |
| BANK1 (EPC)   | EPC内存区  |
| BANK2 (TID)   | TID内存区  |
| BANK3 (USER)  | USER内存区 |

#### 实现流程

```java
rw_lock_btn.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View view) {
        // 1. 显示警告对话框
        AlertDialog.Builder builder = new AlertDialog.Builder(ReadWriteLockActivity.this);
        builder.setTitle(R.string.warning);
        builder.setMessage(R.string.lockwarning);
        
        builder.setPositiveButton(R.string.commit, new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {
                Reader.Lock_Obj lobj = null;
                Reader.Lock_Type ltyp = null;
                
                // 2. 获取锁定项目和类型
                int lbank = lock_item_spinner.getSelectedItemPosition();
                int ltype = lock_type_spinner.getSelectedItemPosition();
                
                // 3. 根据选择确定锁定对象和类型
                if (lbank == 0) {  // 访问密码
                    lobj = Reader.Lock_Obj.LOCK_OBJECT_ACCESS_PASSWD;
                    if (ltype == 0)
                        ltyp = Reader.Lock_Type.ACCESS_PASSWD_UNLOCK;
                    else if (ltype == 1)
                        ltyp = Reader.Lock_Type.ACCESS_PASSWD_LOCK;
                    else if (ltype == 2)
                        ltyp = Reader.Lock_Type.ACCESS_PASSWD_PERM_LOCK;
                } 
                else if (lbank == 1) {  // 销毁密码
                    lobj = Reader.Lock_Obj.LOCK_OBJECT_KILL_PASSWORD;
                    // ... 类似设置
                } 
                else if (lbank == 2) {  // EPC区
                    lobj = Reader.Lock_Obj.LOCK_OBJECT_BANK1;
                    // ... 类似设置
                } 
                else if (lbank == 3) {  // TID区
                    lobj = Reader.Lock_Obj.LOCK_OBJECT_BANK2;
                    // ... 类似设置
                } 
                else if (lbank == 4) {  // USER区
                    lobj = Reader.Lock_Obj.LOCK_OBJECT_BANK3;
                    // ... 类似设置
                }
                
                // 4. 解析锁定密码
                byte[] lockpaswd = new byte[4];
                if (!rw_password_lock_edittext.getText().toString().equals("")) {
                    UHFUtils.Str2Hex(
                        rw_password_lock_edittext.getText().toString(),
                        rw_password_lock_edittext.getText().toString().length(), 
                        lockpaswd);
                }
                
                // 5. 设置过滤器
                if(!setFilter()){
                    Toast.makeText(getApplicationContext(),
                                 "设置过滤失败！", Toast.LENGTH_SHORT).show();
                    return;
                }
                
                // 6. 执行锁定操作
                Reader.READER_ERR er = UHFEngine.getEngine().lockTag(
                        1,                      // 天线编号
                        (byte) lobj.value(),    // 锁定对象
                        (short) ltyp.value(),   // 锁定类型
                        lockpaswd,              // 访问密码
                        (short) 1000            // 超时时间
                );
                
                // 7. 显示结果
                if (er == Reader.READER_ERR.MT_OK_ERR) {
                    Toast.makeText(getApplicationContext(),
                                 "Lock Success!", Toast.LENGTH_SHORT).show();
                } else {
                    Toast.makeText(getApplicationContext(),
                                 "Lock failed!", Toast.LENGTH_SHORT).show();
                }
                
                // 8. 重置过滤器
                resetFilter();
            }
        });
        
        builder.setNegativeButton(R.string.cancel, null);
        builder.create().show();
    }
});
```

#### ⚠️ 警告

- **永久锁定不可逆**: PERM_LOCK操作后无法恢复
- **密码保护**: 需要正确的访问密码才能锁定
- **确认对话框**: 操作前显示警告，防止误操作

------

### 2.5 销毁(Kill)功能

#### 功能描述

永久销毁RFID标签，使其无法再被读取或写入

#### 实现流程

```java
rw_kill_btn.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View view) {
        // 1. 显示警告对话框
        AlertDialog.Builder builder = new AlertDialog.Builder(ReadWriteLockActivity.this);
        builder.setTitle(R.string.warning);
        builder.setMessage(R.string.killwarning);
        
        builder.setPositiveButton(R.string.commit, new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {
                // 2. 解析销毁密码
                byte[] killpaswd = new byte[4];
                if (!rw_password_kill_edittext.getText().toString().equals("")) {
                    UHFUtils.Str2Hex(
                        rw_password_kill_edittext.getText().toString(),
                        rw_password_kill_edittext.getText().toString().length(), 
                        killpaswd);
                }
                
                // 3. 设置过滤器
                if(!setFilter()){
                    Toast.makeText(getApplicationContext(),
                                 "设置过滤失败！", Toast.LENGTH_SHORT).show();
                    return;
                }
                
                // 4. 执行销毁操作
                Reader.READER_ERR er = UHFEngine.getEngine().killTag(
                        1,              // 天线编号
                        killpaswd,      // 销毁密码
                        (short) 1000    // 超时时间
                );
                
                // 5. 显示结果
                if (er == Reader.READER_ERR.MT_OK_ERR) {
                    Toast.makeText(getApplicationContext(),
                                 "Kill success!", Toast.LENGTH_SHORT).show();
                } else {
                    Toast.makeText(getApplicationContext(),
                                 "Kill failed!", Toast.LENGTH_SHORT).show();
                }
                
                // 6. 重置过滤器
                resetFilter();
            }
        });
        
        builder.setNegativeButton(R.string.cancel, null);
        builder.create().show();
    }
});
```

#### ⚠️ 极其危险的操作

- **不可逆**: 销毁后标签永久失效
- **需要销毁密码**: 必须提供正确的Kill Password
- **双重确认**: 显示警告对话框要求用户确认

------

## 三、辅助功能

### 3.1 过滤器设置 (setFilter)

#### 功能描述

根据特定条件过滤RFID标签，只对匹配的标签进行操作

#### 实现详解

```java
private boolean setFilter(){
    // 1. 获取读取长度（用于计算缓冲区大小）
    int blocks = Integer.valueOf(
        rw_read_length_edittext.getText().toString().trim());
    byte[] rdata = new byte[blocks*2];
    
    // 2. 创建过滤器对象
    Reader.TagFilter_ST g2tf = new Reader.TagFilter_ST();
    
    // 3. 验证过滤数据
    if(filterdata_edittext.getText().toString().length() == 0 || 
       filterdata_edittext.getText().toString().length()%2 != 0){
        return false;  // 数据为空或长度不是偶数
    }
    
    // 4. 转换过滤数据为字节数组
    byte[] fdata = new byte[filterdata_edittext.getText().toString().length() / 2];
    UHFUtils.Str2Hex(filterdata_edittext.getText().toString(), 
                    filterdata_edittext.getText().toString().length(), 
                    fdata);
    
    // 5. 设置过滤器参数
    g2tf.fdata = fdata;                    // 过滤数据
    g2tf.flen = fdata.length * 8;          // 长度（bit）
    g2tf.isInvert = 0;                     // 不反转
    g2tf.bank = filter_mem_bank_spinner.getSelectedItemPosition();  // 内存区域
    
    // 6. 计算起始地址（块 -> 字节 -> bit）
    // 公式: 块数 * 2字节/块 * 8bit/字节
    g2tf.startaddr = Integer.valueOf(
        filter_address_edittext.getText().toString()) * 2 * 8;
    
    // 7. 应用过滤器
    Reader.READER_ERR er = UHFParamsOperator.getInstance().setTagFilter(g2tf);
    
    if (er == Reader.READER_ERR.MT_OK_ERR) {
        Log.e("###","设置过滤成功！");
        return true;
    }
    return false;
}
```

#### 过滤器工作原理

```
标签内存结构示例 (EPC区):
┌─────────────────────────────────────┐
│ PC (16bit) │ EPC Data (96bit) │ CRC │
├────────────┼──────────────────┼─────┤
│  0-15 bit  │   16-111 bit     │ ... │
└────────────┴──────────────────┴─────┘

过滤器配置:
- bank: EPC (区域1)
- startaddr: 32 bit (跳过PC的16bit，从EPC数据开始)
- fdata: 要匹配的数据
- flen: 匹配的位数

只有匹配的标签会响应后续的读写操作
```

### 3.2 重置过滤器 (resetFilter)

```java
private void resetFilter(){
    // 清除过滤器，允许所有标签响应
    UHFParamsOperator.getInstance().setTagFilter(null);
}
```

------

## 四、生命周期管理

### 4.1 onResume - 连接设备

```java
protected void onResume() {
    // 1. 给模块上电
    UHFEngine.getEngine().powerOn();
    
    // 2. 连接UART设备
    Reader.READER_ERR er = UHFEngine.getEngine().connectModule(
        DefaultConfigure.UART_DEV_PATH,  // UART设备路径
        1                                 // 波特率等级
    );
    
    // 3. 初始化模块
    if(er == Reader.READER_ERR.MT_OK_ERR){
        DefaultConfigure.defaultInitModule();
        Log.e("####","connect success!");
    } else {
        Log.e("####","connect failed!");
    }
    
    super.onResume();
}
```

### 4.2 onPause - 断开设备

```java
protected void onPause() {
    // 1. 断开模块连接
    UHFEngine.getEngine().disconnectModule();
    
    // 2. 给模块下电
    UHFEngine.getEngine().powerOff();
    
    super.onPause();
}
```

------

## 五、数据处理细节

### 5.1 地址计算

#### 块地址 -> 位地址转换

```java
// 1块 = 2字节 = 16位
bit_address = block_address * 2 * 8

示例:
- 块地址 2 -> 位地址 32 (2 * 2 * 8)
- 块地址 3 -> 位地址 48 (3 * 2 * 8)
```

### 5.2 数据转换

#### 字符串 -> 字节数组

```java
// 16进制字符串转字节数组
String hexString = "3008ABCD1234";
byte[] bytes = new byte[hexString.length() / 2];  // 6字节
UHFUtils.Str2Hex(hexString, hexString.length(), bytes);

// 结果: bytes = {0x30, 0x08, 0xAB, 0xCD, 0x12, 0x34}
```

#### 字节数组 -> 字符串

```java
// 字节数组转16进制字符串
byte[] bytes = {0x30, 0x08, 0xAB, 0xCD};
String hexString = Util.bytes2hex(bytes).toUpperCase();

// 结果: hexString = "3008ABCD"
```

### 5.3 密码处理

```java
// 密码格式: 4字节 (8个16进制字符)
// 默认密码: {0x00, 0x00, 0x00, 0x00}
// 自定义密码: "12345678" -> {0x12, 0x34, 0x56, 0x78}

byte[] password = new byte[4];
if (!passwordEditText.getText().toString().equals("")) {
    UHFUtils.Str2Hex(
        passwordEditText.getText().toString(),
        passwordEditText.getText().toString().length(),
        password
    );
} else {
    // 使用默认密码 (全0)
    password = new byte[]{0x00, 0x00, 0x00, 0x00};
}
```

------

## 六、错误处理机制

### 6.1 重试策略

```java
// 最多重试3次的模式
for(int index = 0; index < 3; index++) {
    Reader.READER_ERR er = UHFEngine.getEngine().getTagData(...);
    if(er == Reader.READER_ERR.MT_OK_ERR)
        break;  // 成功则退出循环
}

// 检查最终结果
if (er == Reader.READER_ERR.MT_OK_ERR) {
    // 成功处理
} else {
    // 失败处理
}
```

### 6.2 UI线程更新

```java
// 在后台线程执行RFID操作后，必须在UI线程更新界面
ReadWriteLockActivity.this.runOnUiThread(new Runnable() {
    @Override
    public void run() {
        // 更新TextView、Toast等UI元素
        textView.setText(result);
        Toast.makeText(getApplicationContext(), 
                      "操作成功", Toast.LENGTH_SHORT).show();
    }
});
```

------

## 七、常见问题与注意事项

### 7.1 代码中的TODO注释

```java
// TODO 这里也有问题 读取有时候成功有时候失败
// 可能的原因:
// 1. 信号强度不稳定
// 2. 标签与读写器距离变化
// 3. 环境干扰
// 4. 过滤器设置问题
// 解决方案: 增加重试次数、调整天线功率、优化过滤条件
// todo 写一直失败 ！！！
// 可能的原因:
// 1. 标签已被锁定
// 2. 密码错误
// 3. 写入地址不正确
// 4. 数据格式错误
```

### 7.2 EPC区地址特殊性

#### EPC区内存布局

```
EPC区完整结构:
┌──────┬─────────────────────┬─────┐
│  PC  │     EPC Data        │ CRC │
├──────┼─────────────────────┼─────┤
│16bit │   96-496bit(可变)   │16bit│
└──────┴─────────────────────┴─────┘

块地址映射:
- 块0-1: PC (Protocol Control)
- 块2开始: 实际EPC数据
- 因此读写EPC数据时起始地址通常设为2
```

#### 代码中的体现

```java
rw_mem_bank_read_spinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
    @Override
    public void onItemSelected(AdapterView<?> adapterView, View view, int i, long l) {
        if(i == 1)  // 如果选择EPC区
            rw_address_read_edittext.setText("2");  // 默认从块2开始
        else
            rw_address_read_edittext.setText("0");  // 其他区从块0开始
    }
});
```

### 7.3 过滤器的重要性

#### 为什么需要过滤器？

在多标签环境中，如果不使用过滤器：

- 可能会误操作其他标签
- 无法精确定位特定标签
- 读写操作可能返回多个标签的数据冲突

#### 过滤器使用模式

```java
// 标准操作流程:
1. setFilter()      // 设置过滤条件，锁定目标标签
2. 执行读/写/锁/销毁操作
3. resetFilter()    // 重置过滤器，恢复正常模式
```

### 7.4 密码管理最佳实践

#### Reserved区密码存储

```
Reserved区结构 (32bit = 4块):
┌─────────────────┬─────────────────┐
│ Kill Password   │ Access Password │
├─────────────────┼─────────────────┤
│  块0-1 (32bit)  │  块2-3 (32bit)  │
└─────────────────┴─────────────────┘

块地址:
- 0x00-0x01: Kill Password (高16bit, 低16bit)
- 0x02-0x03: Access Password (高16bit, 低16bit)
```

#### 密码操作示例

```java
// 读取访问密码 (如果未锁定)
// bank: Reserved (0)
// startaddr: 2 (块2开始)
// blockcount: 2 (读取2块 = 4字节 = 32bit)

// 写入访问密码
// 数据格式: "12345678" (8个16进制字符 = 4字节)
byte[] accessPassword = new byte[4];
UHFUtils.Str2Hex("12345678", 8, accessPassword);
// 结果: {0x12, 0x34, 0x56, 0x78}
```

------

## 八、完整操作流程示例

### 8.1 安全写入EPC数据

```java
完整流程:
┌──────────────────────────────────────┐
│ 1. 设置过滤器 (基于当前EPC)          │
├──────────────────────────────────────┤
│ 2. 验证过滤器设置成功                │
├──────────────────────────────────────┤
│ 3. 准备写入数据                      │
│    - 转换为字节数组                  │
│    - 验证数据长度                    │
├──────────────────────────────────────┤
│ 4. 执行写入操作                      │
│    - 最多重试3次                     │
│    - 使用正确的访问密码              │
├──────────────────────────────────────┤
│ 5. 验证写入结果                      │
├──────────────────────────────────────┤
│ 6. 重置过滤器                        │
├──────────────────────────────────────┤
│ 7. 更新UI显示结果                    │
└──────────────────────────────────────┘
```

### 8.2 读取并验证数据

```java
完整读取验证流程:

// 步骤1: 读取前准备
String targetEPC = "E28011700000020225B8C49F";
filterdata_edittext.setText(targetEPC);

// 步骤2: 设置过滤器
if (!setFilter()) {
    // 过滤器设置失败，终止操作
    return;
}

// 步骤3: 执行读取
int rbank = InventoryModeParams.BANK.USER;  // 读取USER区
int startblock = 0;
int blockcount = 4;  // 读取4块 = 8字节
byte[] rdata = new byte[blockcount * 2];
byte[] password = {0x00, 0x00, 0x00, 0x00};

Reader.READER_ERR result = null;
for (int i = 0; i < 3; i++) {
    result = UHFEngine.getEngine().getTagData(
        1, 
        (char) rbank, 
        startblock, 
        blockcount, 
        rdata, 
        password, 
        (short) 1000
    );
    if (result == Reader.READER_ERR.MT_OK_ERR) break;
}

// 步骤4: 处理结果
if (result == Reader.READER_ERR.MT_OK_ERR) {
    String hexData = Util.bytes2hex(rdata).toUpperCase();
    Log.d("RFID", "读取成功: " + hexData);
    
    // 步骤5: 验证数据
    if (hexData.length() == blockcount * 4) {  // 每块2字节=4个16进制字符
        // 数据完整
    } else {
        // 数据不完整
    }
}

// 步骤6: 清理
resetFilter();
```

------

## 九、性能优化建议

### 9.1 减少UI线程阻塞

#### 问题

当前代码在按钮点击事件中直接执行RFID操作，可能导致UI卡顿。

#### 优化方案

```java
// 使用线程池异步执行RFID操作
private ExecutorService executorService = Executors.newSingleThreadExecutor();

rw_read_btn.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View view) {
        // 在后台线程执行
        executorService.execute(new Runnable() {
            @Override
            public void run() {
                // RFID读取操作
                byte[] rdata = performRead();
                
                // 回到UI线程更新界面
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        rw_read_rsp_text.setText(Util.bytes2hex(rdata));
                    }
                });
            }
        });
    }
});

// 在onDestroy中释放线程池
@Override
protected void onDestroy() {
    if (executorService != null) {
        executorService.shutdown();
    }
    super.onDestroy();
}
```

### 9.2 优化过滤器使用

#### 当前问题

每次操作都设置和重置过滤器，增加了通信开销。

#### 优化方案

```java
private String currentFilterEPC = "";

private boolean setFilterIfNeeded(String targetEPC) {
    // 如果过滤器已经设置为目标EPC，无需重复设置
    if (currentFilterEPC.equals(targetEPC)) {
        return true;
    }
    
    boolean success = setFilter();
    if (success) {
        currentFilterEPC = targetEPC;
    }
    return success;
}

private void resetFilterIfNeeded() {
    if (!currentFilterEPC.isEmpty()) {
        resetFilter();
        currentFilterEPC = "";
    }
}
```

### 9.3 批量操作优化

#### 场景：需要读取多个内存区域

```java
// 不优化的方式：每个区域单独读取
// 1. setFilter() -> 读EPC -> resetFilter()
// 2. setFilter() -> 读TID -> resetFilter()
// 3. setFilter() -> 读USER -> resetFilter()

// 优化方式：一次过滤，批量读取
private Map<String, byte[]> readMultipleBanks(int[] banks, int[] startAddrs, int[] lengths) {
    Map<String, byte[]> results = new HashMap<>();
    
    // 只设置一次过滤器
    if (!setFilter()) {
        return results;
    }
    
    try {
        // 批量读取
        for (int i = 0; i < banks.length; i++) {
            byte[] data = new byte[lengths[i] * 2];
            byte[] password = {0x00, 0x00, 0x00, 0x00};
            
            Reader.READER_ERR er = UHFEngine.getEngine().getTagData(
                1,
                (char) banks[i],
                startAddrs[i],
                lengths[i],
                data,
                password,
                (short) 1000
            );
            
            if (er == Reader.READER_ERR.MT_OK_ERR) {
                results.put("BANK_" + banks[i], data);
            }
        }
    } finally {
        // 只重置一次过滤器
        resetFilter();
    }
    
    return results;
}

// 使用示例
int[] banks = {
    InventoryModeParams.BANK.EPC,
    InventoryModeParams.BANK.TID,
    InventoryModeParams.BANK.USER
};
int[] startAddrs = {2, 0, 0};
int[] lengths = {6, 6, 4};

Map<String, byte[]> allData = readMultipleBanks(banks, startAddrs, lengths);
```

------

## 十、安全性考虑

### 10.1 密码管理

#### 密码强度建议

```java
// 弱密码 (不推荐)
byte[] weakPassword = {0x00, 0x00, 0x00, 0x00};  // 全0
byte[] weakPassword2 = {0x12, 0x34, 0x56, 0x78}; // 简单序列

// 强密码 (推荐)
byte[] strongPassword = {0xA7, 0x3F, 0xE2, 0x91}; // 随机值

// 生成随机密码
private byte[] generateRandomPassword() {
    byte[] password = new byte[4];
    new java.security.SecureRandom().nextBytes(password);
    return password;
}
```

#### 密码存储

```java
// 不要在代码中硬编码密码
// ❌ 错误示例
byte[] password = {0x12, 0x34, 0x56, 0x78};

// ✅ 正确示例：从安全存储读取
private byte[] getPasswordFromSecureStorage(String tagId) {
    // 从加密的SharedPreferences或Keystore读取
    SharedPreferences prefs = getEncryptedSharedPreferences();
    String hexPassword = prefs.getString("password_" + tagId, "00000000");
    byte[] password = new byte[4];
    UHFUtils.Str2Hex(hexPassword, 8, password);
    return password;
}
```

### 10.2 操作权限控制

```java
// 添加操作确认和权限检查
private boolean hasPermissionForOperation(String operation) {
    // 检查用户权限
    // 例如：只有管理员可以执行锁定和销毁操作
    switch (operation) {
        case "READ":
            return true;  // 所有用户可读
        case "WRITE":
            return isAuthenticatedUser();  // 认证用户可写
        case "LOCK":
        case "KILL":
            return isAdminUser();  // 只有管理员可锁定/销毁
        default:
            return false;
    }
}

// 在危险操作前检查
rw_lock_btn.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View view) {
        if (!hasPermissionForOperation("LOCK")) {
            Toast.makeText(getApplicationContext(), 
                         "权限不足", Toast.LENGTH_SHORT).show();
            return;
        }
        // 继续执行锁定操作...
    }
});
```

### 10.3 操作日志记录

```java
// 记录所有关键操作
private void logOperation(String operation, String tagEPC, boolean success, String details) {
    String logEntry = String.format(
        "[%s] %s on tag %s: %s - %s",
        new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()),
        operation,
        tagEPC,
        success ? "SUCCESS" : "FAILED",
        details
    );
    
    // 写入日志文件或数据库
    Log.i("RFID_OPERATION", logEntry);
    
    // 同时可以发送到远程服务器进行审计
    // sendAuditLog(logEntry);
}

// 在操作中使用
if (er == Reader.READER_ERR.MT_OK_ERR) {
    logOperation("WRITE", currentEPC, true, "Written data: " + dataHex);
} else {
    logOperation("WRITE", currentEPC, false, "Error code: " + er.toString());
}
```

------

## 十一、调试技巧

### 11.1 详细的错误信息

```java
// 扩展错误处理
private String getErrorDescription(Reader.READER_ERR error) {
    switch (error) {
        case MT_OK_ERR:
            return "操作成功";
        case MT_READER_ADDR_ERR:
            return "读写器地址错误";
        case MT_CMD_INVALID_ERR:
            return "无效的命令";
        case MT_CMD_PARA_NUM_ERR:
            return "命令参数数量错误";
        case MT_TAG_NO_RESPONSE:
            return "标签无响应";
        case MT_TAG_CRC_ERR:
            return "标签CRC校验错误";
        case MT_TAG_MEM_OVERRUN:
            return "标签内存越界";
        case MT_TAG_MEM_LOCKED:
            return "标签内存已锁定";
        case MT_TAG_INSUFFICIENT_POWER:
            return "标签能量不足";
        case MT_TAG_NOT_SUPPORT:
            return "标签不支持此操作";
        default:
            return "未知错误: " + error.toString();
    }
}

// 使用
if (er != Reader.READER_ERR.MT_OK_ERR) {
    String errorMsg = getErrorDescription(er);
    Log.e("RFID_ERROR", errorMsg);
    Toast.makeText(getApplicationContext(), errorMsg, Toast.LENGTH_LONG).show();
}
```

### 11.2 数据验证工具

```java
// 验证16进制字符串格式
private boolean isValidHexString(String hex) {
    if (hex == null || hex.isEmpty()) {
        return false;
    }
    if (hex.length() % 2 != 0) {
        Log.e("VALIDATION", "16进制字符串长度必须是偶数");
        return false;
    }
    if (!hex.matches("[0-9A-Fa-f]+")) {
        Log.e("VALIDATION", "包含非16进制字符");
        return false;
    }
    return true;
}

// 验证地址范围
private boolean isValidAddress(int bank, int address, int length) {
    // 不同内存区域的大小限制
    int maxBlocks = 0;
    switch (bank) {
        case InventoryModeParams.BANK.Reserved:
            maxBlocks = 4;  // 8字节
            break;
        case InventoryModeParams.BANK.EPC:
            maxBlocks = 32; // 最大64字节 (可变)
            break;
        case InventoryModeParams.BANK.TID:
            maxBlocks = 12; // 24字节
            break;
        case InventoryModeParams.BANK.USER:
            maxBlocks = 128; // 256字节 (可变)
            break;
    }
    
    if (address + length > maxBlocks) {
        Log.e("VALIDATION", String.format(
            "地址越界: bank=%d, addr=%d, len=%d, max=%d",
            bank, address, length, maxBlocks
        ));
        return false;
    }
    return true;
}

// 在操作前验证
private void performWrite() {
    String dataHex = rw_data_write_edittext.getText().toString();
    if (!isValidHexString(dataHex)) {
        Toast.makeText(this, "数据格式错误", Toast.LENGTH_SHORT).show();
        return;
    }
    
    int bank = getSelectedBank();
    int address = getWriteAddress();
    int length = dataHex.length() / 4;  // 转换为块数
    
    if (!isValidAddress(bank, address, length)) {
        Toast.makeText(this, "地址或长度无效", Toast.LENGTH_SHORT).show();
        return;
    }
    
    // 继续写入操作...
}
```

### 11.3 信号强度监测

```java
// 添加信号强度显示
private TextView signalStrengthText;

private void updateSignalStrength() {
    executorService.execute(new Runnable() {
        @Override
        public void run() {
            // 读取天线功率配置
            AntPowerConfResult result = 
                UHFParamsOperator.getInstance().getAntPowerConf();
            
            runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    if (result != null) {
                        signalStrengthText.setText(
                            String.format("功率: %d dBm", result.getPower())
                        );
                    }
                }
            });
        }
    });
}

// 定期更新信号强度
private Handler signalHandler = new Handler();
private Runnable signalRunnable = new Runnable() {
    @Override
    public void run() {
        updateSignalStrength();
        signalHandler.postDelayed(this, 2000);  // 每2秒更新
    }
};

@Override
protected void onResume() {
    super.onResume();
    signalHandler.post(signalRunnable);
}

@Override
protected void onPause() {
    signalHandler.removeCallbacks(signalRunnable);
    super.onPause();
}
```

------

## 十二、扩展功能建议

### 12.1 批量标签操作

```java
// 批量读取多个标签
private List<TagData> batchReadTags() {
    List<TagData> tagList = new ArrayList<>();
    
    // 1. 清除过滤器，允许所有标签响应
    resetFilter();
    
    // 2. 进行盘点操作
    UHFEngine.getEngine().startInventory();
    
    // 3. 收集标签数据
    // 需要实现标签数据接收的回调机制
    // ...
    
    // 4. 停止盘点
    UHFEngine.getEngine().stopInventory();
    
    return tagList;
}

// 标签数据类
private class TagData {
    String epc;
    String tid;
    byte[] userData;
    int rssi;  // 信号强度
    int readCount;  // 读取次数
}
```

### 12.2 标签数据缓存

```java
// 缓存读取的标签数据，减少重复读取
private Map<String, CachedTagData> tagDataCache = new HashMap<>();

private class CachedTagData {
    byte[] data;
    long timestamp;
    int bank;
    int address;
    
    public boolean isExpired(long maxAge) {
        return System.currentTimeMillis() - timestamp > maxAge;
    }
}

private byte[] readWithCache(String epc, int bank, int address, int length) {
    String cacheKey = String.format("%s_%d_%d_%d", epc, bank, address, length);
    
    // 检查缓存
    CachedTagData cached = tagDataCache.get(cacheKey);
    if (cached != null && !cached.isExpired(5000)) {  // 5秒有效期
        Log.d("CACHE", "使用缓存数据");
        return cached.data;
    }
    
    // 从标签读取
    byte[] data = performActualRead(bank, address, length);
    
    // 更新缓存
    if (data != null) {
        CachedTagData newCache = new CachedTagData();
        newCache.data = data;
        newCache.timestamp = System.currentTimeMillis();
        newCache.bank = bank;
        newCache.address = address;
        tagDataCache.put(cacheKey, newCache);
    }
    
    return data;
}
```

### 12.3 数据导出功能

```java
// 导出标签数据为CSV
private void exportTagDataToCSV(List<TagData> tags, String filename) {
    try {
        File file = new File(getExternalFilesDir(null), filename);
        FileWriter writer = new FileWriter(file);
        
        // 写入CSV头
        writer.append("EPC,TID,User Data,RSSI,Timestamp\n");
        
        // 写入数据
        for (TagData tag : tags) {
            writer.append(tag.epc).append(",");
            writer.append(tag.tid).append(",");
            writer.append(Util.bytes2hex(tag.userData)).append(",");
            writer.append(String.valueOf(tag.rssi)).append(",");
            writer.append(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss")
                .format(new Date())).append("\n");
        }
        
        writer.flush();
        writer.close();
        
        Toast.makeText(this, "导出成功: " + file.getAbsolutePath(), 
                      Toast.LENGTH_LONG).show();
    } catch (IOException e) {
        Log.e("EXPORT", "导出失败", e);
        Toast.makeText(this, "导出失败", Toast.LENGTH_SHORT).show();
    }
}
```

------

## 十三、总结

### 核心要点回顾

1. **RFID标签内存结构**

   - Reserved区：存储密码
   - EPC区：电子产品码
   - TID区：唯一标识（只读）
   - USER区：用户自定义数据

2. **操作流程标准模式**

   ```
   设置过滤器 → 执行操作 → 验证结果 → 重置过滤器 → 更新UI
   ```

3. **数据单位转换**

   - 1块 = 2字节 = 16位
   - 地址单位通常为块，但过滤器使用位

4. **错误处理**

   - 重试机制（最多3次）
   - 详细错误信息记录
   - UI线程安全更新

5. **安全考虑**

   - 密码管理
   - 操作权限控制
   - 危险操作确认
   - 操作日志审计

### 关键API调用

| 操作 | API方法          | 主要参数                     |
| ---- | ---------------- | ---------------------------- |
| 读取 | `getTagData()`   | 天线、区域、地址、长度、密码 |
| 写入 | `writeTagData()` | 天线、区域、地址、数据、密码 |
| 锁定 | `lockTag()`      | 天线、对象、类型、密码       |
| 销毁 | `killTag()`      | 天线、密码                   |
| 过滤 | `setTagFilter()` | 区域、地址、数据、长度       |

这个Activity是RFID应用的核心功能模块，实现了完整的标签生命周期管理，从读取识别到最终销毁的全过程控制。

















