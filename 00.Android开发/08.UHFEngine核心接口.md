# UHF RFID 核心接口使用指南

本文档详细介绍 UHF RFID 模块的核心接口使用方法，包括实际应用场景和注意事项。

基于提供过来的word文档去详细介绍其关键的核心接口

------

## 一、基本架构

### 1.1 核心类库

- **UHFEngine**: 执行操作的核心引擎（盘点、读写、锁定等）
- **UHFParamsOperator**: 参数配置操作类（功率、区域、会话等）
- **UHFSetting**: 初始化设置类
- **UHFUtils**: 工具类（字符串与字节数组转换等）

### 1.2 依赖库

```
com.uhf.api.cls.Reader - 基础读写器类
com.uhf.api.cls.ReadListener - 盘点监听接口
com.uhf.api.cls.ReadExceptionListener - 异常监听接口
```

------

## 二、UHFEngine 核心接口

### 2.1 基本用法

所有操作通过单例模式调用：

```java
UHFEngine.getEngine().xxx()
```

### 2.2 模块电源管理

#### 2.2.1 模块上电

```java
UHFEngine.getEngine().powerOn()
```

**使用场景**: 在 Activity 的 `onResume()` 中调用

**注意事项**:

- 必须在连接模块前执行
- 确保有足够的系统权限

#### 2.2.2 模块下电

```java
UHFEngine.getEngine().powerOff()
```

**使用场景**: 在 Activity 的 `onPause()` 或 `onDestroy()` 中调用

**注意事项**:

- 必须在断开连接后执行
- 避免资源占用和电池消耗

**完整示例**:

```java
@Override
protected void onResume() {
    // 上电
    UHFEngine.getEngine().powerOn();
    // 连接模块
    Reader.READER_ERR er = UHFEngine.getEngine().connectModule(
        DefaultConfigure.UART_DEV_PATH, 1
    );
    if(er == Reader.READER_ERR.MT_OK_ERR){
        // 初始化模块参数
        DefaultConfigure.defaultInitModule();
    }
    super.onResume();
}

@Override
protected void onPause() {
    // 断开连接
    UHFEngine.getEngine().disconnectModule();
    // 下电
    UHFEngine.getEngine().powerOff();
    super.onPause();
}
```

------

### 2.3 模块连接

#### 2.3.1 连接模块

```java
Reader.READER_ERR connectModule(String src, int rtype)
```

**参数说明**:

- src: 读写器地址

- 串口设备：`/dev/ttysWK0`（带手柄）或 `/dev/ttysWK1`（不带手柄）

- IP地址：网络模块使用

- `rtype`: 天线端口数，PDA 使用 `1`

**返回值**: `Reader.READER_ERR` 枚举类型

- `MT_OK_ERR`: 连接成功
- 其他值: 连接失败

**使用示例**:

```java
Reader.READER_ERR er = UHFEngine.getEngine().connectModule(
    "/dev/ttysWK0", 1
);
if(er == Reader.READER_ERR.MT_OK_ERR){
    Toast.makeText(context, "连接成功", Toast.LENGTH_SHORT).show();
    // 初始化模块参数
    initModule();
} else {
    Toast.makeText(context, "连接失败", Toast.LENGTH_SHORT).show();
}
```

**注意事项**:

- 连接前必须先上电
- 确认串口路径正确（根据设备型号选择）
- 连接成功后建议立即初始化模块参数

#### 2.3.2 断开模块连接

```java
UHFEngine.getEngine().disconnectModule()
```

**注意事项**:

- 在下电前必须先断开连接
- 如果正在盘点，需要先停止盘点

------

### 2.4 标签盘点（核心功能）

#### 2.4.1 启动盘点

```java
Reader.READER_ERR startInventory(
    InventoryParams params,
    ReadListener readListener,
    ReadExceptionListener exceptionListener
)
```

**参数说明**:

- `params`: 盘点参数对象，控制盘点模式
- `readListener`: 标签读取回调接口
- `exceptionListener`: 异常回调接口

**盘点参数配置**:

```java
// 获取盘点参数
// 第一个参数：盘点模式（NORMAL/FAST/DENSE等）
// 第二个参数：盘点配置参数
// 第三个参数：是否读取 TID（仅 NORMAL 模式有效）
InventoryParams params = InventoryModeParams.getParams(
    DefaultConfigure.inventorymode,      // 盘点模式
    DefaultConfigure.inventoryParams,    // 配置参数
    DefaultConfigure.inventorywithtid    // 是否读取TID
);
```

**ReadListener 回调实现**:

```java
ReadListener RL = new ReadListener() {
    @Override
    public void tagRead(List<Reader.TagInfo> list) {
        if (list == null) {
            return;
        }
        
        for (int i = 0; i < list.size(); i++) {
            Reader.TagInfo tagInfo = list.get(i);
            
            // 获取 EPC 数据（十六进制字符串）
            String epcId = Reader.bytes_Hexstr(tagInfo.EpcId);
            
            // 获取 TID 数据（如果启用）
            String tidId = Reader.bytes_Hexstr(tagInfo.EmbededData);
            
            // 信号强度（RSSI）
            int rssi = tagInfo.RSSI;
            
            // 频率
            int frequency = tagInfo.Frequency;
            
            // 处理标签数据
            UHFCardInfo item = new UHFCardInfo();
            item.epc = epcId;
            item.tid = tidId;
            item.rssi = rssi;
            item.Frequency = frequency;
            
            // 更新UI或数据列表
            updateTagList(item);
            
            // 播放提示音
            soundPool.play(1, 1, 1, 0, 0, 1);
        }
    }
};
```

**ReadExceptionListener 回调实现**:

```java
ReadExceptionListener REL = new ReadExceptionListener() {
    @Override
    public void tagReadException(final Reader.READER_ERR er) {
        // 处理盘点异常
        runOnUiThread(() -> {
            Toast.makeText(context, "盘点异常: " + er, Toast.LENGTH_SHORT).show();
        });
    }
};
```

**完整启动盘点示例**:

```java
// 配置盘点参数
InventoryParams params = InventoryModeParams.getParams(
    InventoryModeParams.MODE.NORMAL,  // 普通模式
    DefaultConfigure.inventoryParams,
    true  // 读取TID
);

// 启动盘点
Reader.READER_ERR er = UHFEngine.getEngine().startInventory(params, RL, REL);
if (er != Reader.READER_ERR.MT_OK_ERR) {
    Toast.makeText(context, "启动盘点失败", Toast.LENGTH_SHORT).show();
} else {
    inventoryRunning = true;
    // 开始计时
    startInventoryTimer();
    // 禁用设置按钮
    settingBtn.setEnabled(false);
}
```

**注意事项**:

- 盘点过程是异步的，通过回调获取结果
- 回调可能在子线程中执行，更新UI需要切换到主线程
- 盘点期间不要执行其他读写操作
- TID 读取会降低盘点速度，根据需求决定是否启用
- 建议添加音效反馈提升用户体验

#### 2.4.2 停止盘点

```java
UHFEngine.getEngine().stopInventory()
```

**使用示例**:

```java
if(inventoryRunning){
    UHFEngine.getEngine().stopInventory();
    inventoryRunning = false;
    // 停止计时器
    delayHandler.removeMessages(UPDATE_TIME_UI_LOOP);
    // 恢复按钮状态
    settingBtn.setEnabled(true);
    exportBtn.setEnabled(true);
}
```

**注意事项**:

- 停止后才能执行其他操作
- 确保状态标志正确更新
- 建议使用按键监听实现启停切换

------

### 2.5 获取硬件信息

```java
HardwareDetailsResult getHardwareDetails()
```

**返回值**: `HardwareDetailsResult` 对象，包含硬件详细信息

**使用场景**:

- 显示设备信息
- 调试和故障排查
- 版本兼容性检查

------

### 2.6 标签操作

#### 2.6.1 写入 EPC（初始化标签）

```java
Reader.READER_ERR writeTagEpcEx(
    int ant,              // 天线编号
    byte[] epc,           // EPC 数据
    int epclen,           // EPC 长度（字节）
    byte[] accesspwd,     // 访问密码（4字节，无密码传null）
    short timeout         // 超时时间（毫秒）
)
```

**功能说明**:

- 写入 EPC 的同时会自动更新 PC 字段
- 不支持过滤条件
- 不能写入已锁定的标签
- 主要用于标签初始化

**使用示例**:

```java
// 新的 EPC 数据
byte[] newEpc = {0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, (byte)0x88};

// 无密码写入
Reader.READER_ERR er = UHFEngine.getEngine().writeTagEpcEx(
    1,           // 天线1
    newEpc,      // EPC数据
    newEpc.length,
    null,        // 无访问密码
    (short)1000  // 1秒超时
);

if(er == Reader.READER_ERR.MT_OK_ERR){
    Toast.makeText(context, "写入成功", Toast.LENGTH_SHORT).show();
}
```

**注意事项**:

- PDA 只有一个天线，`ant` 参数固定为 `1`
- EPC 长度通常为 12 字节（96 bit）
- 如果标签设置了访问密码，必须提供正确密码
- 建议重试机制（最多3次）

#### 2.6.2 读取标签数据

```java
Reader.READER_ERR getTagData(
    int ant,              // 天线编号（PDA用1）
    char bank,            // 存储区（0-4）
    int address,          // 起始地址（块地址）
    int blkcnt,           // 读取块数
    byte[] data,          // 输出缓冲区
    byte[] accesspasswd,  // 访问密码（4字节或null）
    short timeout         // 超时时间（毫秒）
)
```

**Bank 存储区说明**:

- `0`: Reserved（保留区）- 存储访问密码和销毁密码
- `1`: EPC - 存储 EPC 数据
- `2`: TID - 存储标签唯一标识符
- `3`: USER - 用户自定义数据区

**地址说明**:

- 单位：块（Block），每块 = 2 字节 = 16 bit
- EPC 区前 32 bit（2块）为 PC 数据，实际 EPC 从块2开始
- TID 区从块0开始

**读取 TID 完整示例**:

```java
private void readTID() {
    // 1. 设置过滤条件（根据EPC过滤）
    Reader.TagFilter_ST filter = new Reader.TagFilter_ST();
    byte[] epcBytes = new byte[currentEpc.length() / 2];
    UHFUtils.Str2Hex(currentEpc, currentEpc.length(), epcBytes);
    
    filter.fdata = epcBytes;
    filter.flen = epcBytes.length * 8;  // 转换为bit
    filter.isInvert = 0;
    filter.bank = InventoryModeParams.BANK.EPC;
    filter.startaddr = 32;  // 跳过PC字段
    
    Reader.READER_ERR er = UHFParamsOperator.getInstance().setTagFilter(filter);
    if (er != Reader.READER_ERR.MT_OK_ERR) {
        Toast.makeText(context, "设置过滤失败", Toast.LENGTH_SHORT).show();
        return;
    }
    
    // 2. 读取 TID
    byte[] tidData = new byte[12];  // TID通常12字节
    byte[] password = {0x00, 0x00, 0x00, 0x00};  // 无密码
    
    // 重试最多3次
    for(int i = 0; i < 3; i++) {
        er = UHFEngine.getEngine().getTagData(
            1,                    // 天线1
            (char)InventoryModeParams.BANK.TID,  // TID区
            0,                    // 从块0开始
            6,                    // 读取6块（12字节）
            tidData,              // 输出缓冲区
            password,             // 访问密码
            (short)1000           // 1秒超时
        );
        if(er == Reader.READER_ERR.MT_OK_ERR)
            break;
    }
    
    // 3. 清除过滤条件
    UHFParamsOperator.getInstance().setTagFilter(null);
    
    // 4. 处理结果
    if (er == Reader.READER_ERR.MT_OK_ERR) {
        String tidHex = Util.bytes2hex(tidData).toUpperCase();
        Toast.makeText(context, "TID: " + tidHex, Toast.LENGTH_SHORT).show();
    } else {
        Toast.makeText(context, "读取失败", Toast.LENGTH_SHORT).show();
    }
}
```

**读取 EPC 示例**:

```java
// 读取 EPC（12字节 = 6块）
byte[] epcData = new byte[12];
byte[] password = null;  // 无密码

Reader.READER_ERR er = UHFEngine.getEngine().getTagData(
    1,                               // 天线1
    (char)InventoryModeParams.BANK.EPC,  // EPC区
    2,                               // 从块2开始（跳过PC）
    6,                               // 读取6块
    epcData,
    password,
    (short)1000
);
```

**注意事项**:

- **必须设置过滤条件**，否则可能读取到多个标签导致失败
- 读取完成后**务必清除过滤**：`setTagFilter(null)`
- 缓冲区大小 = 块数 × 2 字节
- 建议实现重试机制（3次）
- 如果标签在 EPC 区域设置了读保护，需要提供访问密码

#### 2.6.3 写入标签数据

```java
Reader.READER_ERR writeTagData(
    int ant,              // 天线编号
    char bank,            // 存储区
    int address,          // 起始地址（块地址）
    byte[] data,          // 写入数据
    int datalen,          // 数据长度（字节）
    byte[] accesspasswd,  // 访问密码
    short timeout         // 超时时间
)
```

**可写入的存储区**:

- `0`: Reserved - 可写入访问密码和销毁密码
- `1`: EPC - 可写入 EPC 数据
- `3`: USER - 可写入用户数据
- ⚠️ `2`: TID - **不可写入**（只读）

**写入 EPC 完整示例**:

```java
private void writeEPC(String newEpcHex) {
    // 1. 设置过滤条件
    if(!setFilter()){
        Toast.makeText(context, "设置过滤失败", Toast.LENGTH_SHORT).show();
        return;
    }
    
    // 2. 准备写入数据
    byte[] epcData = new byte[newEpcHex.length() / 2];
    UHFUtils.Str2Hex(newEpcHex, newEpcHex.length(), epcData);
    
    // 3. 准备密码
    byte[] password = {0x00, 0x00, 0x00, 0x00};  // 无密码
    
    // 4. 写入数据（重试最多3次）
    Reader.READER_ERR er = null;
    int tryCount = 3;
    do {
        er = UHFEngine.getEngine().writeTagData(
            1,                               // 天线1
            (char)InventoryModeParams.BANK.EPC,  // EPC区
            2,                               // 从块2开始
            epcData,
            epcData.length,
            password,
            (short)1000
        );
        tryCount--;
        if (tryCount < 1) break;
    } while (er != Reader.READER_ERR.MT_OK_ERR);
    
    // 5. 清除过滤
    resetFilter();
    
    // 6. 处理结果
    if (er == Reader.READER_ERR.MT_OK_ERR) {
        Toast.makeText(context, "写入成功", Toast.LENGTH_SHORT).show();
    } else {
        Toast.makeText(context, "写入失败", Toast.LENGTH_SHORT).show();
    }
}
```

**写入用户区示例**:

```java
// 写入用户数据
String userData = "48656C6C6F";  // "Hello" 的十六进制
byte[] userBytes = new byte[userData.length() / 2];
UHFUtils.Str2Hex(userData, userData.length(), userBytes);

Reader.READER_ERR er = UHFEngine.getEngine().writeTagData(
    1,
    (char)InventoryModeParams.BANK.USER,  // USER区
    0,  // 从块0开始
    userBytes,
    userBytes.length,
    null,  // 无密码
    (short)1000
);
```

**注意事项**:

- **写入前必须设置过滤条件**
- 写入完成后**必须清除过滤**
- 数据长度必须是2的倍数（块对齐）
- 如果标签区域被锁定，需要解锁或提供访问密码
- **强烈建议重试机制**（3次）
- TID 区域不可写入

#### 2.6.4 锁定标签

```java
Reader.READER_ERR lockTag(
    int ant,              // 天线编号
    byte lockobjects,     // 锁定对象
    short locktypes,      // 锁定类型
    byte[] accesspasswd,  // 访问密码（必需）
    short timeout         // 超时时间
)
```

**锁定对象（Lock_Obj）**:

- `LOCK_OBJECT_ACCESS_PASSWD`: 访问密码
- `LOCK_OBJECT_KILL_PASSWORD`: 销毁密码
- `LOCK_OBJECT_BANK1`: EPC 区（Bank1）
- `LOCK_OBJECT_BANK2`: TID 区（Bank2）
- `LOCK_OBJECT_BANK3`: USER 区（Bank3）

**锁定类型（Lock_Type）**:

- `UNLOCK`: 解锁（可读写）
- `LOCK`: 暂时锁定（提供密码后可读写）
- `PERM_LOCK`: 永久锁定（**不可逆，慎用！**）

**使用示例（锁定EPC区）**:

```java
private void lockEPC() {
    // 1. 确保访问密码非0
    byte[] accessPwd = {0x12, 0x34, 0x56, 0x78};
    
    // 2. 设置过滤条件
    if(!setFilter()){
        Toast.makeText(context, "设置过滤失败", Toast.LENGTH_SHORT).show();
        return;
    }
    
    // 3. 锁定 EPC 区
    Reader.READER_ERR er = UHFEngine.getEngine().lockTag(
        1,
        (byte)Reader.Lock_Obj.LOCK_OBJECT_BANK1.value(),  // EPC区
        (short)Reader.Lock_Type.BANK1_LOCK.value(),       // 暂时锁定
        accessPwd,
        (short)1000
    );
    
    // 4. 清除过滤
    resetFilter();
    
    // 5. 处理结果
    if (er == Reader.READER_ERR.MT_OK_ERR) {
        Toast.makeText(context, "锁定成功", Toast.LENGTH_SHORT).show();
    } else {
        Toast.makeText(context, "锁定失败", Toast.LENGTH_SHORT).show();
    }
}
```

**锁定类型对应关系表**:

| 锁定对象 | 解锁                 | 暂时锁定           | 永久锁定                |
| -------- | -------------------- | ------------------ | ----------------------- |
| 访问密码 | ACCESS_PASSWD_UNLOCK | ACCESS_PASSWD_LOCK | ACCESS_PASSWD_PERM_LOCK |
| 销毁密码 | KILL_PASSWORD_UNLOCK | KILL_PASSWORD_LOCK | KILL_PASSWORD_PERM_LOCK |
| EPC区    | BANK1_UNLOCK         | BANK1_LOCK         | BANK1_PERM_LOCK         |
| TID区    | BANK2_UNLOCK         | BANK2_LOCK         | BANK2_PERM_LOCK         |
| USER区   | BANK3_UNLOCK         | BANK3_LOCK         | BANK3_PERM_LOCK         |

**⚠️ 重要注意事项**:

- **锁定前必须先设置访问密码为非0**
- **永久锁定不可逆，务必谨慎使用**
- 建议添加二次确认对话框
- 必须设置过滤条件，确保只操作目标标签
- 锁定后的操作需要提供正确的访问密码

**带确认对话框的实现**:

```java
AlertDialog.Builder builder = new AlertDialog.Builder(this);
builder.setTitle("警告");
builder.setMessage("锁定操作不可轻易撤销，确认继续？");
builder.setPositiveButton("确认", (dialog, which) -> {
    // 执行锁定操作
    lockEPC();
});
builder.setNegativeButton("取消", (dialog, which) -> {
    dialog.cancel();
});
builder.create().show();
```

#### 2.6.5 销毁标签

```java
Reader.READER_ERR killTag(
    int ant,              // 天线编号
    byte[] killpasswd,    // 销毁密码（4字节）
    short timeout         // 超时时间
)
```

**功能说明**:

- **标签被销毁后永久失效，无法恢复**
- 销毁前必须先将销毁密码设置为非0
- 这是最危险的操作，务必谨慎使用

**使用示例**:

```java
private void killTag() {
    // 1. 准备销毁密码
    byte[] killPwd = {0x11, 0x22, 0x33, 0x44};
    
    // 2. 设置过滤条件
    if(!setFilter()){
        Toast.makeText(context, "设置过滤失败", Toast.LENGTH_SHORT).show();
        return;
    }
    
    // 3. 销毁标签
    Reader.READER_ERR er = UHFEngine.getEngine().killTag(
        1,
        killPwd,
        (short)1000
    );
    
    // 4. 清除过滤
    resetFilter();
    
    // 5. 处理结果
    if (er == Reader.READER_ERR.MT_OK_ERR) {
        Toast.makeText(context, "标签已销毁", Toast.LENGTH_SHORT).show();
    } else {
        Toast.makeText(context, "销毁失败", Toast.LENGTH_SHORT).show();
    }
}
```

**⚠️ 严重警告**:

- **销毁操作不可逆，标签将永久失效**
- **必须实现多重确认机制**
- 建议记录销毁操作日志
- 仅在必要时使用（如退役、安全销毁）

**推荐的确认流程**:

```java
AlertDialog.Builder builder = new AlertDialog.Builder(this);
builder.setTitle("⚠️ 危险操作");
builder.setMessage("销毁后标签将永久失效且无法恢复！\n确认要销毁标签吗？");
builder.setPositiveButton("确认销毁", (dialog, which) -> {
    // 二次确认
    new AlertDialog.Builder(this)
        .setTitle("最后确认")
        .setMessage("再次确认销毁操作？")
        .setPositiveButton("确认", (d, w) -> killTag())
        .setNegativeButton("取消", null)
        .show();
});
builder.setNegativeButton("取消", null);
builder.create().show();
```

------

## 三、UHFParamsOperator 核心接口

### 3.1 基本用法

所有参数操作通过单例模式调用：

```java
UHFParamsOperator.getInstance().xxx()
```

### 3.2 天线功率配置

#### 3.2.1 设置天线功率

```java
Reader.READER_ERR setAntPowerConf(Reader.AntPowerConf apcf)
```

**完整配置示例**:

```java
private void setPower(int readPower, int writePower) {
    Reader.AntPowerConf apcf = new Reader.AntPowerConf();
    apcf.antcnt = 1;  // PDA只有一个天线
    
    Reader.AntPower antPower = new Reader.AntPower();
    antPower.readPower = readPower;   // 读取功率（单位：0.01dBm）
    antPower.writePower = writePower; // 写入功率
    antPower.antid = 1;               // 天线ID
    
    apcf.Powers[0] = antPower;  // PDA只有一个天线
    
    Reader.READER_ERR er = UHFParamsOperator.getInstance().setAntPowerConf(apcf);
    if (er == Reader.READER_ERR.MT_OK_ERR) {
        Log.i("UHF", "设置功率成功");
    } else {
        Log.e("UHF", "设置功率失败");
    }
}

// 使用示例
setPower(3300, 3300);  // 设置为33dBm
```

**功率单位说明**:

- 单位：0.01 dBm
- 例如：`3300` 表示 33.00 dBm
- 通常范围：1000-3300（10-33 dBm）

#### 3.2.2 获取当前功率

```java
AntPowerConfResult getAntPowerConf()
```

**使用示例**:

```java
AntPowerConfResult result = UHFParamsOperator.getInstance().getAntPowerConf();
if(result.code == Reader.READER_ERR.MT_OK_ERR){
    // PDA只需要获取第一个天线的功率
    int readPower = result.value.Powers[0].readPower;
    int writePower = result.value.Powers[0].writePower;
    Log.i("UHF", "读功率: " + readPower + ", 写功率: " + writePower);
}
```

#### 3.2.3 获取功率范围

```java
// 获取最大功率
MaxPowerResult getMaxPower()

// 获取最小功率
MinPowerResult getMinPower()
```

**使用示例**:

```java
MaxPowerResult maxResult = UHFParamsOperator.getInstance().getMaxPower();
MinPowerResult minResult = UHFParamsOperator.getInstance().getMinPower();

if(maxResult.code == Reader.READER_ERR.MT_OK_ERR){
    int maxPower = maxResult.value;
    Log.i("UHF", "最大功率: " + maxPower);
}

if(minResult.code == Reader.READER_ERR.MT_OK_ER   R){
    int minPower = minResult.value; Log.i("UHF", "最小功率: " + minPower); 
}
```

**注意事项**:

- 返回的是模块支持的功率范围，不是单个天线的
- 设置功率时不要超出此范围
- 功率越大，读取距离越远，但功耗也越高

---

### 3.3 会话（Session）配置

#### 3.3.1 设置会话

```java
Reader.READER_ERR setGen2Session(InventoryModeParams.SESSION session)
```

**Session 说明**:

- `SESSION0`: 速度快，适合标签数量少的场景
- `SESSION1`: 适合标签数量多的场景
- `SESSION2`: 中等速度
- `SESSION3`: 较慢但更稳定

**使用示例**:

```java
Reader.READER_ERR er = UHFParamsOperator.getInstance().setGen2Session(
    InventoryModeParams.SESSION.SESSION1
);
if (er == Reader.READER_ERR.MT_OK_ERR) {
    Log.i("UHF", "设置Session成功");
} else {
    Log.e("UHF", "设置Session失败");
}
```

#### 3.3.2 获取当前会话

```java
Gen2SessionResult getGen2Session()
```

**使用示例**:

```java
Gen2SessionResult result = UHFParamsOperator.getInstance().getGen2Session();
if(result.code == Reader.READER_ERR.MT_OK_ERR){
    Log.i("UHF", "当前Session: " + result.value);
}
```

**使用建议**:

- 标签少（< 50）：使用 SESSION0，速度最快
- 标签多（> 100）：使用 SESSION1，避免冲突
- 需要稳定性：使用 SESSION2 或 SESSION3

------

### 3.4 目标（Target）配置

#### 3.4.1 设置目标

```java
Reader.READER_ERR setGen2Target(InventoryModeParams.TARGET target)
```

**Target 选项**:

- `A`: 只读取标记为 A 的标签
- `B`: 只读取标记为 B 的标签
- `A_2_B`: 读取 A 标签并转为 B（推荐）
- `B_2_A`: 读取 B 标签并转为 A

**使用示例**:

```java
Reader.READER_ERR er = UHFParamsOperator.getInstance().setGen2Target(
    InventoryModeParams.TARGET.A_2_B
);
if (er == Reader.READER_ERR.MT_OK_ERR) {
    Log.i("UHF", "设置Target成功");
}
```

#### 3.4.2 获取当前目标

```java
Gen2TargetResult getGen2Target()
```

**使用示例**:

```java
Gen2TargetResult result = UHFParamsOperator.getInstance().getGen2Target();
if (result.code == Reader.READER_ERR.MT_OK_ERR) {
    Log.i("UHF", "当前Target: " + result.value);
}
```

**使用建议**:

- 通常使用 `A_2_B`（默认推荐）
- 配合 Session 使用可优化盘点性能

------

### 3.5 区域（Region）配置

#### 3.5.1 设置区域

```java
Reader.READER_ERR setRegionConf(Reader.Region_Conf region)
```

**区域选项**:

- `RG_NA`: 北美（美国、加拿大）
- `RG_PRC`: 中国（920-925 MHz）
- `RG_EU`: 欧洲（865-868 MHz）
- `RG_OPEN`: 全频段

**使用示例**:

```java
Reader.READER_ERR er = UHFParamsOperator.getInstance().setRegionConf(
    Reader.Region_Conf.RG_PRC  // 中国区域
);
if (er == Reader.READER_ERR.MT_OK_ERR) {
    Log.i("UHF", "设置区域成功");
}
```

#### 3.5.2 获取当前区域

```java
RegionConfResult getRegionConf()
```

**使用示例**:

```java
RegionConfResult result = UHFParamsOperator.getInstance().getRegionConf();
if (result.code == Reader.READER_ERR.MT_OK_ERR) {
    String regionName = CoverUtil.CoverRegion(result.value);
    Log.i("UHF", "当前区域: " + regionName);
}
```

**⚠️ 重要注意事项**:

- **必须根据使用国家/地区设置正确的区域**
- 使用错误的区域可能违反当地无线电法规
- 中国境内必须使用 `RG_PRC`
- 不确定时可使用 `RG_OPEN`，但可能性能不佳

------

### 3.6 标签过滤配置

#### 3.6.1 设置过滤条件

```java
Reader.READER_ERR setTagFilter(Reader.TagFilter_ST filter)
```

**TagFilter_ST 参数说明**:

```java
Reader.TagFilter_ST filter = new Reader.TagFilter_ST();
filter.bank = 1;           // 过滤的存储区（0-4）
filter.startaddr = 32;     // 起始地址（bit）
filter.flen = 96;          // 过滤数据长度（bit）
filter.fdata = epcBytes;   // 过滤数据（字节数组）
filter.isInvert = 0;       // 是否反向匹配（0=否，1=是）
```

**完整过滤示例（根据EPC过滤）**:

```java
private boolean setFilter(String epcHex) {
    // 1. 转换 EPC 为字节数组
    byte[] epcBytes = new byte[epcHex.length() / 2];
    UHFUtils.Str2Hex(epcHex, epcHex.length(), epcBytes);
    
    // 2. 创建过滤器
    Reader.TagFilter_ST filter = new Reader.TagFilter_ST();
    filter.fdata = epcBytes;
    filter.flen = epcBytes.length * 8;  // 转换为 bit
    filter.isInvert = 0;  // 正向匹配
    filter.bank = InventoryModeParams.BANK.EPC;  // EPC 区
    filter.startaddr = 32;  // 跳过 PC 字段（EPC 区前 32 bit）
    
    // 3. 设置过滤
    Reader.READER_ERR er = UHFParamsOperator.getInstance().setTagFilter(filter);
    if (er == Reader.READER_ERR.MT_OK_ERR) {
        Log.i("UHF", "设置过滤成功");
        return true;
    } else {
        Log.e("UHF", "设置过滤失败");
        return false;
    }
}
```

**过滤 TID 示例**:

```java
private boolean setFilterByTID(String tidHex) {
    byte[] tidBytes = new byte[tidHex.length() / 2];
    UHFUtils.Str2Hex(tidHex, tidHex.length(), tidBytes);
    
    Reader.TagFilter_ST filter = new Reader.TagFilter_ST();
    filter.fdata = tidBytes;
    filter.flen = tidBytes.length * 8;
    filter.isInvert = 0;
    filter.bank = InventoryModeParams.BANK.TID;  // TID 区
    filter.startaddr = 0;  // TID 从 0 开始
    
    Reader.READER_ERR er = UHFParamsOperator.getInstance().setTagFilter(filter);
    return (er == Reader.READER_ERR.MT_OK_ERR);
}
```

#### 3.6.2 清除过滤条件

```java
Reader.READER_ERR setTagFilter(null)
```

**使用示例**:

```java
private void resetFilter() {
    UHFParamsOperator.getInstance().setTagFilter(null);
    Log.i("UHF", "过滤条件已清除");
}
```

**⚠️ 过滤使用注意事项**:

- **读写操作前必须设置过滤**，否则可能操作到多个标签
- **操作完成后必须清除过滤**，否则影响后续盘点
- 过滤数据长度必须正确（字节长度 × 8 = bit 长度）
- EPC 过滤时注意跳过 PC 字段（startaddr = 32）
- 过滤数据必须完全匹配

**过滤流程模板**:

```java
// 1. 设置过滤
if(!setFilter(epcData)){
    Toast.makeText(context, "设置过滤失败", Toast.LENGTH_SHORT).show();
    return;
}

// 2. 执行读写操作
Reader.READER_ERR er = UHFEngine.getEngine().writeTagData(...);

// 3. 清除过滤
resetFilter();

// 4. 处理结果
if (er == Reader.READER_ERR.MT_OK_ERR) {
    // 成功处理
}
```

------

### 3.7 其他参数配置

#### 3.7.1 设置编码模式

```java
Reader.READER_ERR setGen2TagEncoding(int rfmode)
```

**使用场景**:

- 调整编码模式以适应不同标签类型
- 通常使用默认值即可

#### 3.7.2 完整初始化示例

```java
private void initModule() {
    // 1. 设置功率
    Reader.AntPowerConf apcf = new Reader.AntPowerConf();
    apcf.antcnt = 1;
    Reader.AntPower antPower = new Reader.AntPower();
    antPower.readPower = 3300;   // 33 dBm
    antPower.writePower = 3300;
    antPower.antid = 1;
    apcf.Powers[0] = antPower;
    
    Reader.READER_ERR er = UHFParamsOperator.getInstance().setAntPowerConf(apcf);
    Log.i("UHF", "设置功率: " + (er == Reader.READER_ERR.MT_OK_ERR ? "成功" : "失败"));
    
    // 2. 设置 Session
    er = UHFParamsOperator.getInstance().setGen2Session(
        InventoryModeParams.SESSION.SESSION1
    );
    Log.i("UHF", "设置Session: " + (er == Reader.READER_ERR.MT_OK_ERR ? "成功" : "失败"));
    
    // 3. 设置 Target
    er = UHFParamsOperator.getInstance().setGen2Target(
        InventoryModeParams.TARGET.A_2_B
    );
    Log.i("UHF", "设置Target: " + (er == Reader.READER_ERR.MT_OK_ERR ? "成功" : "失败"));
    
    // 4. 设置区域
    er = UHFParamsOperator.getInstance().setRegionConf(
        Reader.Region_Conf.RG_PRC
    );
    Log.i("UHF", "设置区域: " + (er == Reader.READER_ERR.MT_OK_ERR ? "成功" : "失败"));
}
```

------

## 四、工具类和辅助方法

### 4.1 UHFUtils 工具类

#### 4.1.1 字符串转字节数组

```java
UHFUtils.Str2Hex(String hexString, int length, byte[] output)
```

**使用示例**:

```java
String epcHex = "E280116060000207001234567890";
byte[] epcBytes = new byte[epcHex.length() / 2];
UHFUtils.Str2Hex(epcHex, epcHex.length(), epcBytes);
```

#### 4.1.2 字节数组转字符串

```java
String Reader.bytes_Hexstr(byte[] data)
```

**使用示例**:

```java
byte[] epcData = {(byte)0xE2, (byte)0x80, 0x11, 0x60};
String epcHex = Reader.bytes_Hexstr(epcData);
// 结果: "E2801160"
```

### 4.2 自定义工具方法

```java
public class Util {
    // 字节数组转十六进制字符串（自定义格式）
    public static String bytes2hex(byte[] bytes) {
        StringBuilder sb = new StringBuilder();
        for (byte b : bytes) {
            sb.append(String.format("%02X", b));
        }
        return sb.toString();
    }
    
    // 时间格式化（秒转 HH:MM:SS）
    public static String getTimeMode(long seconds) {
        long hours = seconds / 3600;
        long minutes = (seconds % 3600) / 60;
        long secs = seconds % 60;
        return String.format("%02d:%02d:%02d", hours, minutes, secs);
    }
    
    // 获取当前时间戳字符串
    public static String getCurrentTimeFormat() {
        SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd_HHmmss", Locale.getDefault());
        return sdf.format(new Date());
    }
}
```

------

## 五、最佳实践和注意事项

### 5.1 生命周期管理

```java
@Override
protected void onResume() {
    // 1. 上电
    UHFEngine.getEngine().powerOn();
    
    // 2. 连接模块
    Reader.READER_ERR er = UHFEngine.getEngine().connectModule(
        DefaultConfigure.UART_DEV_PATH, 1
    );
    
    // 3. 初始化参数（仅连接成功后）
    if(er == Reader.READER_ERR.MT_OK_ERR){
        initModule();
    }
    
    super.onResume();
}

@Override
protected void onPause() {
    // 1. 停止盘点（如果正在运行）
    if(inventoryRunning){
        UHFEngine.getEngine().stopInventory();
        inventoryRunning = false;
    }
    
    // 2. 断开连接
    UHFEngine.getEngine().disconnectModule();
    
    // 3. 下电
    UHFEngine.getEngine().powerOff();
    
    super.onPause();
}
```

### 5.2 错误处理

```java
// 推荐的错误处理模式
Reader.READER_ERR er = UHFEngine.getEngine().someOperation();

switch(er) {
    case MT_OK_ERR:
        // 成功
        Toast.makeText(context, "操作成功", Toast.LENGTH_SHORT).show();
        break;
    case MT_CMD_FAILED_ERR:
        Toast.makeText(context, "命令失败", Toast.LENGTH_SHORT).show();
        break;
    case MT_TIMEOUT_ERR:
        Toast.makeText(context, "操作超时", Toast.LENGTH_SHORT).show();
        break;
    default:
        Toast.makeText(context, "未知错误: " + er, Toast.LENGTH_SHORT).show();
        break;
}
```

### 5.3 重试机制

```java
// 推荐的重试模式
private Reader.READER_ERR retryOperation(int maxRetries) {
    Reader.READER_ERR er = null;
    for(int i = 0; i < maxRetries; i++) {
        er = UHFEngine.getEngine().someOperation();
        if(er == Reader.READER_ERR.MT_OK_ERR) {
            break;  // 成功，跳出循环
        }
        // 可选：添加延迟
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    return er;
}

// 使用
Reader.READER_ERR result = retryOperation(3);  // 最多重试3次
```

### 5.4 线程安全

```java
// UI 更新必须在主线程
runOnUiThread(new Runnable() {
    @Override
    public void run() {
        textView.setText("更新内容");
        Toast.makeText(context, "提示信息", Toast.LENGTH_SHORT).show();
    }
});

// 或使用 Handler
handler.post(() -> {
    textView.setText("更新内容");
});
```

### 5.5 按键监听（硬件按键触发盘点）

```java
@Override
public boolean onKeyDown(int keyCode, KeyEvent event) {
    // 监听硬件扫描键（通常是 292 或 F1）
    if(!iskeydown && (keyCode == 292 || keyCode == KeyEvent.KEYCODE_F1)){
        iskeydown = true;
        
        if(inventoryRunning){
            // 停止盘点
            UHFEngine.getEngine().stopInventory();
            inventoryRunning = false;
        } else {
            // 启动盘点
            InventoryParams params = InventoryModeParams.getParams(
                DefaultConfigure.inventorymode,
                DefaultConfigure.inventoryParams,
                DefaultConfigure.inventorywithtid
            );
            
            Reader.READER_ERR er = UHFEngine.getEngine().startInventory(
                params, readListener, exceptionListener
            );
            
            if (er == Reader.READER_ERR.MT_OK_ERR) {
                inventoryRunning = true;
            }
        }
    }
    return super.onKeyDown(keyCode, event);
}

@Override
public boolean onKeyUp(int keyCode, KeyEvent event) {
    if(iskeydown && (keyCode == 292 || keyCode == KeyEvent.KEYCODE_F1)){
        iskeydown = false;
    }
    return super.onKeyUp(keyCode, event);
}
```

### 5.6 数据去重和统计

```java
// 标签信息类
public class UHFCardInfo {
    public String epc;      // EPC 数据
    public String tid;      // TID 数据
    public int rssi;        // 信号强度
    public int Frequency;   // 频率
    public int count;       // 读取次数
}

// 去重添加到列表
private void putCardInfoToList(UHFCardInfo newCard) {
    int pos = getCardInfoIndex(newCard);
    
    if(pos != -1) {
        // 已存在，更新信息
        UHFCardInfo existingCard = cardList.get(pos);
        existingCard.count++;
        existingCard.rssi = newCard.rssi;
        existingCard.Frequency = newCard.Frequency;
        
        // 更新 TID（如果为空或有新数据）
        if(existingCard.tid.isEmpty() || !newCard.tid.isEmpty()){
            existingCard.tid = newCard.tid;
        }
    } else {
        // 新标签
        newCard.count = 1;
        cardList.add(newCard);
    }
}

private int getCardInfoIndex(UHFCardInfo card) {
    for (int i = 0; i < cardList.size(); i++) {
        if(card.epc.equals(cardList.get(i).epc)){
            return i;
        }
    }
    return -1;
}
```

### 5.7 性能优化建议

1. **盘点性能优化**:
   - 标签少时使用 SESSION0
   - 标签多时使用 SESSION1
   - 不需要 TID 时关闭 TID 读取
   - 调整功率平衡距离和速度
2. **内存优化**:
   - 及时清理不需要的标签列表
   - 使用对象池复用对象
   - 避免频繁创建大对象
3. **电池优化**:
   - 不使用时及时断开连接和下电
   - 降低功率可延长电池寿命
   - 避免长时间高功率运行

### 5.8 常见问题排查

| 问题         | 可能原因         | 解决方案               |
| ------------ | ---------------- | ---------------------- |
| 无法连接模块 | 串口路径错误     | 确认设备型号和串口路径 |
| 读不到标签   | 功率太低         | 增加功率或靠近标签     |
| 读取失败     | 未设置过滤       | 操作前设置过滤条件     |
| 盘点速度慢   | Session 配置不当 | 标签少用 SESSION0      |
| 写入失败     | 标签被锁定       | 提供访问密码或解锁     |
| 重复读取     | 未去重           | 实现去重逻辑           |

------

## 六、完整示例代码

### 6.1 简单盘点应用

```java
public class SimpleInventoryActivity extends Activity {
    private boolean inventoryRunning = false;
    private List<UHFCardInfo> tagList = new ArrayList<>();
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_inventory);
        
        // 初始化 UI
        Button startBtn = findViewById(R.id.startBtn);
        startBtn.setOnClickListener(v -> toggleInventory());
    }
    
    @Override
    protected void onResume() {
        super.onResume();
        // 上电并连接
        UHFEngine.getEngine().powerOn();
        Reader.READER_ERR er = UHFEngine.getEngine().connectModule("/dev/ttysWK0", 1);
        if(er == Reader.READER_ERR.MT_OK_ERR){
            initModule();
        }
    }
    
    @Override
    protected void onPause() {
        super.onPause();
        // 停止盘点
        if(inventoryRunning){
            UHFEngine.getEngine().stopInventory();
        }
        // 断开并下电
        UHFEngine.getEngine().disconnectModule();
        UHFEngine.getEngine().powerOff();
    }
    
    private void initModule() {
        // 设置功率
        Reader.AntPowerConf apcf = new Reader.AntPowerConf();
        apcf.antcnt = 1;
        Reader.AntPower antPower = new Reader.AntPower();
        antPower.readPower = 3300;
        antPower.writePower = 3300;
        antPower.antid = 1;
        apcf.Powers[0] = antPower;
        UHFParamsOperator.getInstance().setAntPowerConf(apcf);
        
        // 设置区域
        UHFParamsOperator.getInstance().setRegionConf(Reader.Region_Conf.RG_PRC);
    }
    
    private void toggleInventory() {
        if(inventoryRunning){
            // 停止
            UHFEngine.getEngine().stopInventory();
            inventoryRunning = false;
        } else {
            // 启动
            InventoryParams params = InventoryModeParams.getParams(
                InventoryModeParams.MODE.NORMAL,
                null,
                false  // 不读取 TID
            );
            
            Reader.READER_ERR er = UHFEngine.getEngine().startInventory(
                params, tagReadListener, exceptionListener
            );
            
            if(er == Reader.READER_ERR.MT_OK_ERR){
                inventoryRunning = true;
            }
        }
    }
    
    private ReadListener tagReadListener = new ReadListener() {
        @Override
        public void tagRead(List<Reader.TagInfo> list) {
            if (list == null) return;
            
            for (Reader.TagInfo tag : list) {
                String epc = Reader.bytes_Hexstr(tag.EpcId);
                Log.i("UHF", "读到标签: " + epc);
                
                // 添加到列表（去重）
                addTag(epc, tag.RSSI);
            }
            
            // 更新 UI
            runOnUiThread(() -> updateUI());
        }
    };
    
    private ReadExceptionListener exceptionListener = new ReadExceptionListener() {
        @Override
        public void tagReadException(Reader.READER_ERR er) {
            Log.e("UHF", "盘点异常: " + er);
        }
    };
    
    private void addTag(String epc, int rssi) {
        // 实现去重逻辑
        for (UHFCardInfo card : tagList) {
            if(card.epc.equals(epc)){
                card.count++;
                card.rssi = rssi;
                return;
            }
        }
        
        // 新标签
        UHFCardInfo newCard = new UHFCardInfo();
        newCard.epc = epc;
        newCard.rssi = rssi;
        newCard.count = 1;
        tagList.add(newCard);
    }
    
    private void updateUI() {
        // 更新列表显示
        // adapter.notifyDataSetChanged();
    }
}
```

------

## 七、总结

### 7.1 开发流程

1. **初始化阶段**:
   - 上电 → 连接模块 → 配置参数
2. **操作阶段**:
   - 盘点：启动盘点 → 处理回调 → 停止盘点
   - 读写：设置过滤 → 执行操作 → 清除过滤
3. **清理阶段**:
   - 停止操作 → 断开连接 → 下电

### 7.2 关键要点

- ✅ 始终在 Activity 生命周期中管理模块状态
- ✅ 读写操作必须设置过滤条件
- ✅ 操作完成后清除过滤
- ✅ 实现重试机制提高成功率
- ✅ UI 更新切换到主线程
- ⚠️ 永久锁定和销毁操作不可逆
- ⚠️ 根据地区正确设置频率区域

### 7.3 推荐配置

```java
// 通用推荐配置
功率: 3300 (33 dBm)
Session: SESSION1（标签多）/ SESSION0（标签少）
Target: A_2_B
区域: RG_PRC（中国）
```





















