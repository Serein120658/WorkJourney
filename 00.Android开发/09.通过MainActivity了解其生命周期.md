

# RFID 应用代码架构分析文档

> 基于 MainActivity.java 的完整解析

## 代码

### 原始shit

```java
package com.pda.testuhfapi;

import androidx.appcompat.app.AppCompatActivity;

import android.app.Activity;
import android.content.Intent;
import android.media.AudioManager;
import android.media.SoundPool;
import android.os.Bundle;
import android.os.Environment;
import android.os.Handler;
import android.os.Message;
import android.util.Log;
import android.view.KeyEvent;
import android.view.View;
import android.widget.AdapterView;
import android.widget.Button;
import android.widget.ListView;
import android.widget.TextView;
import android.widget.Toast;

import com.pda.Excel.ExcelUtil;
import com.pda.adapter.CardDeviceList;
import com.pda.adapter.CardInfoAdaptar;
import com.pda.adapter.UHFCardInfo;
import com.pda.uhf.UHFEngine;
import com.pda.uhf.UHFParamsOperator;
import com.pda.uhf.UHFSetting;
import com.pda.uhf.model.InventoryMode;
import com.pda.uhf.model.InventoryParams;
import com.pda.uhf.model.params.AntPowerConfResult;
import com.pda.uhf.model.params.Gen2SessionResult;
import com.pda.uhf.model.params.Gen2TargetResult;
import com.pda.uhf.model.params.MaxPowerResult;
import com.pda.uhf.model.params.RegionConfResult;
import com.uhf.api.cls.ReadExceptionListener;
import com.uhf.api.cls.ReadListener;
import com.uhf.api.cls.Reader;

import java.util.ArrayList;
import java.util.*;


public class MainActivity extends Activity implements View.OnClickListener, AdapterView.OnItemClickListener {
    private List<String> Alllist = new ArrayList<String>();
    private SoundPool soundPool = null;
    private boolean iskeydown = false;
    private boolean inventoryRunning = false;

    private CardDeviceList mCardDeviceList = null;
    private CardInfoAdaptar mCardInfoAdaptar = null;
    private ListView cardInfoListView = null;
    private Handler delayHandler = null;
    private final static int INIT_SUCCESS = 1;
    private final static int SHOW_TOAST = 2;
    private final static int BTN_CHANGED = 4;
    private final static int UPDATE_LIST = 3;
    private final static int UPDATE_OTHER_UI = 5;
    private final static int UPDATE_TIME_UI = 6;
    private final static int UPDATE_TIME_UI_LOOP = 7;
    private final static int START_FAILED = 8;
    private TextView tagscount = null;
    private Button startInventoryBtn = null;
    private Button cleanBtn = null;
    private Button settingBtn = null;
    private long inventorytimes = 0;

    private TextView inventorytime = null;

    private Button exportBtn = null;

    private Button mockDataBtn = null;
    private String message = "";

    private void addList(String EcpString){

        for(int i = 0; i < Alllist.size();i++){
            if(EcpString.equals(Alllist.get(i))){
                return;
            }
        }


        Alllist.add(EcpString);
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        //修改权限
        UHFSetting.initRoot(getApplicationContext());
        //初始化声音
        soundPool = new SoundPool(10, AudioManager.STREAM_SYSTEM, 5);
        soundPool.load(this, R.raw.beep333, 1);

        cardInfoListView = findViewById(R.id.cardinfo_list);

        //count = findViewById(R.id.count);
        mCardDeviceList = CardDeviceList.getInstance();
        if(mCardInfoAdaptar == null){
            mCardInfoAdaptar = new CardInfoAdaptar(getApplicationContext(),mCardDeviceList.cardInfos);
            mCardInfoAdaptar.setCardInfos(mCardDeviceList.cardInfos);
            cardInfoListView.setAdapter(mCardInfoAdaptar);
            cardInfoListView.setOnItemClickListener(this);
        }

        tagscount = findViewById(R.id.tagscount);

        startInventoryBtn = findViewById(R.id.startInventoryBtn);
        startInventoryBtn.setOnClickListener(this);

        cleanBtn = findViewById(R.id.cleanBtn);
        cleanBtn.setOnClickListener(this);

        settingBtn = findViewById(R.id.settingBtn);
        settingBtn.setOnClickListener(this);

        inventorytime = findViewById(R.id.inventorytime);
        //inventorytime.setText(Util.getTimeMode(3600));

        exportBtn = findViewById(R.id.exportBtn);
        exportBtn.setOnClickListener(this);

        // todo  测试在main中添加的测试代码
        mockDataBtn = findViewById(R.id.mockDataBtn);
        mockDataBtn.setOnClickListener(this);


        delayHandler = new Handler() {
            @Override
            public void handleMessage(Message msg) {
                Bundle mBundle = null;
                switch (msg.what) {

                    case INIT_SUCCESS:
                        //if(start_invenroty_btn != null)
                        //    start_invenroty_btn.setEnabled(UHFConfigure.initsucess);
                        break;
                    case SHOW_TOAST:
                        Toast.makeText(getApplicationContext(),message,Toast.LENGTH_SHORT).show();
                        //manager.writeEpcByEpcNoPassword(new byte[]{0x11,0x22,0x33,0x44,0x55,0x66,0x77,(byte) 0x88},new byte[]{0x01,0x02,0x03,0x04,0x05,0x06,0x07,(byte) 0x08});
                        //manager.writeEpcByTidNoPassword(new byte[]{0x11,0x22,0x33,0x44,0x55,0x66,0x77,(byte) 0x88},new byte[]{0x01,0x02,0x03,0x04,0x05,0x06,0x07,(byte) 0x08});
                        break;
                    case UPDATE_LIST:
                        mCardInfoAdaptar.notifyDataSetChanged();
                        tagscount.setText("Tags Count:"+mCardDeviceList.cardInfos.size()+"  Tags Times:"+mCardDeviceList.allcount);
                        break;
                    case BTN_CHANGED:
                        startInventoryBtn.setText(inventoryRunning?R.string.stop_inventory:R.string.start_inventory);
                        break;
                    case UPDATE_OTHER_UI:
                        break;
                    case UPDATE_TIME_UI:
                        inventorytime.setText(Util.getTimeMode(inventorytimes));
                        break;
                    case UPDATE_TIME_UI_LOOP:
                        inventorytimes++;
                        delayHandler.sendEmptyMessage(UPDATE_TIME_UI);
                        delayHandler.sendEmptyMessageDelayed(UPDATE_TIME_UI_LOOP,1000);
                        break;
                }
            }
        };
    }
    /*
    private void defaultInitModule(){
        //设置功率
        Reader.AntPowerConf apcf = new Reader.AntPowerConf();
        apcf.antcnt =1;//设定天线个数，PDA只有一个天线
        Reader.AntPower jaap = new Reader.AntPower();
        jaap.readPower=DefaultConfigure.readpower;//读取功率,根据需要更改
        jaap.writePower=DefaultConfigure.writepower;//写功率,根据需要更改
        jaap.antid = 1;//天线1，PDA只有一个天线
        apcf.Powers[0] = jaap;//PDA只有一个天线
        Reader.READER_ERR er = UHFParamsOperator.getInstance().setAntPowerConf(apcf);

        //设置session
        er = UHFParamsOperator.getInstance().setGen2Session(DefaultConfigure.session);
        //target设置
        er = UHFParamsOperator.getInstance().setGen2Target(DefaultConfigure.target);
        //区域设置
        //Region_Conf.RG_NA 北美
        //Region_Conf.RG_PRC 中国1
        //Region_Conf.RG_EU 欧洲
        //Region_Conf.RG_OPEN 全频段
        er = UHFParamsOperator.getInstance().setRegionConf(DefaultConfigure.region);

        er = UHFParamsOperator.getInstance().setGen2TagEncoding(DefaultConfigure.rfmode);

    }

     */
    private void initModule(){
        //设置功率
        Reader.AntPowerConf apcf = new Reader.AntPowerConf();
        apcf.antcnt =1;//设定天线个数，PDA只有一个天线
        Reader.AntPower jaap = new Reader.AntPower();
        jaap.readPower=3300;//读取功率,根据需要更改
        jaap.writePower=3300;//写功率,根据需要更改
        jaap.antid = 1;//天线1，PDA只有一个天线
        apcf.Powers[0] = jaap;//PDA只有一个天线

        Reader.READER_ERR er = UHFParamsOperator.getInstance().setAntPowerConf(apcf);
        if (er == Reader.READER_ERR.MT_OK_ERR) {
            Log.e("##","设置power 成功");
        }else{
            Log.e("##","设置power 失败");
        }

        //设置session
        Gen2SessionResult mGen2SessionResult = UHFParamsOperator.getInstance().getGen2Session();
        Log.e("##","设置之前session:"+mGen2SessionResult.value);
        er = UHFParamsOperator.getInstance().setGen2Session(InventoryModeParams.SESSION.SESSION1);
        //session 0 - 3
        //普通使用session0，速度快，但是不适合过多标签
        //太多标签使用session1
        if (er == Reader.READER_ERR.MT_OK_ERR) {
            Log.e("##","设置Session 成功");
        }else{
            Log.e("##","设置Session 失败");
        }
        mGen2SessionResult = UHFParamsOperator.getInstance().getGen2Session();
        Log.e("##","设置之后session:"+mGen2SessionResult.value);

        //target设置
        Gen2TargetResult result = UHFParamsOperator.getInstance().getGen2Target();
        if (result.code == Reader.READER_ERR.MT_OK_ERR) {
            Log.e("##","设置前获取Target 成功，Target="+result.value);

        }else{
            Log.e("##","设置前获取Target 失败");
        }
        er = UHFParamsOperator.getInstance().setGen2Target(InventoryModeParams.TARGET.A_2_B);
        if (er == Reader.READER_ERR.MT_OK_ERR) {
            Log.e("##","设置Target 成功");
        }else{
            Log.e("##","设置Target 失败");
        }
        result = UHFParamsOperator.getInstance().getGen2Target();
        if (result.code == Reader.READER_ERR.MT_OK_ERR) {
            Log.e("##","设置后获取Target 成功，Target="+result.value);

        }else{
            Log.e("##","设置后获取Target 失败");
        }

        //区域设置
        //Region_Conf.RG_NA 北美
        //Region_Conf.RG_PRC 中国1
        //Region_Conf.RG_EU 欧洲
        //Region_Conf.RG_OPEN 全频段
        RegionConfResult mRegionConfResult = UHFParamsOperator.getInstance().getRegionConf();
        if (mRegionConfResult.code == Reader.READER_ERR.MT_OK_ERR) {
            Log.e("##","设置前获取Region 成功，Region="+CoverUtil.CoverRegion(mRegionConfResult.value));

        }else{
            Log.e("##","设置前获取Region 失败");
        }
        er = UHFParamsOperator.getInstance().setRegionConf(Reader.Region_Conf.RG_PRC);
        if (er == Reader.READER_ERR.MT_OK_ERR) {
            Log.e("##","设置Region 成功");
        }else{
            Log.e("##","设置Region 失败");
        }
        mRegionConfResult = UHFParamsOperator.getInstance().getRegionConf();
        if (mRegionConfResult.code == Reader.READER_ERR.MT_OK_ERR) {
            Log.e("##","设置后获取Region 成功，Region="+CoverUtil.CoverRegion(mRegionConfResult.value));

        }else{
            Log.e("##","设置后获取Region 失败");
        }
    }
    @Override
    protected void onResume() {
         // todo 测试先去除
        //上电
        UHFEngine.getEngine().powerOn();
        //连接模块
        Reader.READER_ERR er = UHFEngine.getEngine().connectModule(DefaultConfigure.UART_DEV_PATH, 1);
        if(er == Reader.READER_ERR.MT_OK_ERR){
            //initModule();
            DefaultConfigure.defaultInitModule();
            AntPowerConfResult result = UHFParamsOperator.getInstance().getAntPowerConf();
            MainActivity.this.runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    //Toast.makeText(getApplicationContext(),"Connect success power"+result.value.Powers[0].readPower,Toast.LENGTH_SHORT).show();
                }
            });


        }else{
            MainActivity.this.runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    //Toast.makeText(getApplicationContext(),"Connect failed",Toast.LENGTH_SHORT).show();
                }
            });

        }



        super.onResume();
    }

    @Override
    protected void onPause() {
         // TODO 先去除真实设备
        //断开连接
        UHFEngine.getEngine().disconnectModule();
        //下电
        UHFEngine.getEngine().powerOff();

        super.onPause();
    }


    /**
     * 异步盘点方式监听标签事件
     */
    ReadListener RL = new ReadListener() {
        long streadt = System.currentTimeMillis();

        @Override
        public void tagRead(List<Reader.TagInfo> list) {
            if (list == null) {
                return;
            }

            for (int i = 0; i < list.size(); i++) {
                //获取盘点数据
                Reader.TagInfo tagInfo = list.get(i);
                String epcId = Reader.bytes_Hexstr(tagInfo.EpcId);
                String TidId = Reader.bytes_Hexstr(tagInfo.EmbededData);

                //addList(epcId);
                UHFCardInfo item = new UHFCardInfo();
                item.epc = epcId;
                item.tid = TidId;
                item.rssi = tagInfo.RSSI;
                item.Frequency = tagInfo.Frequency;
                Log.e("####",epcId+","+TidId+","+tagInfo.Frequency);
                putCardInfoToList(item);
                mCardDeviceList.allcount++;
            }
            mCardInfoAdaptar.setCardInfos(mCardDeviceList.cardInfos);
            delayHandler.sendEmptyMessage(UPDATE_LIST);
            //更新UI
            // 放音效
            soundPool.play(1, 1, 1, 0, 0, 1);

        }
    };
    /***
     * 异步盘点方式监听异常事件
     * */
    ReadExceptionListener REL = new ReadExceptionListener() {
        @Override
        public void tagReadException(final Reader.READER_ERR er) {

        }
    };


    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
       // Toast.makeText(getApplicationContext(),keyCode+"",Toast.LENGTH_SHORT).show();
        if(!iskeydown && (keyCode == 292 ||keyCode== KeyEvent.KEYCODE_F1)){
            if(inventoryRunning){
                //停止盘点
                delayHandler.removeMessages(UPDATE_TIME_UI_LOOP);
                delayHandler.sendEmptyMessage(BTN_CHANGED);
                UHFEngine.getEngine().stopInventory();
                inventoryRunning = false;
                settingBtn.setEnabled(true);
                exportBtn.setEnabled(true);
            }else {
                delayHandler.sendEmptyMessage(BTN_CHANGED);
                iskeydown = true;
                //获取盘点模式参数设置
                //第一个参数是盘点模式，具体参考InventoryModeParams.MODE
                //第二个参数是是否读取tid，切记只有NORNAL普通模式才起作用
                InventoryParams params = InventoryModeParams.getParams(DefaultConfigure.inventorymode,DefaultConfigure.inventoryParams,DefaultConfigure.inventorywithtid);

                //启动盘点
                //第一个参数为盘点模式参数
                //第二个参数为盘点结果回调接口,需要自行参考demo去处理回调数据
                //第三个为盘点出错回调接口
                Reader.READER_ERR er = UHFEngine.getEngine().startInventory(params, RL, REL);
                if (er != Reader.READER_ERR.MT_OK_ERR) {
                    //Toast.makeText(getApplicationContext(), "启动盘点失败！", Toast.LENGTH_SHORT).show();
                }else{
                    inventoryRunning = true;
                    inventorytimes = 0;
                    delayHandler.sendEmptyMessage(UPDATE_TIME_UI);
                    delayHandler.sendEmptyMessageDelayed(UPDATE_TIME_UI_LOOP,1000);
                    settingBtn.setEnabled(false);
                    exportBtn.setEnabled(false);
                    //Gen2SessionResult mGen2SessionResult = UHFParamsOperator.getInstance().getGen2Session();
                    //Log.e("##","启动盘点session:"+mGen2SessionResult.value);
                }

            }
        }
        return super.onKeyDown(keyCode, event);
    }

    @Override
    public boolean onKeyUp(int keyCode, KeyEvent event) {
        if(iskeydown && (keyCode == 292)||keyCode== KeyEvent.KEYCODE_F1){
            iskeydown = false;
        }
        return super.onKeyUp(keyCode, event);
    }

    private int getCardInfoIndex(UHFCardInfo mUHFCardInfo){
        int size = mCardDeviceList.cardInfos.size();
        UHFCardInfo mInfo = null;
        for (int index = 0; index < size; index++) {
            mInfo = mCardDeviceList.cardInfos.get(index);
            if(mUHFCardInfo.epc.equals(mInfo.epc)){
                return index;
            }
        }
        return -1;
    }
    private void putCardInfoToList(UHFCardInfo mUHFCardInfo){
        int pos = 0;

        pos = getCardInfoIndex(mUHFCardInfo);
        if(pos != -1){
            mCardDeviceList.cardInfos.get(pos).count = mCardDeviceList.cardInfos.get(pos).count+1;
            mUHFCardInfo.count = mCardDeviceList.cardInfos.get(pos).count;
            if(mCardDeviceList.cardInfos.get(pos).tid.equals("")){
                //mCardDeviceList.cardInfos.set(pos,mUHFCardInfo);
                mCardDeviceList.cardInfos.get(pos).tid = mUHFCardInfo.tid;
            }else{
                if(!mUHFCardInfo.tid.equals("")){
                    mCardDeviceList.cardInfos.get(pos).tid = mUHFCardInfo.tid;
                }
            }
            mCardDeviceList.cardInfos.get(pos).Frequency = mUHFCardInfo.Frequency;
            mCardDeviceList.cardInfos.get(pos).rssi = mUHFCardInfo.rssi;
            //
        }else{
            mUHFCardInfo.count = 1;
            mCardDeviceList.cardInfos.add(mUHFCardInfo);
        }
    }
    private void cleanCardInfoToList(){
        mCardDeviceList.cardInfos.clear();
    }

    @Override
    public void onClick(View view) {
        int id = view.getId();
        if(id == R.id.startInventoryBtn){
            delayHandler.sendEmptyMessage(BTN_CHANGED);
            if(inventoryRunning){
                UHFEngine.getEngine().stopInventory();
                inventoryRunning = false;
                settingBtn.setEnabled(true);
                exportBtn.setEnabled(true);
            }else{
                InventoryParams params = InventoryModeParams.getParams(DefaultConfigure.inventorymode,DefaultConfigure.inventoryParams,DefaultConfigure.inventorywithtid);

                //启动盘点
                //第一个参数为盘点模式参数
                //第二个参数为盘点结果回调接口,需要自行参考demo去处理回调数据
                //第三个为盘点出错回调接口
                Reader.READER_ERR er = UHFEngine.getEngine().startInventory(params, RL, REL);
                if (er != Reader.READER_ERR.MT_OK_ERR) {
                    //Toast.makeText(getApplicationContext(), "启动盘点失败！", Toast.LENGTH_SHORT).show();
                }else{
                    inventoryRunning = true;
                    settingBtn.setEnabled(false);
                    exportBtn.setEnabled(false);
                }
            }
        }else if(id == R.id.cleanBtn){
            mCardDeviceList.cardInfos.clear();
            mCardDeviceList.allcount = 0;
            delayHandler.sendEmptyMessage(UPDATE_LIST);
            inventorytimes  = 0;
            delayHandler.sendEmptyMessage(UPDATE_TIME_UI);
        }else if(id == R.id.settingBtn){
            Intent intent = new Intent(this, SettingActivity.class);
            startActivity(intent);
        }else if(id == R.id.exportBtn){
            String filepath = Environment.getExternalStorageDirectory().getPath();
            int status = ExcelUtil.writeExcel(filepath+"/Documents/Export_UHFTags_"+Util.getCurrentTimeFormat()+".xls",mCardDeviceList.cardInfos);
            if(status == 0){
                message = "Export Success!";
            }else{
                message = "Export failed!";
            }
            delayHandler.sendEmptyMessage(SHOW_TOAST);
        }else if(id == R.id.mockDataBtn){
            // 模拟生成 RFID 数据
            generateMockRFIDData();
        }
    }

    @Override
    public void onItemClick(AdapterView<?> adapterView, View view, int i, long l) {
        MainActivity.this.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                TextView itemEpc = view.findViewById(R.id.epcvalue);
                //Toast.makeText(getApplicationContext(),itemEpc.getText().toString(),Toast.LENGTH_SHORT).show();
                DefaultConfigure.currentEpc = itemEpc.getText().toString();
                Intent intent = new Intent(MainActivity.this,ReadWriteLockActivity.class);
                startActivity(intent);
            }
        });
    }
    // 没有设备  模拟数据
    private void generateMockRFIDData(){
        // 模拟 5 个 RFID 标签
        /*String[] mockEPCs = {
                "E280116060000207001234567890",
                "E280116060000207001234567891",
                "E280116060000207001234567892",
                "E280116060000207001234567893",
                "E280116060000207001234567894"
        };

        String[] mockTIDs = {
                "E200001234567890ABCDEF01",
                "E200001234567890ABCDEF02",
                "E200001234567890ABCDEF03",
                "E200001234567890ABCDEF04",
                "E200001234567890ABCDEF05"
        };

        // 随机选择几个标签添加到列表
        Random random = new Random();
        for(int i = 0; i < 3; i++){
            int index = random.nextInt(mockEPCs.length);

            UHFCardInfo item = new UHFCardInfo();
            item.epc = mockEPCs[index];
            item.tid = mockTIDs[index];
            item.rssi = -45 - random.nextInt(20); // 模拟信号强度
            item.Frequency = 920000 + random.nextInt(5000); // 模拟频率

            putCardInfoToList(item);
            mCardDeviceList.allcount++;

            // 播放提示音
            soundPool.play(1, 1, 1, 0, 0, 1);
        }

        // 更新界面
        mCardInfoAdaptar.setCardInfos(mCardDeviceList.cardInfos);
        delayHandler.sendEmptyMessage(UPDATE_LIST);*/
        // 模拟跳转 new 一个意图
        Intent intent = new Intent(MainActivity.this,TagReaderActivity.class);
        startActivity(intent);
    }
}
```

说实话：上面的代码像shit一样，耦合太高。

### 重构后

```java
package com.pda.testuhfapi;

import androidx.appcompat.app.AppCompatActivity;

import android.app.Activity;
import android.content.Intent;
import android.media.AudioManager;
import android.media.SoundPool;
import android.os.Bundle;
import android.os.Environment;
import android.os.Handler;
import android.os.Message;
import android.util.Log;
import android.view.KeyEvent;
import android.view.View;
import android.widget.AdapterView;
import android.widget.Button;
import android.widget.ListView;
import android.widget.TextView;
import android.widget.Toast;

import com.pda.Excel.ExcelUtil;
import com.pda.adapter.CardDeviceList;
import com.pda.adapter.CardInfoAdaptar;
import com.pda.adapter.UHFCardInfo;
import com.pda.uhf.UHFEngine;
import com.pda.uhf.UHFParamsOperator;
import com.pda.uhf.model.InventoryParams;
import com.uhf.api.cls.ReadExceptionListener;
import com.uhf.api.cls.ReadListener;
import com.uhf.api.cls.Reader;

import java.util.ArrayList;
import java.util.List;

/**
 * RFID 标签读取主界面
 * 功能：启动/停止盘点、显示标签列表、导出数据
 */
public class MainActivity extends Activity implements View.OnClickListener, AdapterView.OnItemClickListener {

    // ==================== Handler 消息常量 ====================
    private final static int INIT_SUCCESS = 1;
    private final static int SHOW_TOAST = 2;
    private final static int UPDATE_LIST = 3;
    private final static int BTN_CHANGED = 4;
    private final static int UPDATE_OTHER_UI = 5;
    private final static int UPDATE_TIME_UI = 6;
    private final static int UPDATE_TIME_UI_LOOP = 7;
    private final static int START_FAILED = 8;

    // ==================== UI 组件 ====================
    private ListView cardInfoListView;
    private TextView tagscount;
    private TextView inventorytime;
    private Button startInventoryBtn;
    private Button cleanBtn;
    private Button settingBtn;
    private Button exportBtn;
    private Button mockDataBtn;

    // ==================== 数据相关 ====================
    private CardDeviceList mCardDeviceList;
    private CardInfoAdaptar mCardInfoAdaptar;

    // ==================== 状态标志 ====================
    private boolean iskeydown = false;
    private boolean inventoryRunning = false;
    private long inventorytimes = 0;

    // ==================== 其他 ====================
    private SoundPool soundPool;
    private Handler delayHandler;
    private String message = "";

    // ========================================================================
    // 生命周期方法
    // ========================================================================

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        // 修改权限
        UHFSetting.initRoot(getApplicationContext());

        // 初始化组件
        initViews();

        // 初始化数据和适配器
        initData();
        /*
        * todo 因为获取数据是在子线程中的，但是由于android规则
        *  子线程是不能更新UI的，子线程中更新UI会让其崩溃
        *  此时，就需要消息处理机制：通俗的讲就是子线程处理好数据之后发送消息给主线程，让主线程去更新UI
           也就是通过标签监听器、启动盘点、终止盘点的时候 中发送 sendMessage  然后再initHandler中集中处理
        *  原始提供过来的真的不好评价，混乱的不行
        * */
        initHandler();

        // 初始化音频
        initSound();
    }

    /*
    * todo 这里的上电 下电 以及连接RFID模块  在别的页面也有可能会使用，那么就会让代码重复量很高，此时
    *  可以构建一个基类，将onResume 并连接 RFID模块 和 onPause 等集成到基类中
    *  好处：1、便于维护  2、基类只负责RFID 连接、断开、监听 子类只负责UI展示和数据处理  3、扩展性好 某些子类特殊处理
    *  缺点：1、代码复杂度增加  2、父类修改直接影响到了所有的子类  3、不能再继承别的类  单一继承性
    * */

    @Override
    protected void onResume() {
        super.onResume();

        // 上电并连接 RFID 模块
        connectRFIDModule();
    }

    @Override
    protected void onPause() {
        super.onPause();

        // 断开连接并下电
        disconnectRFIDModule();
    }

    // ========================================================================
    // 初始化方法
    // ========================================================================

    /**
     * 初始化 UI 组件
     */
    private void initViews() {
        cardInfoListView = findViewById(R.id.cardinfo_list);
        tagscount = findViewById(R.id.tagscount);
        inventorytime = findViewById(R.id.inventorytime);

        startInventoryBtn = findViewById(R.id.startInventoryBtn);
        startInventoryBtn.setOnClickListener(this);

        cleanBtn = findViewById(R.id.cleanBtn);
        cleanBtn.setOnClickListener(this);

        settingBtn = findViewById(R.id.settingBtn);
        settingBtn.setOnClickListener(this);

        exportBtn = findViewById(R.id.exportBtn);
        exportBtn.setOnClickListener(this);

        mockDataBtn = findViewById(R.id.mockDataBtn);
        mockDataBtn.setOnClickListener(this);
    }

    /**
     * 初始化数据和适配器
     */
    private void initData() {
        mCardDeviceList = CardDeviceList.getInstance();

        if (mCardInfoAdaptar == null) {
            mCardInfoAdaptar = new CardInfoAdaptar(
                    getApplicationContext(),
                    mCardDeviceList.cardInfos
            );
            cardInfoListView.setAdapter(mCardInfoAdaptar);
            cardInfoListView.setOnItemClickListener(this);
        }
    }

    /**
     * 初始化 Handler 消息处理
     */
    private void initHandler() {
        delayHandler = new Handler() {
            @Override
            public void handleMessage(Message msg) {
                switch (msg.what) {
                    case INIT_SUCCESS:
                        // 初始化成功
                        break;

                    case SHOW_TOAST:
                        Toast.makeText(
                                getApplicationContext(),
                                message,
                                Toast.LENGTH_SHORT
                        ).show();
                        break;

                    case UPDATE_LIST:
                        // 更新列表和统计信息
                        mCardInfoAdaptar.notifyDataSetChanged();
                        tagscount.setText(
                                "Tags Count:" + mCardDeviceList.cardInfos.size() +
                                        "  Tags Times:" + mCardDeviceList.allcount
                        );
                        break;

                    case BTN_CHANGED:
                        // 切换按钮文字
                        startInventoryBtn.setText(
                                inventoryRunning ?
                                        R.string.stop_inventory :
                                        R.string.start_inventory
                        );
                        break;

                    case UPDATE_OTHER_UI:
                        // 其他 UI 更新
                        break;

                    case UPDATE_TIME_UI:
                        // 更新时间显示
                        inventorytime.setText(Util.getTimeMode(inventorytimes));
                        break;

                    case UPDATE_TIME_UI_LOOP:
                        // 循环更新时间
                        inventorytimes++;
                        delayHandler.sendEmptyMessage(UPDATE_TIME_UI);
                        delayHandler.sendEmptyMessageDelayed(UPDATE_TIME_UI_LOOP, 1000);
                        break;
                }
            }
        };
    }

    /**
     * 初始化音效
     */
    private void initSound() {
        soundPool = new SoundPool(10, AudioManager.STREAM_SYSTEM, 5);
        soundPool.load(this, R.raw.beep333, 1);
    }

    // ========================================================================
    // RFID 模块连接管理
    // ========================================================================

    /**
     * 连接 RFID 模块
     */
    private void connectRFIDModule() {
        // 1. 上电
        UHFEngine.getEngine().powerOn();

        // 2. 连接串口设备
        Reader.READER_ERR er = UHFEngine.getEngine()
                .connectModule(DefaultConfigure.UART_DEV_PATH, 1);

        // 3. 初始化参数配置
        if (er == Reader.READER_ERR.MT_OK_ERR) {
            DefaultConfigure.defaultInitModule();

            runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    // Toast.makeText(getApplicationContext(), "连接成功", Toast.LENGTH_SHORT).show();
                }
            });
        } else {
            runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    // Toast.makeText(getApplicationContext(), "连接失败", Toast.LENGTH_SHORT).show();
                }
            });
        }
    }

    /**
     * 断开 RFID 模块连接
     */
    private void disconnectRFIDModule() {
        // 1. 断开连接
        UHFEngine.getEngine().disconnectModule();

        // 2. 下电
        UHFEngine.getEngine().powerOff();
    }

    // ========================================================================
    // RFID 盘点控制
    // ========================================================================

    /**
     * 启动盘点
     */
    private void startInventory() {
        // 1. 获取盘点参数
        InventoryParams params = InventoryModeParams.getParams(
                DefaultConfigure.inventorymode,
                DefaultConfigure.inventoryParams,
                DefaultConfigure.inventorywithtid
        );

        // 2. 启动盘点引擎
        Reader.READER_ERR er = UHFEngine.getEngine()
                .startInventory(params, readListener, readExceptionListener);

        // 3. 处理启动结果
        if (er == Reader.READER_ERR.MT_OK_ERR) {
            inventoryRunning = true;
            inventorytimes = 0;

            // 更新 UI
            delayHandler.sendEmptyMessage(BTN_CHANGED);
            delayHandler.sendEmptyMessage(UPDATE_TIME_UI);
            delayHandler.sendEmptyMessageDelayed(UPDATE_TIME_UI_LOOP, 1000);

            // 禁用设置和导出按钮
            settingBtn.setEnabled(false);
            exportBtn.setEnabled(false);
        } else {
            // Toast.makeText(getApplicationContext(), "启动盘点失败！", Toast.LENGTH_SHORT).show();
        }
    }

    /**
     * 停止盘点
     */
    private void stopInventory() {
        // 1. 停止盘点引擎
        UHFEngine.getEngine().stopInventory();

        // 2. 更新状态
        inventoryRunning = false;

        // 3. 停止计时器
        delayHandler.removeMessages(UPDATE_TIME_UI_LOOP);

        // 4. 更新 UI
        delayHandler.sendEmptyMessage(BTN_CHANGED);

        // 5. 启用设置和导出按钮
        settingBtn.setEnabled(true);
        exportBtn.setEnabled(true);
    }

    // ========================================================================
    // RFID 数据回调监听
    // ========================================================================

    /**
     * 标签读取回调监听器
     */
    private ReadListener readListener = new ReadListener() {
        @Override
        public void tagRead(List<Reader.TagInfo> list) {
            if (list == null) {
                return;
            }

            // 处理每个读取到的标签
            for (int i = 0; i < list.size(); i++) {
                // 1. 获取标签信息
                Reader.TagInfo tagInfo = list.get(i);
                String epcId = Reader.bytes_Hexstr(tagInfo.EpcId);
                String tidId = Reader.bytes_Hexstr(tagInfo.EmbededData);

                // 2. 创建数据对象
                UHFCardInfo item = new UHFCardInfo();
                item.epc = epcId;
                item.tid = tidId;
                item.rssi = tagInfo.RSSI;
                item.Frequency = tagInfo.Frequency;

                // 3. 记录日志
                Log.e("RFID_TAG", epcId + "," + tidId + "," + tagInfo.Frequency);

                // 4. 添加到列表（自动去重）
                putCardInfoToList(item);
                mCardDeviceList.allcount++;
            }

            // 5. 更新适配器数据
            mCardInfoAdaptar.setCardInfos(mCardDeviceList.cardInfos);

            // 6. 通知 UI 更新
            delayHandler.sendEmptyMessage(UPDATE_LIST);

            // 7. 播放提示音
            soundPool.play(1, 1, 1, 0, 0, 1);
        }
    };

    /**
     * 标签读取异常监听器
     */
    private ReadExceptionListener readExceptionListener = new ReadExceptionListener() {
        @Override
        public void tagReadException(final Reader.READER_ERR er) {
            Log.e("RFID_ERROR", "读取异常: " + er.toString());
        }
    };

    // ========================================================================
    // 数据处理方法
    // ========================================================================

    /**
     * 将标签信息添加到列表（自动去重）
     * @param newCard 新读取的标签信息
     */
    private void putCardInfoToList(UHFCardInfo newCard) {
        // 1. 查找标签是否已存在
        int pos = getCardInfoIndex(newCard);

        if (pos != -1) {
            // 标签已存在，更新信息
            UHFCardInfo existingCard = mCardDeviceList.cardInfos.get(pos);

            // 增加读取计数
            existingCard.count++;

            // 更新 TID（如果之前为空）
            if (existingCard.tid.equals("")) {
                existingCard.tid = newCard.tid;
            } else if (!newCard.tid.equals("")) {
                existingCard.tid = newCard.tid;
            }

            // 更新信号强度和频率
            existingCard.Frequency = newCard.Frequency;
            existingCard.rssi = newCard.rssi;
        } else {
            // 新标签，添加到列表
            newCard.count = 1;
            mCardDeviceList.cardInfos.add(newCard);
        }
    }

    /**
     * 查找标签在列表中的索引
     * @param targetCard 目标标签
     * @return 索引位置，-1 表示未找到
     */
    private int getCardInfoIndex(UHFCardInfo targetCard) {
        int size = mCardDeviceList.cardInfos.size();

        for (int index = 0; index < size; index++) {
            UHFCardInfo existingCard = mCardDeviceList.cardInfos.get(index);

            // 根据 EPC 判断是否为同一标签
            if (targetCard.epc.equals(existingCard.epc)) {
                return index;
            }
        }

        return -1;
    }

    /**
     * 清空标签列表
     */
    private void cleanCardInfoToList() {
        mCardDeviceList.cardInfos.clear();
        mCardDeviceList.allcount = 0;
        inventorytimes = 0;

        delayHandler.sendEmptyMessage(UPDATE_LIST);
        delayHandler.sendEmptyMessage(UPDATE_TIME_UI);
    }

    // ========================================================================
    // 按键事件处理
    // ========================================================================

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        // 检测 F1 键或设备的扫描键(292)
        if (!iskeydown && (keyCode == 292 || keyCode == KeyEvent.KEYCODE_F1)) {
            iskeydown = true;

            if (inventoryRunning) {
                // 停止盘点
                stopInventory();
            } else {
                // 开始盘点
                startInventory();
            }
        }

        return super.onKeyDown(keyCode, event);
    }

    @Override
    public boolean onKeyUp(int keyCode, KeyEvent event) {
        // 按键释放时重置标志
        if (iskeydown && (keyCode == 292 || keyCode == KeyEvent.KEYCODE_F1)) {
            iskeydown = false;
        }

        return super.onKeyUp(keyCode, event);
    }

    // ========================================================================
    // UI 事件处理
    // ========================================================================

    @Override
    public void onClick(View view) {
        int id = view.getId();

        if (id == R.id.startInventoryBtn) {
            handleStartInventoryClick();
        } else if (id == R.id.cleanBtn) {
            handleCleanClick();
        } else if (id == R.id.settingBtn) {
            handleSettingClick();
        } else if (id == R.id.exportBtn) {
            handleExportClick();
        } else if (id == R.id.mockDataBtn) {
            handleMockDataClick();
        }
    }

    /**
     * 处理开始/停止盘点按钮点击
     */
    private void handleStartInventoryClick() {
        if (inventoryRunning) {
            stopInventory();
        } else {
            startInventory();
        }
    }

    /**
     * 处理清空按钮点击
     */
    private void handleCleanClick() {
        cleanCardInfoToList();
    }

    /**
     * 处理设置按钮点击
     */
    private void handleSettingClick() {
        Intent intent = new Intent(this, SettingActivity.class);
        startActivity(intent);
    }

    /**
     * 处理导出按钮点击
     */
    private void handleExportClick() {
        String filepath = Environment.getExternalStorageDirectory().getPath();
        String filename = filepath + "/Documents/Export_UHFTags_" +
                Util.getCurrentTimeFormat() + ".xls";

        int status = ExcelUtil.writeExcel(filename, mCardDeviceList.cardInfos);

        if (status == 0) {
            message = "Export Success!";
        } else {
            message = "Export failed!";
        }

        delayHandler.sendEmptyMessage(SHOW_TOAST);
    }

    /**
     * 处理模拟数据按钮点击
     */
    private void handleMockDataClick() {
        // 跳转到标签读取测试页面
        Intent intent = new Intent(MainActivity.this, TagReaderActivity.class);
        startActivity(intent);
    }

    @Override
    public void onItemClick(AdapterView<?> adapterView, View view, int i, long l) {
        runOnUiThread(new Runnable() {
            @Override
            public void run() {
                // 获取点击的标签 EPC
                TextView itemEpc = view.findViewById(R.id.epcvalue);
                String epc = itemEpc.getText().toString();

                // 保存到全局配置
                DefaultConfigure.currentEpc = epc;

                // 跳转到读写锁定页面
                Intent intent = new Intent(MainActivity.this, ReadWriteLockActivity.class);
                startActivity(intent);
            }
        });
    }
}
```

#### 重构后

1. 将原本的配置在上电并连接RFID标签中就准备好硬件 **08中的核心接口基本也是在这里面使用到** onResume

   这个是类实现了某方法，重写其中的方法，因此就不能再封装了  只能单独拎出来 肯定还能封的，但是这里就没必要了，如果别的页面也要用到的上电下电的话，重复代码太多，那就新建一个类，类中继承Acticity,然后再实现View.OnclickLister, AdapterView.OnItemClickLister  在当前类中继承这个类

2. 初始化组件 `initViews()`  也就是拿到.xml中的各类组件 通过findViewById中拿到对应id的组件，有哪些组件一目了然，为后续调用更加方便了

3. 初始化数据和适配器  `initData()`

4. 初始化音频 `initSound()` 如果这里需要根据不同类型的组件走不同的声音，可以考虑添加个参数  到时候调用 即可

### 二次重构(未采取，有这个思想即可)

> todo 这里的上电 下电 以及连接RFID模块  在别的页面也有可能会使用，那么就会让代码重复量很高，此时
>
> 可以构建一个基类，将onResume 并连接 RFID模块 和 onPause 等集成到基类中
>
> *  好处：1、便于维护  **2、基类只负责RFID 连接、断开、监听 子类只负责UI展示和数据处理**  3、扩展性好 某些子类特殊处理
> *  缺点：1、代码复杂度增加  2、父类修改直接影响到了所有的子类  3、不能再继承别的类  单一继承性

#### 基类参考

```java
package com.pda.testuhfapi.base;

import android.app.Activity;
import android.media.AudioManager;
import android.media.SoundPool;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.util.Log;
import android.widget.Toast;

import com.pda.testuhfapi.DefaultConfigure;
import com.pda.testuhfapi.R;
import com.pda.uhf.UHFEngine;
import com.pda.uhf.UHFSetting;
import com.pda.uhf.model.InventoryParams;
import com.uhf.api.cls.ReadExceptionListener;
import com.uhf.api.cls.ReadListener;
import com.uhf.api.cls.Reader;

import java.util.List;

/**
 * RFID 功能基类
 * 封装了 RFID 模块的连接、断开、数据监听等通用功能
 *
 * 使用方式：
 * public class YourActivity extends BaseRFIDActivity {
 *     @Override
 *     protected void onRFIDDataReceived(List<Reader.TagInfo> tagList) {
 *         // 处理接收到的标签数据
 *     }
 * }
 */
public abstract class BaseRFIDActivity extends Activity {

    // ==================== 常量定义 ====================
    protected static final String TAG = "BaseRFIDActivity";

    // Handler 消息类型
    protected static final int MSG_SHOW_TOAST = 1000;
    protected static final int MSG_UPDATE_UI = 1001;
    protected static final int MSG_RFID_CONNECTED = 1002;
    protected static final int MSG_RFID_DISCONNECTED = 1003;

    // ==================== 成员变量 ====================
    protected Handler baseHandler;
    protected SoundPool soundPool;
    protected int beepSoundId;
    protected boolean isRFIDConnected = false;
    protected String toastMessage = "";

    // ==================== 生命周期方法 ====================

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // 初始化基础组件
        initBaseComponents();
    }

    @Override
    protected void onResume() {
        super.onResume();

        // 连接 RFID 模块
        connectRFIDModule();
    }

    @Override
    protected void onPause() {
        super.onPause();

        // 断开 RFID 模块
        disconnectRFIDModule();
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();

        // 释放资源
        releaseResources();
    }

    // ==================== 初始化方法 ====================

    /**
     * 初始化基础组件
     */
    private void initBaseComponents() {
        // 修改权限
        UHFSetting.initRoot(getApplicationContext());

        // 初始化 Handler
        initBaseHandler();

        // 初始化音效
        initBaseSound();
    }

    /**
     * 初始化 Handler
     */
    private void initBaseHandler() {
        baseHandler = new Handler() {
            @Override
            public void handleMessage(Message msg) {
                switch (msg.what) {
                    case MSG_SHOW_TOAST:
                        Toast.makeText(
                                getApplicationContext(),
                                toastMessage,
                                Toast.LENGTH_SHORT
                        ).show();
                        break;

                    case MSG_RFID_CONNECTED:
                        onRFIDConnected();
                        break;

                    case MSG_RFID_DISCONNECTED:
                        onRFIDDisconnected();
                        break;

                    case MSG_UPDATE_UI:
                        onUpdateUI();
                        break;

                    default:
                        // 交给子类处理
                        handleChildMessage(msg);
                        break;
                }
            }
        };
    }

    /**
     * 初始化音效
     */
    private void initBaseSound() {
        soundPool = new SoundPool(10, AudioManager.STREAM_SYSTEM, 5);
        beepSoundId = soundPool.load(this, R.raw.beep333, 1);
    }

    // ==================== RFID 模块连接管理 ====================

    /**
     * 连接 RFID 模块
     */
    protected void connectRFIDModule() {
        Log.d(TAG, "开始连接 RFID 模块...");

        // 1. 上电
        UHFEngine.getEngine().powerOn();

        // 2. 连接串口设备
        Reader.READER_ERR er = UHFEngine.getEngine()
                .connectModule(DefaultConfigure.UART_DEV_PATH, 1);

        // 3. 处理连接结果
        if (er == Reader.READER_ERR.MT_OK_ERR) {
            // 初始化参数配置
            DefaultConfigure.defaultInitModule();

            isRFIDConnected = true;
            Log.d(TAG, "RFID 模块连接成功");

            // 通知子类
            baseHandler.sendEmptyMessage(MSG_RFID_CONNECTED);
        } else {
            isRFIDConnected = false;
            Log.e(TAG, "RFID 模块连接失败: " + er.toString());

            toastMessage = "RFID 连接失败";
            baseHandler.sendEmptyMessage(MSG_SHOW_TOAST);
        }
    }

    /**
     * 断开 RFID 模块连接
     */
    protected void disconnectRFIDModule() {
        Log.d(TAG, "断开 RFID 模块...");

        // 1. 断开连接
        UHFEngine.getEngine().disconnectModule();

        // 2. 下电
        UHFEngine.getEngine().powerOff();

        isRFIDConnected = false;

        // 通知子类
        baseHandler.sendEmptyMessage(MSG_RFID_DISCONNECTED);
    }

    /**
     * 检查 RFID 是否已连接
     */
    protected boolean isRFIDConnected() {
        return isRFIDConnected;
    }

    // ==================== RFID 数据监听器 ====================

    /**
     * 标签读取监听器（统一封装）
     */
    protected ReadListener baseReadListener = new ReadListener() {
        @Override
        public void tagRead(List<Reader.TagInfo> list) {
            if (list == null || list.isEmpty()) {
                return;
            }

            // 播放提示音
            playBeep();

            // 交给子类处理数据
            onRFIDDataReceived(list);

            // 通知 UI 更新
            baseHandler.sendEmptyMessage(MSG_UPDATE_UI);
        }
    };

    /**
     * 标签读取异常监听器（统一封装）
     */
    protected ReadExceptionListener baseReadExceptionListener = new ReadExceptionListener() {
        @Override
        public void tagReadException(final Reader.READER_ERR er) {
            Log.e(TAG, "RFID 读取异常: " + er.toString());

            // 交给子类处理
            onRFIDException(er);
        }
    };

    // ==================== 工具方法 ====================

    /**
     * 播放提示音
     */
    protected void playBeep() {
        if (soundPool != null && beepSoundId != 0) {
            soundPool.play(beepSoundId, 1, 1, 0, 0, 1);
        }
    }

    /**
     * 显示 Toast 提示
     */
    protected void showToast(String message) {
        toastMessage = message;
        baseHandler.sendEmptyMessage(MSG_SHOW_TOAST);
    }

    /**
     * 启动盘点（通用方法）
     */
    protected Reader.READER_ERR startInventory(InventoryParams params) {
        if (!isRFIDConnected) {
            Log.e(TAG, "RFID 未连接，无法启动盘点");
            return Reader.READER_ERR.MT_CMD_FAILED_ERR;
        }

        return UHFEngine.getEngine()
                .startInventory(params, baseReadListener, baseReadExceptionListener);
    }

    /**
     * 停止盘点（通用方法）
     */
    protected void stopInventory() {
        UHFEngine.getEngine().stopInventory();
    }

    /**
     * 释放资源
     */
    private void releaseResources() {
        if (soundPool != null) {
            soundPool.release();
            soundPool = null;
        }

        if (baseHandler != null) {
            baseHandler.removeCallbacksAndMessages(null);
        }
    }

    // ==================== 抽象方法（子类必须实现）====================

    /**
     * 接收到 RFID 数据时的回调
     * @param tagList 标签信息列表
     */
    protected abstract void onRFIDDataReceived(List<Reader.TagInfo> tagList);

    // ==================== 可选重写方法（子类可选实现）====================

    /**
     * RFID 连接成功回调
     */
    protected void onRFIDConnected() {
        // 子类可选重写
        Log.d(TAG, "onRFIDConnected - 可在子类中重写");
    }

    /**
     * RFID 断开连接回调
     */
    protected void onRFIDDisconnected() {
        // 子类可选重写
        Log.d(TAG, "onRFIDDisconnected - 可在子类中重写");
    }

    /**
     * RFID 异常回调
     */
    protected void onRFIDException(Reader.READER_ERR error) {
        // 子类可选重写
        Log.e(TAG, "onRFIDException - 可在子类中重写: " + error.toString());
    }

    /**
     * UI 更新回调
     */
    protected void onUpdateUI() {
        // 子类可选重写
    }

    /**
     * 处理子类自定义消息
     */
    protected void handleChildMessage(Message msg) {
        // 子类可选重写
    }

    /**
     * 获取 Handler（供子类使用）
     */
    protected Handler getBaseHandler() {
        return baseHandler;
    }
}
```

------

## 🏗️ 整体架构

### 三层架构设计

```
┌─────────────────────────────────────┐
│         UI 层（用户界面）              │
│  - 按钮控制                           │
│  - 列表展示                           │
│  - 状态显示                           │
├─────────────────────────────────────┤
│      业务逻辑层（核心处理）            │
│  - Handler 消息机制                  │
│  - 数据去重与统计                     │
│  - 状态管理                           │
├─────────────────────────────────────┤
│     硬件交互层（RFID 模块）           │
│  - UHFEngine: 引擎管理               │
│  - UHFParamsOperator: 参数配置      │
│  - ReadListener: 异步回调            │
└─────────────────────────────────────┘
```

### 核心组件说明

| 组件         | 职责           | 关键类/方法                      |
| ------------ | -------------- | -------------------------------- |
| **UI 组件**  | 界面展示与交互 | `ListView`, `Button`, `TextView` |
| **数据管理** | 标签信息存储   | `CardDeviceList`, `UHFCardInfo`  |
| **硬件引擎** | RFID 模块控制  | `UHFEngine.getEngine()`          |
| **消息处理** | 线程间通信     | `Handler.handleMessage()`        |
| **回调监听** | 异步数据接收   | `ReadListener.tagRead()`         |

------

## ⚡ 生命周期管理

### 为什么要在生命周期方法中管理硬件？

**核心原理：** Android 应用的界面有可见/不可见状态，硬件资源应该随界面状态动态管理

### onResume() - 激活硬件

```java
@Override
protected void onResume() {
    // 1. 上电
    UHFEngine.getEngine().powerOn();
    
    // 2. 连接串口设备
    Reader.READER_ERR er = UHFEngine.getEngine()
        .connectModule(DefaultConfigure.UART_DEV_PATH, 1);
    
    // 3. 初始化参数
    if(er == Reader.READER_ERR.MT_OK_ERR){
        DefaultConfigure.defaultInitModule();
    }
    
    super.onResume();
}
```

**执行时机：**

- 应用启动时
- 从后台返回前台时
- 从其他 Activity 返回时

**为什么在这里？**

- ✅ 确保用户使用时硬件已就绪
- ✅ 从后台返回时自动重新连接
- ✅ 避免在 onCreate 中初始化（可能过早）

### onPause() - 释放硬件

```java
@Override
protected void onPause() {
    // 1. 断开连接
    UHFEngine.getEngine().disconnectModule();
    
    // 2. 下电
    UHFEngine.getEngine().powerOff();
    
    super.onPause();
}
```

**执行时机：**

- 切换到其他应用时、锁屏时、跳转到其他 Activity 时

**为什么在这里？**

- ✅ 节省电量、✅ 释放串口资源、✅ 避免其他应用无法使用硬件

### 生命周期流程图

```
用户打开应用
    ↓
onCreate() - 初始化 UI
    ↓
onResume() - 上电、连接硬件 ✅
    ↓
用户正常使用
    ↓
按 Home 键 / 切换应用
    ↓
onPause() - 断开、下电 ✅
    ↓
用户返回应用
    ↓
onResume() - 重新连接 ✅
```

------

## 🔄 Handler 消息机制

### 为什么需要 Handler？

#### ❌ 问题：不能在子线程更新 UI

```java
// ❌ 错误：会导致应用崩溃
// RFID 读取在子线程中
ReadListener RL = new ReadListener() {
    @Override
    public void tagRead(List<Reader.TagInfo> list) {
        // ❌ 这里是子线程，不能直接操作 UI
        textView.setText("更新文本");  // 崩溃！
    }
};
```

**Android 规则：** 只有主线程（UI 线程）才能更新 UI 组件

#### ✅ 解决方案：Handler 消息队列

```java
// ✅ 正确：通过 Handler 发送消息
ReadListener RL = new ReadListener() {
    @Override
    public void tagRead(List<Reader.TagInfo> list) {
        // 1. 子线程处理数据
        processData(list);
        
        // 2. 发送消息到主线程
        delayHandler.sendEmptyMessage(UPDATE_LIST);
    }
};

// 3. 主线程接收并处理
Handler delayHandler = new Handler() {
    @Override
    public void handleMessage(Message msg) {
        if(msg.what == UPDATE_LIST) {
            // 现在可以安全地更新 UI 了
            textView.setText("更新成功");
        }
    }
};
```

### 消息类型定义

```java
// 消息常量定义
private final static int INIT_SUCCESS = 1;       // 初始化成功
private final static int SHOW_TOAST = 2;         // 显示提示
private final static int UPDATE_LIST = 3;        // 更新列表
private final static int BTN_CHANGED = 4;        // 按钮状态改变
private final static int UPDATE_OTHER_UI = 5;    // 更新其他UI
private final static int UPDATE_TIME_UI = 6;     // 更新时间显示
private final static int UPDATE_TIME_UI_LOOP = 7;// 循环更新时间
private final static int START_FAILED = 8;       // 启动失败
```

### 消息处理流程

```java
Handler delayHandler = new Handler() {
    @Override
    public void handleMessage(Message msg) {
        switch (msg.what) {
            case UPDATE_LIST:
                // 更新列表数据
                mCardInfoAdaptar.notifyDataSetChanged();
                // 更新统计信息
                tagscount.setText("Tags Count:" + 
                    mCardDeviceList.cardInfos.size() + 
                    "  Tags Times:" + 
                    mCardDeviceList.allcount);
                break;
                
            case BTN_CHANGED:
                // 切换按钮文字
                startInventoryBtn.setText(
                    inventoryRunning ? 
                    R.string.stop_inventory : 
                    R.string.start_inventory
                );
                break;
                
            case UPDATE_TIME_UI:
                // 更新运行时间
                inventorytime.setText(
                    Util.getTimeMode(inventorytimes)
                );
                break;
                
            case UPDATE_TIME_UI_LOOP:
                // 递增时间并循环更新
                inventorytimes++;
                delayHandler.sendEmptyMessage(UPDATE_TIME_UI);
                delayHandler.sendEmptyMessageDelayed(UPDATE_TIME_UI_LOOP, 1000);
                break;
                
            case SHOW_TOAST:
                // 显示提示消息
                Toast.makeText(
                    getApplicationContext(),
                    message,
                    Toast.LENGTH_SHORT
                ).show();
                break;
        }
    }
};
```

### Handler 工作原理图

```
子线程（RFID读取）          主线程（UI线程）
      ↓                         ↓
  读取到标签数据            等待消息
      ↓                         ↓
sendEmptyMessage(UPDATE_LIST)   
      ↓                         ↓
   消息队列 ----------------→ handleMessage()
                                ↓
                          switch(msg.what)
                                ↓
                          更新UI界面 ✅
```

### 延迟消息的使用

```java
// 立即发送消息
delayHandler.sendEmptyMessage(UPDATE_LIST);

// 延迟 1000ms 发送消息
delayHandler.sendEmptyMessageDelayed(UPDATE_TIME_UI_LOOP, 1000);

// 移除未处理的消息
delayHandler.removeMessages(UPDATE_TIME_UI_LOOP);
```

**实际应用：** 实现每秒更新的计时器

```java
// 启动计时器
inventorytimes = 0;
delayHandler.sendEmptyMessage(UPDATE_TIME_UI);              // 立即更新一次
delayHandler.sendEmptyMessageDelayed(UPDATE_TIME_UI_LOOP, 1000);  // 1秒后循环

// 停止计时器
delayHandler.removeMessages(UPDATE_TIME_UI_LOOP);
```

------

## 📡 盘点流程详解

### 完整数据流转

```
┌─────────────────────────────────────────────────────────┐
│ 1. 用户触发                                              │
│    - 按下 F1 键 或 扫描键(292)                           │
│    - 点击"开始盘点"按钮                                   │
└────────────────┬────────────────────────────────────────┘
                 ↓
┌─────────────────────────────────────────────────────────┐
│ 2. 启动盘点引擎                                          │
│    InventoryParams params = getParams(...);              │
│    UHFEngine.getEngine().startInventory(params, RL, REL);│
└────────────────┬────────────────────────────────────────┘
                 ↓
┌─────────────────────────────────────────────────────────┐
│ 3. RFID 模块扫描（子线程，持续进行）                      │
│    硬件发射射频信号 → 标签响应 → 接收数据                 │
└────────────────┬────────────────────────────────────────┘
                 ↓
┌─────────────────────────────────────────────────────────┐
│ 4. 回调函数接收数据                                       │
│    ReadListener.tagRead(List<TagInfo> list)              │
│    - 解析 EPC、TID、RSSI、Frequency                      │
└────────────────┬────────────────────────────────────────┘
                 ↓
┌─────────────────────────────────────────────────────────┐
│ 5. 数据处理与去重                                        │
│    putCardInfoToList(item)                               │
│    - 检查标签是否已存在（根据 EPC）                       │
│    - 存在：增加计数，更新 RSSI/频率                       │
│    - 不存在：添加到列表                                   │
└────────────────┬────────────────────────────────────────┘
                 ↓
┌─────────────────────────────────────────────────────────┐
│ 6. 发送 UI 更新消息                                      │
│    delayHandler.sendEmptyMessage(UPDATE_LIST)            │
└────────────────┬────────────────────────────────────────┘
                 ↓
┌─────────────────────────────────────────────────────────┐
│ 7. 主线程更新界面                                        │
│    handleMessage() → notifyDataSetChanged()              │
│    - 刷新列表显示                                        │
│    - 更新标签数量统计                                    │
└────────────────┬────────────────────────────────────────┘
                 ↓
┌─────────────────────────────────────────────────────────┐
│ 8. 提示反馈                                              │
│    soundPool.play(...) - 播放提示音                      │
└─────────────────────────────────────────────────────────┘
```

### 关键代码详解

#### 1. 启动盘点

```java
// 按键触发或按钮点击
public boolean onKeyDown(int keyCode, KeyEvent event) {
    if(!iskeydown && (keyCode == 292 || keyCode == KeyEvent.KEYCODE_F1)) {
        if(inventoryRunning) {
            // 停止盘点
            stopInventory();
        } else {
            // 开始盘点
            startInventory();
        }
    }
    return super.onKeyDown(keyCode, event);
}

private void startInventory() {
    // 1. 获取盘点参数
    InventoryParams params = InventoryModeParams.getParams(
        DefaultConfigure.inventorymode,      // 盘点模式
        DefaultConfigure.inventoryParams,    // 参数配置
        DefaultConfigure.inventorywithtid    // 是否读取TID
    );
    
    // 2. 启动盘点
    Reader.READER_ERR er = UHFEngine.getEngine()
        .startInventory(params, RL, REL);
    
    // 3. 更新状态
    if (er == Reader.READER_ERR.MT_OK_ERR) {
        inventoryRunning = true;
        inventorytimes = 0;
        
        // 更新按钮状态
        delayHandler.sendEmptyMessage(BTN_CHANGED);
        
        // 启动计时器
        delayHandler.sendEmptyMessage(UPDATE_TIME_UI);
        delayHandler.sendEmptyMessageDelayed(UPDATE_TIME_UI_LOOP, 1000);
        
        // 禁用设置和导出按钮
        settingBtn.setEnabled(false);
        exportBtn.setEnabled(false);
    }
}
```

#### 2. 异步回调接收数据

```java
ReadListener RL = new ReadListener() {
    @Override
    public void tagRead(List<Reader.TagInfo> list) {
        if (list == null) return;
        
        for (int i = 0; i < list.size(); i++) {
            // 1. 获取标签信息
            Reader.TagInfo tagInfo = list.get(i);
            String epcId = Reader.bytes_Hexstr(tagInfo.EpcId);
            String TidId = Reader.bytes_Hexstr(tagInfo.EmbededData);
            
            // 2. 创建数据对象
            UHFCardInfo item = new UHFCardInfo();
            item.epc = epcId;           // 标签唯一标识
            item.tid = TidId;           // 标签芯片ID
            item.rssi = tagInfo.RSSI;   // 信号强度
            item.Frequency = tagInfo.Frequency;  // 读取频率
            
            // 3. 添加到列表（去重处理）
            putCardInfoToList(item);
            mCardDeviceList.allcount++;
            
            // 4. 记录日志
            Log.e("####", epcId + "," + TidId + "," + tagInfo.Frequency);
        }
        
        // 5. 更新适配器数据
        mCardInfoAdaptar.setCardInfos(mCardDeviceList.cardInfos);
        
        // 6. 通知UI更新
        delayHandler.sendEmptyMessage(UPDATE_LIST);
        
        // 7. 播放提示音
        soundPool.play(1, 1, 1, 0, 0, 1);
    }
};
```

#### 3. 停止盘点

```java
private void stopInventory() {
    // 1. 停止引擎
    UHFEngine.getEngine().stopInventory();
    
    // 2. 更新状态
    inventoryRunning = false;
    
    // 3. 停止计时器
    delayHandler.removeMessages(UPDATE_TIME_UI_LOOP);
    
    // 4. 更新按钮状态
    delayHandler.sendEmptyMessage(BTN_CHANGED);
    
    // 5. 启用设置和导出按钮
    settingBtn.setEnabled(true);
    exportBtn.setEnabled(true);
}
```

------

## ⚙️ 硬件参数配置

### 为什么需要配置这些参数？

就像调节收音机一样，RFID 读写器也需要调整各种参数才能获得最佳性能：

| 参数              | 类比         | 作用         |
| ----------------- | ------------ | ------------ |
| **功率 (Power)**  | 收音机音量   | 决定读取距离 |
| **频段 (Region)** | 电台频道     | 符合当地法规 |
| **Session**       | 防重播机制   | 避免重复读取 |
| **Target**        | 频道切换策略 | 标签选择方式 |

### 配置代码详解

```java
private void initModule() {
    // ========== 1. 配置天线功率 ==========
    Reader.AntPowerConf apcf = new Reader.AntPowerConf();
    apcf.antcnt = 1;  // PDA 只有一个天线
    
    Reader.AntPower jaap = new Reader.AntPower();
    jaap.readPower = 3300;   // 读功率 33dBm（最大）
    jaap.writePower = 3300;  // 写功率 33dBm（最大）
    jaap.antid = 1;          // 天线编号
    
    apcf.Powers[0] = jaap;
    Reader.READER_ERR er = UHFParamsOperator.getInstance()
        .setAntPowerConf(apcf);
    
    // ========== 2. 配置 Session ==========
    // Session 0-3 可选
    // SESSION0: 速度快，适合少量标签
    // SESSION1: 平衡，适合多标签场景 ✅
    // SESSION2/3: 适合移动场景
    er = UHFParamsOperator.getInstance()
        .setGen2Session(InventoryModeParams.SESSION.SESSION1);
    
    // ========== 3. 配置 Target ==========
    // A_2_B: 从A状态切换到B状态
    // B_2_A: 从B状态切换到A状态
    er = UHFParamsOperator.getInstance()
        .setGen2Target(InventoryModeParams.TARGET.A_2_B);
    
    // ========== 4. 配置区域（频段）==========
    // RG_NA: 北美 (902-928 MHz)
    // RG_PRC: 中国 (920-925 MHz) ✅
    // RG_EU: 欧洲 (865-868 MHz)
    // RG_OPEN: 全频段
    er = UHFParamsOperator.getInstance()
        .setRegionConf(Reader.Region_Conf.RG_PRC);
}
```

### 参数详解

#### 1. 功率 (Power)

```java
jaap.readPower = 3300;  // 33dBm = 2W
```

**功率范围：** 通常 10dBm - 33dBm

| 功率      | 读取距离 | 功耗 | 适用场景           |
| --------- | -------- | ---- | ------------------ |
| 10-15 dBm | 0.5-1m   | 低   | 近距离、精确读取   |
| 20-25 dBm | 2-4m     | 中   | 一般应用           |
| 30-33 dBm | 5-10m    | 高   | 远距离、仓库盘点 ✅ |

**注意事项：**

- 功率越大，读取距离越远
- 功率越大，耗电越多，发热越严重
- 功率过大可能导致标签碰撞（多个标签同时响应）

#### 2. Session

```java
setGen2Session(SESSION1);
```

**Session 机制：** 标签内部有一个"标志位"，记录自己是否被读取过

```
SESSION0 - 标志位保持时间: 50ms
    特点: 速度最快，但容易重复读取
    适用: 标签数量少（<10个）
    
SESSION1 - 标志位保持时间: 2秒 ✅
    特点: 平衡速度和重复控制
    适用: 多标签场景（10-100个）
    
SESSION2 - 标志位保持时间: 2秒
    特点: 持久化标志
    适用: 标签移动场景
    
SESSION3 - 标志位保持时间: 无限
    特点: 需要手动重置
    适用: 长期跟踪场景
```

**工作原理图：**

```
时间轴: 0s -------- 1s -------- 2s -------- 3s

SESSION0:
标签A被读取 → [50ms内不响应] → 继续响应
              ↑
              标志位保持时间很短

SESSION1:
标签A被读取 → [2秒内不响应] → 继续响应
              ↑
              标志位保持2秒
```

#### 3. Target (A/B 状态)

```java
setGen2Target(A_2_B);
```

**Target 机制：** 每个标签有 A 和 B 两个状态

```
A_2_B 模式:
┌─────────┐  读取  ┌─────────┐
│ A 状态  │ ────→ │ B 状态  │
└─────────┘        └─────────┘
   ↑                    │
   └────────────────────┘
        超时后自动恢复

B_2_A 模式:
┌─────────┐  读取  ┌─────────┐
│ B 状态  │ ────→ │ A 状态  │
└─────────┘        └─────────┘
```

**实际应用：**

```
第一轮盘点: 所有标签在 A 状态
   ↓
使用 A_2_B: 读取 A 状态标签，读取后变为 B
   ↓
结果: 被读取的标签 → B，未读取的 → A
   ↓
第二轮盘点: 使用 B_2_A 读取漏掉的标签
```

#### 4. Region (频段)

```java
setRegionConf(RG_PRC);
```

**频段规定：**

| 区域           | 频段范围    | 说明             |
| -------------- | ----------- | ---------------- |
| 中国 (RG_PRC)  | 920-925 MHz | 中国法规 ✅       |
| 北美 (RG_NA)   | 902-928 MHz | 美国、加拿大     |
| 欧洲 (RG_EU)   | 865-868 MHz | 欧盟法规         |
| 全球 (RG_OPEN) | 860-960 MHz | 测试用，可能违法 |

**注意：** 使用错误的频段可能违反当地无线电管理法规！

### 参数调优建议

```java
// 仓库盘点场景（标签多、距离远）
readPower = 3300;        // 最大功率
session = SESSION1;      // 多标签处理
target = A_2_B;          // 标准模式
region = RG_PRC;         // 根据所在地

// 近距离精确读取场景
readPower = 2000;        // 中等功率，减少干扰
session = SESSION0;      // 快速读取
target = A_2_B;          // 标准模式

// 移动盘点场景（传送带）
readPower = 2500;        // 中高功率
session = SESSION2;      // 移动场景
target = A_2_B;          // 标准模式
```

------

## 🔍 数据去重逻辑

### 为什么需要去重？

**问题：** RFID 读取器会持续高频扫描，同一个标签在 1 秒内可能被读取 **20-50 次**

```
不去重的结果：
─────────────────────────────────
时间      读取到的标签
─────────────────────────────────
00:00.100  E28011606... (标签A)
00:00.120  E28011606... (标签A) ← 重复
00:00.145  E28011606... (标签A) ← 重复
00:00.160  E28012308... (标签B)
00:00.185  E28011606... (标签A) ← 又重复
00:00.200  E28012308... (标签B) ← 重复
...
```

### 去重实现原理

#### 核心方法：`putCardInfoToList()`

```java
private void putCardInfoToList(UHFCardInfo newCard) {
    // 1. 查找标签是否已存在
    int pos = getCardInfoIndex(newCard);
    
    if (pos != -1) {
        // ========== 标签已存在：更新信息 ==========
        
        // 1.1 增加读取计数
        mCardDeviceList.cardInfos.get(pos).count++;
        
        // 1.2 更新 TID（如果之前为空）
        if (mCardDeviceList.cardInfos.get(pos).tid.equals("")) {
            mCardDeviceList.cardInfos.get(pos).tid = newCard.tid;
        } else {
            // 如果新读取的 TID 不为空，也更新
            if (!newCard.tid.equals("")) {
                mCardDeviceList.cardInfos.get(pos).tid = newCard.tid;
            }
        }
        
        // 1.3 更新信号强度和频率（保持最新）
        mCardDeviceList.cardInfos.get(pos).Frequency = newCard.Frequency;
        mCardDeviceList.cardInfos.get(pos).rssi = newCard.rssi;
        
    } else {
        // ========== 新标签：添加到列表 ==========
        newCard.count = 1;  // 初始计数为1
        mCardDeviceList.cardInfos.add(newCard);
    }
}
```

#### 查找方法：`getCardInfoIndex()`

```java
private int getCardInfoIndex(UHFCardInfo targetCard) {
    int size = mCardDeviceList.cardInfos.size();
    
    for (int index = 0; index < size; index++) {
        UHFCardInfo existingCard = mCardDeviceList.cardInfos.get(index);
        
        // 根据 EPC 判断是否为同一标签
        if (targetCard.epc.equals(existingCard.epc)) {
            return index;  // 找到了，返回索引
        }
    }
    
    return -1;  // 未找到
}
```

### 去重逻辑流程图

```
新标签数据到达
    ↓
根据 EPC 查找是否已存在
    ↓
┌─────────┴─────────┐
│                   │
已存在             不存在
│                   │
↓                   ↓
更新已有数据        添加到列表
- count++          - count = 1
- 更新 RSSI        - 保存所有信息
- 更新频率
- 补充 TID(如果缺失)
│                   │
└─────────┬─────────┘
          ↓
    通知 UI 刷新
```

### 数据结构

```java
public class UHFCardInfo {
    public String epc;      // 标签唯一标识（用于去重）
    public String tid;      // 标签芯片ID
    public int rssi;        // 信号强度（dBm）
    public int Frequency;   // 读取频率（KHz）
    public int count;       // 读取次数（去重后的统计）
}
```

### 实际效果对比

#### ❌ 不去重

```
列表显示（混乱不堪）：
┌──────────────────────────────────────────┐
│ EPC              │ TID         │ RSSI   │
├──────────────────────────────────────────┤
│ E28011606...     │ E2000134... │ -42 dBm│
│ E28011606...     │ E2000134... │ -43 dBm│ ← 重复
│ E28011606...     │ E2000134... │ -41 dBm│ ← 重复
│ E28012308...     │ E2000135... │ -45 dBm│
│ E28011606...     │ E2000134... │ -42 dBm│ ← 又重复
│ E28012308...     │ E2000135... │ -44 dBm│ ← 重复
│ ... (列表爆炸，无法使用)                 │
└──────────────────────────────────────────┘
```

#### ✅ 去重后

```
列表显示（清晰明了）：
┌────────────────────────────────────────────────┐
│ EPC              │ TID         │ 次数 │ RSSI   │
├────────────────────────────────────────────────┤
│ E28011606...     │ E2000134... │  45  │ -42 dBm│
│ E28012308...     │ E2000135... │  38  │ -45 dBm│
│ E28013421...     │ E2000136... │  52  │ -40 dBm│
└────────────────────────────────────────────────┘

统计信息：
- 标签数量：3 个唯一标签
- 总读取次数：135 次
- 平均每个标签读取：45 次
```

### 为什么只用 EPC 判断重复？

**EPC (Electronic Product Code)** 是标签的唯一标识符，类似于人的身份证号

```java
// EPC 是唯一的，足以区分不同标签
if (targetCard.epc.equals(existingCard.epc)) {
    // 这是同一个标签
}
```

**为什么不用 TID？**

- TID 是芯片编号，理论上也唯一
- 但读取 TID 需要额外配置，可能为空
- EPC 是标准字段，每次都能读到

**为什么不用 RSSI？**

- RSSI 会随距离、角度变化
- 同一标签的 RSSI 可能在 -40 到 -50 dBm 之间波动
- 不能作为唯一标识

------

## 💻 关键代码片段

### 1. 按钮点击处理

```java
@Override
public void onClick(View view) {
    int id = view.getId();
    
    if (id == R.id.startInventoryBtn) {
        // ========== 开始/停止盘点 ==========
        delayHandler.sendEmptyMessage(BTN_CHANGED);
        
        if (inventoryRunning) {
            // 停止盘点
            UHFEngine.getEngine().stopInventory();
            inventoryRunning = false;
            settingBtn.setEnabled(true);
            exportBtn.setEnabled(true);
        } else {
            // 启动盘点
            InventoryParams params = InventoryModeParams.getParams(
                DefaultConfigure.inventorymode,
                DefaultConfigure.inventoryParams,
                DefaultConfigure.inventorywithtid
            );
            
            Reader.READER_ERR er = UHFEngine.getEngine()
                .startInventory(params, RL, REL);
            
            if (er == Reader.READER_ERR.MT_OK_ERR) {
                inventoryRunning = true;
                settingBtn.setEnabled(false);
                exportBtn.setEnabled(false);
            }
        }
        
    } else if (id == R.id.cleanBtn) {
        // ========== 清空列表 ==========
        mCardDeviceList.cardInfos.clear();
        mCardDeviceList.allcount = 0;
        delayHandler.sendEmptyMessage(UPDATE_LIST);
        
        // 重置计时器
        inventorytimes = 0;
        delayHandler.sendEmptyMessage(UPDATE_TIME_UI);
        
    } else if (id == R.id.settingBtn) {
        // ========== 打开设置页面 ==========
        Intent intent = new Intent(this, SettingActivity.class);
        startActivity(intent);
        
    } else if (id == R.id.exportBtn) {
        // ========== 导出到 Excel ==========
        String filepath = Environment.getExternalStorageDirectory().getPath();
        String filename = filepath + "/Documents/Export_UHFTags_" + 
                         Util.getCurrentTimeFormat() + ".xls";
        
        int status = ExcelUtil.writeExcel(filename, mCardDeviceList.cardInfos);
        
        if (status == 0) {
            message = "Export Success!";
        } else {
            message = "Export failed!";
        }
        delayHandler.sendEmptyMessage(SHOW_TOAST);
    }
}
```

### 2. 列表项点击处理

```java
@Override
public void onItemClick(AdapterView<?> adapterView, View view, int i, long l) {
    MainActivity.this.runOnUiThread(new Runnable() {
        @Override
        public void run() {
            // 获取点击的标签 EPC
            TextView itemEpc = view.findViewById(R.id.epcvalue);
            String epc = itemEpc.getText().toString();
            
            // 保存到全局配置
            DefaultConfigure.currentEpc = epc;
            
            // 跳转到读写锁定页面
            Intent intent = new Intent(MainActivity.this, ReadWriteLockActivity.class);
            startActivity(intent);
        }
    });
}
```

### 3. 按键监听（硬件扫描键）

```java
@Override
public boolean onKeyDown(int keyCode, KeyEvent event) {
    // 检测 F1 键或设备的扫描键(292)
    if (!iskeydown && (keyCode == 292 || keyCode == KeyEvent.KEYCODE_F1)) {
        
        if (inventoryRunning) {
            // ========== 停止盘点 ==========
            stopInventory();
        } else {
            // ========== 开始盘点 ==========
            delayHandler.sendEmptyMessage(BTN_CHANGED);
            iskeydown = true;
            
            // 获取参数并启动
            InventoryParams params = InventoryModeParams.getParams(
                DefaultConfigure.inventorymode,
                DefaultConfigure.inventoryParams,
                DefaultConfigure.inventorywithtid
            );
            
            Reader.READER_ERR er = UHFEngine.getEngine()
                .startInventory(params, RL, REL);
            
            if (er == Reader.READER_ERR.MT_OK_ERR) {
                inventoryRunning = true;
                inventorytimes = 0;
                
                // 启动计时器
                delayHandler.sendEmptyMessage(UPDATE_TIME_UI);
                delayHandler.sendEmptyMessageDelayed(UPDATE_TIME_UI_LOOP, 1000);
                
                settingBtn.setEnabled(false);
                exportBtn.setEnabled(false);
            }
        }
    }
    return super.onKeyDown(keyCode, event);
}

@Override
public boolean onKeyUp(int keyCode, KeyEvent event) {
    // 按键释放时重置标志
    if (iskeydown && (keyCode == 292 || keyCode == KeyEvent.KEYCODE_F1)) {
        iskeydown = false;
    }
    return super.onKeyUp(keyCode, event);
}
```

### 4. 异常处理

```java
// 异步盘点方式监听异常事件
ReadExceptionListener REL = new ReadExceptionListener() {
    @Override
    public void tagReadException(final Reader.READER_ERR er) {
        // 处理读取异常
        // 可以在这里添加错误提示或重试逻辑
        Log.e("RFID", "Read exception: " + er.toString());
    }
};
```

### 5. 清空数据

```java
private void cleanCardInfoToList() {
    // 清空列表
    mCardDeviceList.cardInfos.clear();
    
    // 可以保留统计信息的重置
    // mCardDeviceList.allcount = 0;
}
```

------

## 🎨 设计模式总结

### 1. 观察者模式（Observer Pattern）

**应用场景：** 硬件事件回调

```java
// 观察者（监听器）
ReadListener RL = new ReadListener() {
    @Override
    public void tagRead(List<Reader.TagInfo> list) {
        // 收到通知后的处理
    }
};

// 被观察者（RFID引擎）
UHFEngine.getEngine().startInventory(params, RL, REL);
```

**优点：**

- 解耦硬件和业务逻辑
- 异步非阻塞
- 支持多个监听器

### 2. 单例模式（Singleton Pattern）

**应用场景：** 全局数据管理

```java
// CardDeviceList 单例
mCardDeviceList = CardDeviceList.getInstance();

// UHFEngine 单例
UHFEngine.getEngine().powerOn();
```

**优点：**

- 全局唯一实例
- 避免重复创建
- 数据共享方便

### 3. 适配器模式（Adapter Pattern）

**应用场景：** 列表数据展示

```java
// 适配器连接数据和视图
mCardInfoAdaptar = new CardInfoAdaptar(
    getApplicationContext(),
    mCardDeviceList.cardInfos
);

cardInfoListView.setAdapter(mCardInfoAdaptar);

// 数据变化时通知刷新
mCardInfoAdaptar.notifyDataSetChanged();
```

**优点：**

- 分离数据和展示
- 复用列表项视图
- 自动管理视图回收

### 4. 生命周期模式（Lifecycle Pattern）

**应用场景：** Activity 生命周期管理

```java
onCreate()   → 初始化 UI
onResume()   → 激活硬件
onPause()    → 释放硬件
onDestroy()  → 清理资源
```

**优点：**

- 自动资源管理
- 防止内存泄漏
- 优化电量使用

### 5. 消息队列模式（Message Queue Pattern）

**应用场景：** 线程间通信

```java
// 生产者（子线程）
delayHandler.sendEmptyMessage(UPDATE_LIST);

// 消费者（主线程）
handleMessage(Message msg) { ... }
```

**优点：**

- 线程安全
- 异步处理
- 解耦发送和处理

------

## 🔑 核心设计思想

### 1. 分层架构

```
┌─────────────────────────────────────┐
│  表现层 (Presentation Layer)        │
│  - Activity/Fragment                │
│  - UI 组件                           │
├─────────────────────────────────────┤
│  业务层 (Business Layer)            │
│  - 数据处理                         │
│  - 业务逻辑                         │
│  - 状态管理                         │
├─────────────────────────────────────┤
│  数据层 (Data Layer)                │
│  - 数据模型                         │
│  - 数据存储                         │
├─────────────────────────────────────┤
│  硬件层 (Hardware Layer)            │
│  - UHFEngine                        │
│  - 硬件驱动                         │
└─────────────────────────────────────┘
```

### 2. 异步编程

**原则：** 永远不要在主线程做耗时操作

```
主线程（UI线程）
    ↓
只负责：
- 响应用户操作
- 更新界面显示
- 播放音效

子线程（工作线程）
    ↓
负责：
- 硬件读写
- 数据处理
- 网络请求
```

### 3. 数据流向

```
单向数据流：

用户操作 → 更新状态 → 刷新UI
   ↑                      ↓
   └──────── 事件回调 ────┘
```

### 4. 状态管理

```java
// 关键状态标志
private boolean inventoryRunning = false;  // 盘点运行状态
private boolean iskeydown = false;         // 按键按下状态

// 状态改变时的处理
if (inventoryRunning) {
    // 执行停止逻辑
    stopInventory();
} else {
    // 执行启动逻辑
    startInventory();
}
```

------

## 📊 数据流程图

### 完整流程图

```
┌──────────────────────────────────────────────────────────────┐
│                        用户交互层                             │
│  [开始按钮] [停止按钮] [清空按钮] [设置] [导出] [硬件扫描键]  │
└────────────────────────┬─────────────────────────────────────┘
                         ↓
┌──────────────────────────────────────────────────────────────┐
│                      Activity 主线程                          │
│  - onClick() 处理按钮点击                                     │
│  - onKeyDown() 处理按键                                       │
│  - handleMessage() 处理消息                                   │
└────────────┬─────────────────────────┬───────────────────────┘
             ↓                         ↓
    ┌─────────────────┐      ┌─────────────────┐
    │  启动盘点逻辑    │      │  UI 更新逻辑     │
    │  startInventory()│      │  更新列表/按钮   │
    └────────┬─────────┘      └─────────────────┘
             ↓
┌──────────────────────────────────────────────────────────────┐
│                      UHF 引擎层                               │
│  UHFEngine.getEngine().startInventory(params, RL, REL)       │
└────────────────────────┬─────────────────────────────────────┘
                         ↓
┌──────────────────────────────────────────────────────────────┐
│                      硬件驱动层                               │
│  - 串口通信                                                   │
│  - 射频信号发射                                               │
│  - 标签响应接收                                               │
└────────────────────────┬─────────────────────────────────────┘
                         ↓
┌──────────────────────────────────────────────────────────────┐
│                      RFID 标签                                │
│  标签接收信号 → 调制反射 → 返回 EPC/TID/RSSI                 │
└────────────────────────┬─────────────────────────────────────┘
                         ↓
┌──────────────────────────────────────────────────────────────┐
│                    回调监听器（子线程）                        │
│  ReadListener.tagRead(List<TagInfo>)                         │
│  - 解析数据                                                   │
│  - 数据去重 putCardInfoToList()                              │
│  - 发送消息 sendEmptyMessage(UPDATE_LIST)                    │
└────────────────────────┬─────────────────────────────────────┘
                         ↓
┌──────────────────────────────────────────────────────────────┐
│                    Handler 消息队列                           │
│  Message msg: { what: UPDATE_LIST }                          │
└────────────────────────┬─────────────────────────────────────┘
                         ↓
┌──────────────────────────────────────────────────────────────┐
│                    主线程 UI 更新                             │
│  - mCardInfoAdaptar.notifyDataSetChanged()                   │
│  - tagscount.setText(...)                                    │
│  - soundPool.play(...) 播放提示音                            │
└──────────────────────────────────────────────────────────────┘
```

------

## 💡 最佳实践建议

### 1. 资源管理

```java
// ✅ 正确：在生命周期方法中管理硬件
@Override
protected void onResume() {
    super.onResume();
    initHardware();  // 激活硬件
}

@Override
protected void onPause() {
    super.onPause();
    releaseHardware();  // 释放硬件
}

// ❌ 错误：在 onCreate 中初始化硬件
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    // ❌ 不要在这里初始化硬件
    // UHFEngine.getEngine().powerOn();
}
```

### 2. 线程安全

```java
// ✅ 正确：通过 Handler 更新 UI
ReadListener RL = new ReadListener() {
    @Override
    public void tagRead(List<Reader.TagInfo> list) {
        processData(list);
        delayHandler.sendEmptyMessage(UPDATE_LIST);
    }
};

// ❌ 错误：直接在子线程更新 UI
ReadListener RL = new ReadListener() {
    @Override
    public void tagRead(List<Reader.TagInfo> list) {
        // ❌ 崩溃！不能在子线程更新 UI
        textView.setText("更新");
    }
};
```

### 3. 状态管理

```java
// ✅ 正确：使用标志位管理状态
private boolean inventoryRunning = false;

public void toggleInventory() {
    if (inventoryRunning) {
        stopInventory();
        inventoryRunning = false;
    } else {
        startInventory();
        inventoryRunning = true;
    }
}

// ❌ 错误：没有状态管理
public void toggleInventory() {
    // ❌ 不知道当前是什么状态
    startInventory();  // 可能重复启动
}
```

### 4. 错误处理

```java
// ✅ 正确：检查返回值
Reader.READER_ERR er = UHFEngine.getEngine()
    .startInventory(params, RL, REL);

if (er == Reader.READER_ERR.MT_OK_ERR) {
    // 启动成功
    inventoryRunning = true;
} else {
    // 启动失败，提示用户
    Toast.makeText(this, "启动失败", Toast.LENGTH_SHORT).show();
}

// ❌ 错误：不检查返回值
UHFEngine.getEngine().startInventory(params, RL, REL);
inventoryRunning = true;  // ❌ 可能启动失败但状态已改变
```

### 5. 内存管理

```java
// ✅ 正确：清空数据时完全清理
public void clearData() {
    mCardDeviceList.cardInfos.clear();
    mCardDeviceList.allcount = 0;
    mCardInfoAdaptar.notifyDataSetChanged();
}

// ✅ 正确：停止盘点时清理定时器
public void stopInventory() {
    UHFEngine.getEngine().stopInventory();
    delayHandler.removeMessages(UPDATE_TIME_UI_LOOP);  // 防止内存泄漏
    inventoryRunning = false;
}
```

------

## 🎯 总结

### 核心设计原则

1. **分层架构** - UI / 业务 / 硬件 各司其职
2. **异步编程** - 永远不阻塞主线程
3. **生命周期管理** - 随界面状态管理资源
4. **消息机制** - 解决线程通信问题
5. **数据去重** - 保证数据质量

### 关键技术点

| 技术点           | 作用     | 实现方式                                 |
| ---------------- | -------- | ---------------------------------------- |
| **Handler**      | 线程通信 | `sendEmptyMessage()` + `handleMessage()` |
| **ReadListener** | 异步回调 | 接收 RFID 读取结果                       |
| **生命周期**     | 资源管理 | `onResume()` / `onPause()`               |
| **数据去重**     | 数据处理 | 根据 EPC 判断重复                        |
| **状态管理**     | 流程控制 | `inventoryRunning` 标志位                |

### 常见问题

**Q1: 为什么不能在子线程更新 UI？**

- Android 的 UI 组件不是线程安全的
- 必须在主线程（UI 线程）操作 UI
- 使用 Handler 或 runOnUiThread() 切换到主线程

**Q2: 为什么要在 onResume/onPause 管理硬件？**

- 界面不可见时释放硬件节省资源
- 避免多个应用同时占用硬件
- Android 生命周期自动管理

**Q3: Session 和 Target 有什么区别？**

- Session：控制标签响应的时间策略
- Target：控制标签的 A/B 状态切换
- 两者配合使用优化多标签读取

**Q4: 为什么要数据去重？**

- RFID 持续扫描，同一标签会被读取多次
- 去重后列表清晰，用户体验好
- 保留读取次数用于统计分析

------

## 📚 扩展阅读

### 相关概念

- **EPC Gen2 协议**：RFID 标签通信协议
- **RSSI**：接收信号强度指示
- **TID**：标签唯一标识符
- **串口通信**：设备间数据传输方式

### 推荐学习资源

1. Android Handler 机制详解
2. RFID 技术原理与应用
3. Android Activity 生命周期
4. 异步编程最佳实践

