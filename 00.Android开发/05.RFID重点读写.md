# RFID标签读写与锁定操作详解

## 一、RFID标签内存结构

RFID标签内部包含四个主要的存储区域：

### 1. **TID区（标签ID区）**

- **特性**：不可修改
- **用途**：存储标签的唯一识别码，由厂商写入
- **说明**：每个标签的TID都是唯一的，用于标签的身份识别

### 2. **EPC区（电子产品码区）**

- **特性**：唯一标识，可修改
- **用途**：存储产品的电子编码
- **说明**：这是最常用的区域，用于标识不同的商品或物品

### 3. **USER MEMORY区（用户存储区）**

- **特性**：可读写
- **用途**：用户自定义数据存储
- **说明**：可以存储商品信息、生产日期、批次等额外数据

### 4. **Reserved区（保留区/密码区）**

- **特性**：可读写
- **用途**：存储访问密码和销毁密码
- **说明**：用于标签的安全保护

------

## 二、核心功能实现

### 2.1 读取TID（标签唯一ID）

#### 操作步骤：

**第一步：设置过滤器**

```java
// 创建过滤器对象
Reader.TagFilter_ST g2tf = new Reader.TagFilter_ST();

// 将EPC字符串转换为字节数组
byte[] fdata = new byte[DefaultConfigure.currentEpc.length() / 2];
UHFUtils.Str2Hex(DefaultConfigure.currentEpc, DefaultConfigure.currentEpc.length(), fdata);

// 配置过滤器参数
g2tf.fdata = fdata;                    // 过滤数据
g2tf.flen = fdata.length * 8;          // 数据长度（单位：bit）
g2tf.isInvert = 0;                     // 不反转
g2tf.bank = InventoryModeParams.BANK.EPC;  // 在EPC区进行过滤
g2tf.startaddr = 32;                   // 起始地址32bit（跳过PC等数据）

// 应用过滤器
Reader.READER_ERR er = UHFParamsOperator.getInstance().setTagFilter(g2tf);
```

**第二步：读取TID数据**

```java
byte[] rdata = new byte[12];           // 准备12字节的存储空间
byte[] rpaswd = {0x00,0x00,0x00,0x00}; // 访问密码（全0表示无密码）

int rbank = InventoryModeParams.BANK.TID;  // 指定读取TID区
int startblock = 0;                    // 起始块地址为0
int blockcount = 6;                    // 读取6个块（每块2字节，共12字节）

// 循环尝试读取（最多3次）
for(int index = 0; index < 3; index++) {
    er = UHFEngine.getEngine().getTagData(
            1,              // 天线编号
            (char) rbank,   // 存储区类型
            startblock,     // 起始块
            blockcount,     // 块数量
            rdata,          // 接收数据的缓冲区
            rpaswd,         // 访问密码
            (short) 1000    // 超时时间（毫秒）
    );
    if(er == Reader.READER_ERR.MT_OK_ERR)
        break;  // 读取成功，退出循环
}
```

**第三步：显示结果并重置过滤器**

```java
if (er == Reader.READER_ERR.MT_OK_ERR) {
    // 将字节数组转换为十六进制字符串并显示
    rw_tid_text.setText(Util.bytes2hex(rdata).toUpperCase(Locale.ROOT));
    Toast.makeText(getApplicationContext(),"Read TID success!",Toast.LENGTH_SHORT).show();
} else {
    Toast.makeText(getApplicationContext(),"Read TID failed!",Toast.LENGTH_SHORT).show();
}

// 重置过滤器
UHFParamsOperator.getInstance().setTagFilter(null);
```

------

### 2.2 通用读取操作

#### 功能说明：

可以读取标签的任意存储区（Reserved、EPC、TID、USER）

#### 关键参数设置：

**1. 选择存储区**

```java
int rbank = 0;
switch (rw_mem_bank_read_spinner.getSelectedItemPosition()){
    case 0:  // 读取Reserved区（保留区）
        rbank = InventoryModeParams.BANK.Reserved;
        break;
    case 1:  // 读取EPC区
        rbank = InventoryModeParams.BANK.EPC;
        break;
    case 2:  // 读取TID区
        rbank = InventoryModeParams.BANK.TID;
        break;
    case 3:  // 读取USER区
        rbank = InventoryModeParams.BANK.USER;
        break;
}
```

**2. 设置读取参数**

```java
int startaddr = Integer.valueOf(rw_address_read_edittext.getText().toString().trim());
int blocks = Integer.valueOf(rw_read_length_edittext.getText().toString().trim());

// 准备密码（如果标签设置了密码）
byte[] rpaswd = new byte[rw_password_read_edittext.getText().length()/2];
UHFUtils.Str2Hex(rw_password_read_edittext.getText().toString(), 
                 rw_password_read_edittext.getText().toString().length(), rpaswd);

// 准备数据缓冲区
byte[] rdata = new byte[blocks*2];  // 每块2字节
```

**3. 执行读取**

```java
// 设置过滤器（根据EPC定位标签）
if(!setFilter()){
    Toast.makeText(getApplicationContext(),"设置过滤失败！",Toast.LENGTH_SHORT).show();
    return;
}

// 循环尝试读取
for(int index = 0; index < 3; index++) {
    er = UHFEngine.getEngine().getTagData(
            1,              // 天线编号
            (char) rbank,   // 存储区
            startblock,     // 起始块
            blockcount,     // 块数量
            rdata,          // 数据缓冲区
            rpaswd,         // 访问密码
            (short) 1000    // 超时时间
    );
    if(er == Reader.READER_ERR.MT_OK_ERR)
        break;
}

// 显示结果
if (er == Reader.READER_ERR.MT_OK_ERR) {
    rw_read_rsp_text.setText(Util.bytes2hex(rdata).toUpperCase(Locale.ROOT));
    Toast.makeText(getApplicationContext(),"Read success!",Toast.LENGTH_SHORT).show();
} else {
    Toast.makeText(getApplicationContext(),"Read failed!",Toast.LENGTH_SHORT).show();
}

resetFilter();  // 重置过滤器
```

------

### 2.3 写入操作

#### 功能说明：

可以向标签的指定存储区写入数据（Reserved、EPC、USER区可写，TID区不可写）

#### 操作步骤：

**第一步：确定写入的存储区**

```java
int wbank = 0;
switch (rw_mem_bank_write_spinner.getSelectedItemPosition()){
    case 0:  // 写入Reserved区
        wbank = InventoryModeParams.BANK.Reserved;
        break;
    case 1:  // 写入EPC区
        wbank = InventoryModeParams.BANK.EPC;
        break;
    case 2:  // 写入USER区（注意：没有TID选项，因为TID不可写）
        wbank = InventoryModeParams.BANK.USER;
        break;
}
```

**第二步：准备写入数据**

```java
// 起始地址
int write_startaddr = Integer.valueOf(rw_address_write_edittext.getText().toString().trim());

// 访问密码
byte[] wpaswd = new byte[rw_password_write_edittext.getText().length()/2];
UHFUtils.Str2Hex(rw_password_write_edittext.getText().toString(), 
                 rw_password_write_edittext.getText().toString().length(), wpaswd);

// 待写入的数据
String wdataString = rw_data_write_edittext.getText().toString();
byte[] wdata = new byte[wdataString.length()/2];
UHFUtils.Str2Hex(wdataString, wdataString.length(), wdata);
```

**第三步：执行写入操作**

```java
// 设置过滤器
if(!setFilter()){
    Toast.makeText(getApplicationContext(),"设置过滤失败！",Toast.LENGTH_SHORT).show();
    return;
}

// 循环尝试写入（最多3次）
int trycount = 3;
Reader.READER_ERR er = null;
do {
    er = UHFEngine.getEngine().writeTagData(
            1,              // 天线编号
            (char) wbank,   // 存储区
            write_startaddr,// 起始地址
            wdata,          // 写入数据
            wdata.length,   // 数据长度
            wpaswd,         // 访问密码
            (short) 1000    // 超时时间
    );
    
    trycount--;
    if (trycount < 1)
        break;
} while (er != Reader.READER_ERR.MT_OK_ERR);

resetFilter();  // 恢复过滤器

// 显示结果
if (er == Reader.READER_ERR.MT_OK_ERR) {
    Toast.makeText(getApplicationContext(),"Write success!",Toast.LENGTH_SHORT).show();
} else {
    Toast.makeText(getApplicationContext(),"Write failed!",Toast.LENGTH_SHORT).show();
}
```

------

### 2.4 锁定操作

#### 功能说明：

对标签的特定区域进行锁定，防止未授权的访问或修改

#### 锁定类型：

1. **UNLOCK（解锁）**：可自由读写
2. **LOCK（锁定）**：需要密码才能读写
3. **PERM_LOCK（永久锁定）**：永久锁定，无法恢复

#### 可锁定的对象：

```java
// 根据选择的项目确定锁定对象
Reader.Lock_Obj lobj = null;
Reader.Lock_Type ltyp = null;

int lbank = lock_item_spinner.getSelectedItemPosition();
int ltype = lock_type_spinner.getSelectedItemPosition();

if (lbank == 0) {  // 锁定访问密码
    lobj = Reader.Lock_Obj.LOCK_OBJECT_ACCESS_PASSWD;
    if (ltype == 0)
        ltyp = Reader.Lock_Type.ACCESS_PASSWD_UNLOCK;
    else if (ltype == 1)
        ltyp = Reader.Lock_Type.ACCESS_PASSWD_LOCK;
    else if (ltype == 2)
        ltyp = Reader.Lock_Type.ACCESS_PASSWD_PERM_LOCK;
        
} else if (lbank == 1) {  // 锁定销毁密码
    lobj = Reader.Lock_Obj.LOCK_OBJECT_KILL_PASSWORD;
    if (ltype == 0)
        ltyp = Reader.Lock_Type.KILL_PASSWORD_UNLOCK;
    else if (ltype == 1)
        ltyp = Reader.Lock_Type.KILL_PASSWORD_LOCK;
    else if (ltype == 2)
        ltyp = Reader.Lock_Type.KILL_PASSWORD_PERM_LOCK;
        
} else if (lbank == 2) {  // 锁定EPC区（BANK1）
    lobj = Reader.Lock_Obj.LOCK_OBJECT_BANK1;
    if (ltype == 0)
        ltyp = Reader.Lock_Type.BANK1_UNLOCK;
    else if (ltype == 1)
        ltyp = Reader.Lock_Type.BANK1_LOCK;
    else if (ltype == 2)
        ltyp = Reader.Lock_Type.BANK1_PERM_LOCK;
        
} else if (lbank == 3) {  // 锁定TID区（BANK2）
    lobj = Reader.Lock_Obj.LOCK_OBJECT_BANK2;
    if (ltype == 0)
        ltyp = Reader.Lock_Type.BANK2_UNLOCK;
    else if (ltype == 1)
        ltyp = Reader.Lock_Type.BANK2_LOCK;
    else if (ltype == 2)
        ltyp = Reader.Lock_Type.BANK2_PERM_LOCK;
        
} else if (lbank == 4) {  // 锁定USER区（BANK3）
    lobj = Reader.Lock_Obj.LOCK_OBJECT_BANK3;
    if (ltype == 0)
        ltyp = Reader.Lock_Type.BANK3_UNLOCK;
    else if (ltype == 1)
        ltyp = Reader.Lock_Type.BANK3_LOCK;
    else if (ltype == 2)
        ltyp = Reader.Lock_Type.BANK3_PERM_LOCK;
}
```

#### 执行锁定：

```java
// 准备锁定密码
byte[] lockpaswd = new byte[4];
if (!rw_password_lock_edittext.getText().toString().equals("")) {
    UHFUtils.Str2Hex(rw_password_lock_edittext.getText().toString(),
                     rw_password_lock_edittext.getText().toString().length(), lockpaswd);
}

// 设置过滤器
if(!setFilter()){
    Toast.makeText(getApplicationContext(),"设置过滤失败！",Toast.LENGTH_SHORT).show();
    return;
}

// 执行锁定操作
Reader.READER_ERR er = UHFEngine.getEngine().lockTag(
        1,                      // 天线编号
        (byte) lobj.value(),    // 锁定对象
        (short) ltyp.value(),   // 锁定类型
        lockpaswd,              // 访问密码
        (short) 1000            // 超时时间
);

if (er == Reader.READER_ERR.MT_OK_ERR) {
    Toast.makeText(getApplicationContext(),"Lock Success!",Toast.LENGTH_SHORT).show();
} else {
    Toast.makeText(getApplicationContext(),"Lock failed!",Toast.LENGTH_SHORT).show();
}

resetFilter();  // 重置过滤器
```

#### ⚠️ 重要提示：

```java
// 在执行锁定操作前，会弹出警告对话框
AlertDialog.Builder builder = new AlertDialog.Builder(ReadWriteLockActivity.this);
builder.setTitle(R.string.warning);
builder.setMessage(R.string.lockwarning);
builder.setPositiveButton(R.string.commit, new DialogInterface.OnClickListener() {
    @Override
    public void onClick(DialogInterface dialog, int which) {
        // 执行锁定操作
    }
});
builder.setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {
    @Override
    public void onClick(DialogInterface dialog, int which) {
        dialog.cancel();
    }
});
```

------

### 2.5 销毁标签（Kill操作）

#### 功能说明：

永久销毁标签，使其无法再被读取或使用。**此操作不可逆！**

#### 操作步骤：

```java
// 准备销毁密码
byte[] killpaswd = new byte[4];
if (!rw_password_kill_edittext.getText().toString().equals("")) {
    UHFUtils.Str2Hex(rw_password_kill_edittext.getText().toString(),
                     rw_password_kill_edittext.getText().toString().length(), killpaswd);
}

// 设置过滤器
if(!setFilter()){
    Toast.makeText(getApplicationContext(),"设置过滤失败！",Toast.LENGTH_SHORT).show();
    return;
}

// 执行销毁操作
Reader.READER_ERR er = UHFEngine.getEngine().killTag(
        1,              // 天线编号
        killpaswd,      // 销毁密码
        (short) 1000    // 超时时间
);

if (er == Reader.READER_ERR.MT_OK_ERR) {
    Toast.makeText(getApplicationContext(),"Kill success!",Toast.LENGTH_SHORT).show();
} else {
    Toast.makeText(getApplicationContext(),"Kill failed!",Toast.LENGTH_SHORT).show();
}

resetFilter();
```

#### ⚠️ 危险警告：

销毁操作同样会弹出警告对话框，确保用户了解操作的严重性。销毁后的标签将永久失效，无法恢复！

------

## 三、过滤器设置详解

### 3.1 setFilter() 方法

过滤器用于在多标签环境中精确定位目标标签。

```java
private boolean setFilter(){
    Reader.TagFilter_ST g2tf = new Reader.TagFilter_ST();
    
    // 验证过滤数据有效性
    if(filterdata_edittext.getText().toString().length() == 0 || 
       filterdata_edittext.getText().toString().length()%2 != 0){
        return false;  // 数据为空或长度不是偶数
    }
    
    // 将十六进制字符串转换为字节数组
    byte[] fdata = new byte[filterdata_edittext.getText().toString().length() / 2];
    UHFUtils.Str2Hex(filterdata_edittext.getText().toString(), 
                     filterdata_edittext.getText().toString().length(), fdata);
    
    // 配置过滤器参数
    g2tf.fdata = fdata;                    // 过滤数据
    g2tf.flen = fdata.length * 8;          // 长度（bit）
    g2tf.isInvert = 0;                     // 不反转
    g2tf.bank = filter_mem_bank_spinner.getSelectedItemPosition();  // 过滤的存储区
    g2tf.startaddr = Integer.valueOf(filter_address_edittext.getText().toString())*2*8;  
    // 起始地址转换：块地址 × 2字节/块 × 8bit/字节
    
    // 应用过滤器
    Reader.READER_ERR er = UHFParamsOperator.getInstance().setTagFilter(g2tf);
    if (er == Reader.READER_ERR.MT_OK_ERR) {
        Log.e("###","设置过滤成功！");
        return true;
    }
    return false;
}
```

### 3.2 resetFilter() 方法

操作完成后，必须重置过滤器，否则会影响后续操作。

```java
private void resetFilter(){
    UHFParamsOperator.getInstance().setTagFilter(null);
}
```

------

## 四、生命周期管理

### 4.1 onResume() - 初始化连接

```java
protected void onResume() {
    // 给RFID模块上电
    UHFEngine.getEngine().powerOn();
    
    // 连接RFID模块
    Reader.READER_ERR er = UHFEngine.getEngine().connectModule(
                                DefaultConfigure.UART_DEV_PATH, 1);
    
    if(er == Reader.READER_ERR.MT_OK_ERR){
        // 连接成功，进行默认初始化
        DefaultConfigure.defaultInitModule();
        Log.e("####","connect success!");
    } else {
        Log.e("####","connect failed!");
    }
    super.onResume();
}
```

### 4.2 onPause() - 断开连接

```java
@Override
protected void onPause() {
    // 断开模块连接
    UHFEngine.getEngine().disconnectModule();
    
    // 给模块下电
    UHFEngine.getEngine().powerOff();
    
    super.onPause();
}
```

------

## 五、重要概念总结

### 5.1 地址单位说明

- **块（Block）**：RFID标签的基本存储单位，每块 = 2字节 = 16bit
- **字节（Byte）**：8bit
- **bit**：最小单位

**地址转换关系：**

```
块地址 × 2 × 8 = bit地址
例如：块地址2 → bit地址32 (2 × 2 × 8)
```

### 5.2 EPC区特殊说明

EPC区的前32bit存储PC（协议控制）等数据，实际的EPC数据从第32bit开始。所以：

- 读取EPC内容时：起始地址通常设置为2（跳过PC）
- 过滤EPC数据时：起始地址设置为32bit

### 5.3 密码说明

- **访问密码**：4字节，用于保护标签的读写操作
- **销毁密码**：4字节，用于执行销毁操作
- **默认密码**：0x00000000（全0）

### 5.4 操作流程标准模式

```
1. 设置过滤器（定位目标标签）
2. 执行操作（读/写/锁/销毁）
3. 重置过滤器（清除过滤条件）
```

------

## 六、注意事项

1. **永久锁定和销毁操作不可逆**，操作前务必确认
2. 所有操作都会尝试最多3次，提高成功率
3. 过滤器使用后必须重置，避免影响后续操作
4. TID区不可写入，只能读取
5. 密码长度必须是4字节（8个十六进制字符）
6. 写入数据时，长度必须是偶数个十六进制字符

## 七、参考代码

```java
package com.pda.testuhfapi;

import androidx.appcompat.app.AppCompatActivity;

import android.annotation.SuppressLint;
import android.app.Activity;
import android.app.AlertDialog;
import android.content.DialogInterface;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.AdapterView;
import android.widget.Button;
import android.widget.EditText;
import android.widget.Spinner;
import android.widget.TextView;
import android.widget.Toast;

import com.pda.uhf.UHFEngine;
import com.pda.uhf.UHFParamsOperator;
import com.pda.uhf.UHFUtils;
import com.pda.uhf.model.params.AntPowerConfResult;
import com.uhf.api.cls.Reader;

import java.util.Locale;

public class ReadWriteLockActivity extends Activity {

    private TextView rw_tid_text = null;
    private EditText rw_epc_edit = null;

    private Button rw_gettid_btn = null;

    private Button rw_read_btn = null;
    private Spinner rw_mem_bank_read_spinner = null;
    private TextView rw_address_read_edittext = null;
    private TextView rw_read_length_edittext = null;
    private TextView rw_password_read_edittext = null;
    private TextView rw_read_rsp_text = null;
    private Spinner filter_mem_bank_spinner = null;
    private EditText filter_address_edittext = null;
    private EditText filterdata_edittext = null;

    private Spinner rw_mem_bank_write_spinner = null;
    private Button rw_write_btn = null;
    private EditText rw_address_write_edittext = null;
    private EditText rw_password_write_edittext = null;
    private EditText rw_data_write_edittext = null;
    private TextView rw_write_rsp_text = null;

    private Spinner lock_item_spinner = null;
    private Spinner lock_type_spinner = null;
    private EditText rw_password_lock_edittext = null;
    private Button rw_lock_btn = null;

    private EditText rw_password_kill_edittext = null;
    private Button rw_kill_btn = null;

    @SuppressLint("WrongViewCast")
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_read_write_lock);

        rw_tid_text = findViewById(R.id.rw_tid_text);
        rw_epc_edit = findViewById(R.id.rw_epc_edit);
        rw_epc_edit.setText(DefaultConfigure.currentEpc);

        rw_gettid_btn = findViewById(R.id.rw_gettid_btn);
        rw_gettid_btn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                //根据EPC数据读取TID
                byte[] rdata = new byte[12];//读取存放的存储空间
                byte[] rpaswd = {0x00,0x00,0x00,0x00};//密钥，如果标签有密钥填入自己的密钥，如果没有用全0
                Reader.TagFilter_ST g2tf = new Reader.TagFilter_ST();//创建过滤起
                //转换成EPC字节数组
                byte[] fdata = new byte[DefaultConfigure.currentEpc.length() / 2];
                UHFUtils.Str2Hex(DefaultConfigure.currentEpc, DefaultConfigure.currentEpc.length(), fdata);

                //Log.e("###",Util.bytes2hex(fdata));
                //Log.e("###",Util.bytes2hex(rpaswd));

                g2tf.fdata = fdata;
                g2tf.flen = fdata.length * 8;//长度单位是bit，所以用字节数乘以8
                g2tf.isInvert = 0;


                g2tf.bank = InventoryModeParams.BANK.EPC;//设置过滤的分区为EPC
                g2tf.startaddr = 32;//开始地址，EPC分区前32个bit是PC等数据，所以跳过前32个bit
                Reader.READER_ERR er = UHFParamsOperator.getInstance().setTagFilter(g2tf);//设置过滤条件
                if (er == Reader.READER_ERR.MT_OK_ERR) {
                    Log.e("###","设置过滤成功！");
                }
                //读tid （2），起始块 0  块数 6
                int rbank = InventoryModeParams.BANK.TID;//读取分区是TID
                int startblock = 0;//开始地址，TID的开始地址是0，如果要跳过前面的字节，设置这个数值，单位是bit
                int blockcount = 6;//设置读取的块数，读取是以块读取，每个块是2个字节，6个块就是12个字节，96个bit

                //最多循环读三次，如果三次都失败，认为读取失败
                for(int index = 0;index < 3;index++) {
                    er = UHFEngine.getEngine().getTagData(
                            1,//读取的天线，只有一个天线，设置为1
                            (char) rbank,
                            startblock,
                            blockcount,
                            rdata,
                            rpaswd,
                            (short) 1000//读取超时时间
                    );
                    if(er == Reader.READER_ERR.MT_OK_ERR)
                        break;
                }

                if (er == Reader.READER_ERR.MT_OK_ERR) {
                    //Log.e("###","TID:"+Util.bytes2hex(rdata));
                    ReadWriteLockActivity.this.runOnUiThread(new Runnable() {
                        @Override
                        public void run() {

                            rw_tid_text.setText(Util.bytes2hex(rdata).toUpperCase(Locale.ROOT));
                            Toast.makeText(getApplicationContext(),"Read TID success!",Toast.LENGTH_SHORT).show();
                        }
                    });

                }else{
                    ReadWriteLockActivity.this.runOnUiThread(new Runnable() {
                        @Override
                        public void run() {
                            Toast.makeText(getApplicationContext(),"Read TID failed!",Toast.LENGTH_SHORT).show();
                        }
                    });
                }
                UHFParamsOperator.getInstance().setTagFilter(null);//读取完毕，恢复过滤设置
            }
        });


        rw_mem_bank_read_spinner = findViewById(R.id.rw_mem_bank_read_spinner);

        rw_mem_bank_read_spinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
            @Override
            public void onItemSelected(AdapterView<?> adapterView, View view, int i, long l) {
                if(i == 1)
                    rw_address_read_edittext.setText("2");
                else
                    rw_address_read_edittext.setText("0");
            }

            @Override
            public void onNothingSelected(AdapterView<?> adapterView) {

            }
        });
        rw_address_read_edittext = findViewById(R.id.rw_address_read_edittext);
        rw_read_length_edittext = findViewById(R.id.rw_read_length_edittext);
        rw_password_read_edittext = findViewById(R.id.rw_password_read_edittext);
        rw_read_btn = findViewById(R.id.rw_read_btn);
        rw_read_rsp_text = findViewById(R.id.rw_read_rsp_text);
        rw_read_btn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                int startaddr = Integer.valueOf(rw_address_read_edittext.getText().toString().trim());
                int blocks = Integer.valueOf(rw_read_length_edittext.getText().toString().trim());
                byte[] rpaswd = new byte[rw_password_read_edittext.getText().length()/2];
                UHFUtils.Str2Hex(rw_password_read_edittext.getText().toString(), rw_password_read_edittext.getText().toString().length(), rpaswd);
                byte[] rdata = new byte[blocks*2];//读取存放的存储空间
                Reader.READER_ERR er = null;
                /*
                int readlength = Integer.valueOf(rw_read_length_edittext.getText().toString().trim());






                Reader.TagFilter_ST g2tf = new Reader.TagFilter_ST();//创建过滤器
                //转换成字节数组
                byte[] fdata = new byte[DefaultConfigure.currentEpc.length() / 2];
                UHFUtils.Str2Hex(filterdata_edittext.getText().toString(), filterdata_edittext.getText().toString().length(), fdata);

                g2tf.fdata = fdata;
                g2tf.flen = fdata.length * 8;//长度单位是bit，所以用字节数乘以8
                g2tf.isInvert = 0;

                //g2tf.bank = InventoryModeParams.BANK.EPC;//设置过滤的分区为EPC
                g2tf.bank = filter_mem_bank_spinner.getSelectedItemPosition();
                //g2tf.startaddr = 32;//开始地址，EPC分区前32个bit是PC等数据，所以跳过前32个bit

                g2tf.startaddr = Integer.valueOf(filter_address_edittext.getText().toString())*2*8;//一个块2个字节，每个字节8个bit


                Reader.READER_ERR er = UHFParamsOperator.getInstance().setTagFilter(g2tf);//设置过滤条件
                if (er == Reader.READER_ERR.MT_OK_ERR) {
                    Log.e("###","设置过滤成功！");
                }

                 */
                if(!setFilter()){
                    Toast.makeText(getApplicationContext(),"设置过滤失败！",Toast.LENGTH_SHORT).show();
                    return;
                }
                int startblock = startaddr;//开始地址，TID的开始地址是0，如果要跳过前面的字节，设置这个数值，单位是bit
                int blockcount = blocks;//设置读取的块数，读取是以块读取，每个块是2个字节，6个块就是12个字节，96个bit
                int rbank = 0;
                switch (rw_mem_bank_read_spinner.getSelectedItemPosition()){
                    case 0://read reserved
                        rbank = InventoryModeParams.BANK.Reserved;//读取分区是reserved(保留区)
                        break;
                    case 1://read epc
                        //读epc （1），起始块 2  块数 6
                        rbank = InventoryModeParams.BANK.EPC;//读取分区是EPC
                        break;
                    case 2://read tid
                        //读tid （2），起始块 0  块数 6
                        rbank = InventoryModeParams.BANK.TID;//读取分区是TID
                        break;
                    case 3://read user
                        //读user （3），起始块 0  块数 6
                        rbank = InventoryModeParams.BANK.USER;//读取分区是USER
                        break;
                }
                //最多循环读三次，如果三次都失败，认为读取失败
                for(int index = 0;index < 3;index++) {
                    er = UHFEngine.getEngine().getTagData(
                            1,//读取的天线，只有一个天线，设置为1
                            (char) rbank,
                            startblock,
                            blockcount,
                            rdata,
                            rpaswd,
                            (short) 1000//读取超时时间
                    );
                    if(er == Reader.READER_ERR.MT_OK_ERR)
                        break;
                }
                if (er == Reader.READER_ERR.MT_OK_ERR) {
                    //Log.e("###","TID:"+Util.bytes2hex(rdata));
                    ReadWriteLockActivity.this.runOnUiThread(new Runnable() {
                        @Override
                        public void run() {
                            rw_read_rsp_text.setText(Util.bytes2hex(rdata).toUpperCase(Locale.ROOT));
                            Toast.makeText(getApplicationContext(),"Read success!",Toast.LENGTH_SHORT).show();
                        }
                    });

                }else{
                    ReadWriteLockActivity.this.runOnUiThread(new Runnable() {
                        @Override
                        public void run() {
                            Toast.makeText(getApplicationContext(),"Read failed!",Toast.LENGTH_SHORT).show();
                        }
                    });
                }
                //UHFParamsOperator.getInstance().setTagFilter(null);//读取完毕，恢复过滤设置为null
                resetFilter();
            }
        });

        filter_mem_bank_spinner = findViewById(R.id.filter_mem_bank_spinner);
        filter_address_edittext = findViewById(R.id.filter_address_edittext);
        filterdata_edittext = findViewById(R.id.filterdata_edittext);
        filterdata_edittext.setText(DefaultConfigure.currentEpc);
        filter_mem_bank_spinner.setSelection(1);//默认EPC
        filter_address_edittext.setText("2");
        filter_mem_bank_spinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
            @Override
            public void onItemSelected(AdapterView<?> adapterView, View view, int i, long l) {
                if(i == 1)
                    filter_address_edittext.setText("2");
                else
                    filter_address_edittext.setText("0");
            }

            @Override
            public void onNothingSelected(AdapterView<?> adapterView) {

            }
        });


        rw_mem_bank_write_spinner = findViewById(R.id.rw_mem_bank_write_spinner);
        rw_mem_bank_write_spinner.setSelection(1);//默认选择EPC
        rw_password_write_edittext = findViewById(R.id.rw_password_write_edittext);
        rw_address_write_edittext = findViewById(R.id.rw_address_write_edittext);
        rw_data_write_edittext = findViewById(R.id.rw_data_write_edittext);
        rw_write_rsp_text = findViewById(R.id.rw_write_rsp_text);
        rw_write_btn = findViewById(R.id.rw_write_btn);

        rw_mem_bank_write_spinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
            @Override
            public void onItemSelected(AdapterView<?> adapterView, View view, int i, long l) {
                if(i == 1)
                    rw_address_write_edittext.setText("2");
                else
                    rw_address_write_edittext.setText("0");
            }

            @Override
            public void onNothingSelected(AdapterView<?> adapterView) {

            }
        });

        rw_write_btn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                if(!setFilter()){
                    ReadWriteLockActivity.this.runOnUiThread(new Runnable() {
                        @Override
                        public void run() {
                            Toast.makeText(getApplicationContext(),"设置过滤失败！",Toast.LENGTH_SHORT).show();
                        }
                    });

                    return;
                }

                int wbank = 0;//要写的分区
                switch (rw_mem_bank_write_spinner.getSelectedItemPosition()){
                    case 0://write reserved
                        wbank = InventoryModeParams.BANK.Reserved;//写入分区是reserved(保留区)
                        break;
                    case 1://write epc
                        //写epc （1），起始块 2  块数 6
                        wbank = InventoryModeParams.BANK.EPC;//写入分区是EPC
                        break;
                    case 2://write user.because tid cannot be writed,so skip tip
                        //写user （3），起始块 0  块数 6
                        wbank = InventoryModeParams.BANK.USER;//写入分区是USER,由于TID不能写，所以列表中没有TID
                        break;
                }
                int write_startaddr = Integer.valueOf(rw_address_write_edittext.getText().toString().trim());
                byte[] wpaswd = new byte[rw_password_write_edittext.getText().length()/2];
                UHFUtils.Str2Hex(rw_password_write_edittext.getText().toString(), rw_password_write_edittext.getText().toString().length(), wpaswd);
                String wdataString = rw_data_write_edittext.getText().toString();
                byte[] wdata = new byte[wdataString.length()/2];//写入存放的存储空间
                UHFUtils.Str2Hex(wdataString, wdataString.length(), wdata);
                int trycount = 3;
                Reader.READER_ERR er = null;
                do {
                    er = UHFEngine.getEngine().writeTagData(1,
                            (char) wbank,
                            write_startaddr,
                            wdata,
                            wdata.length,
                            wpaswd,
                            (short) 1000);

                    trycount--;
                    if (trycount < 1)
                        break;
                } while (er != Reader.READER_ERR.MT_OK_ERR);
                resetFilter();//恢复过滤
                if (er == Reader.READER_ERR.MT_OK_ERR) {
                    //Log.e("###","TID:"+Util.bytes2hex(rdata));
                    ReadWriteLockActivity.this.runOnUiThread(new Runnable() {
                        @Override
                        public void run() {
                            //rw_read_rsp_text.setText(Util.bytes2hex(rdata).toUpperCase(Locale.ROOT));
                            Toast.makeText(getApplicationContext(),"Write success!",Toast.LENGTH_SHORT).show();
                        }
                    });

                }else{
                    ReadWriteLockActivity.this.runOnUiThread(new Runnable() {
                        @Override
                        public void run() {
                            Toast.makeText(getApplicationContext(),"Write failed!",Toast.LENGTH_SHORT).show();
                        }
                    });
                }
            }

        });

        lock_item_spinner = findViewById(R.id.lock_item_spinner);

        lock_type_spinner = findViewById(R.id.lock_type_spinner);

        rw_password_lock_edittext = findViewById(R.id.rw_password_lock_edittext);
        rw_lock_btn = findViewById(R.id.rw_lock_btn);
        rw_lock_btn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {

                AlertDialog.Builder builder = new AlertDialog.Builder(ReadWriteLockActivity.this);
                builder.setTitle(R.string.warning); // 设置对话框标题
                builder.setMessage(R.string.lockwarning); // 设置对话框内容
                builder.setPositiveButton(R.string.commit, new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        Reader.Lock_Obj lobj = null;
                        Reader.Lock_Type ltyp = null;
                        int lbank = lock_item_spinner.getSelectedItemPosition();
                        int ltype = lock_type_spinner.getSelectedItemPosition();
                        if (lbank == 0) {
                            lobj = Reader.Lock_Obj.LOCK_OBJECT_ACCESS_PASSWD;
                            if (ltype == 0)
                                ltyp = Reader.Lock_Type.ACCESS_PASSWD_UNLOCK;
                            else if (ltype == 1)
                                ltyp = Reader.Lock_Type.ACCESS_PASSWD_LOCK;
                            else if (ltype == 2)
                                ltyp = Reader.Lock_Type.ACCESS_PASSWD_PERM_LOCK;

                        } else if (lbank == 1) {
                            lobj = Reader.Lock_Obj.LOCK_OBJECT_KILL_PASSWORD;
                            if (ltype == 0)
                                ltyp = Reader.Lock_Type.KILL_PASSWORD_UNLOCK;
                            else if (ltype == 1)
                                ltyp = Reader.Lock_Type.KILL_PASSWORD_LOCK;
                            else if (ltype == 2)
                                ltyp = Reader.Lock_Type.KILL_PASSWORD_PERM_LOCK;
                        } else if (lbank == 2) {
                            lobj = Reader.Lock_Obj.LOCK_OBJECT_BANK1;
                            if (ltype == 0)
                                ltyp = Reader.Lock_Type.BANK1_UNLOCK;
                            else if (ltype == 1)
                                ltyp = Reader.Lock_Type.BANK1_LOCK;
                            else if (ltype == 2)
                                ltyp = Reader.Lock_Type.BANK1_PERM_LOCK;
                        } else if (lbank == 3) {
                            lobj = Reader.Lock_Obj.LOCK_OBJECT_BANK2;
                            if (ltype == 0)
                                ltyp = Reader.Lock_Type.BANK2_UNLOCK;
                            else if (ltype == 1)
                                ltyp = Reader.Lock_Type.BANK2_LOCK;
                            else if (ltype == 2)
                                ltyp = Reader.Lock_Type.BANK2_PERM_LOCK;
                        } else if (lbank == 4) {
                            lobj = Reader.Lock_Obj.LOCK_OBJECT_BANK3;
                            if (ltype == 0)
                                ltyp = Reader.Lock_Type.BANK3_UNLOCK;
                            else if (ltype == 1)
                                ltyp = Reader.Lock_Type.BANK3_LOCK;
                            else if (ltype == 2)
                                ltyp = Reader.Lock_Type.BANK3_PERM_LOCK;
                        }

                        byte[] lockpaswd = new byte[4];

                        if (!rw_password_lock_edittext.getText().toString().equals("")) {
                            UHFUtils.Str2Hex(rw_password_lock_edittext.getText().toString(),
                                    rw_password_lock_edittext.getText().toString().length(), lockpaswd);
                        }
                        if(!setFilter()){
                            ReadWriteLockActivity.this.runOnUiThread(new Runnable() {
                                @Override
                                public void run() {
                                    Toast.makeText(getApplicationContext(),"设置过滤失败！",Toast.LENGTH_SHORT).show();
                                }
                            });

                            return;
                        }
                        Reader.READER_ERR er = UHFEngine.getEngine().lockTag(
                                1,
                                (byte) lobj.value(),
                                (short) ltyp.value(),
                                lockpaswd,
                                (short) 1000);
                        if (er == Reader.READER_ERR.MT_OK_ERR) {
                            ReadWriteLockActivity.this.runOnUiThread(new Runnable() {
                                @Override
                                public void run() {
                                    Toast.makeText(getApplicationContext(),"Lock Success!",Toast.LENGTH_SHORT).show();
                                }
                            });

                        } else {
                            ReadWriteLockActivity.this.runOnUiThread(new Runnable() {
                                @Override
                                public void run() {
                                    Toast.makeText(getApplicationContext(),"Lock failed!",Toast.LENGTH_SHORT).show();
                                }
                            });
                        }
                        resetFilter();
                    }
                });
                builder.setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        dialog.cancel();
                    }
                });

                AlertDialog alertDialog = builder.create();
                alertDialog.show(); // 显示对话框


            }
        });

        rw_password_kill_edittext = findViewById(R.id.rw_password_kill_edittext);
        rw_kill_btn = findViewById(R.id.rw_kill_btn);
        rw_kill_btn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {


                    AlertDialog.Builder builder = new AlertDialog.Builder(ReadWriteLockActivity.this);
                    builder.setTitle(R.string.warning); // 设置对话框标题
                    builder.setMessage(R.string.killwarning); // 设置对话框内容
                    builder.setPositiveButton(R.string.commit, new DialogInterface.OnClickListener() {
                        @Override
                        public void onClick(DialogInterface dialog, int which) {
                            byte[] killpaswd = new byte[4];

                            if (!rw_password_kill_edittext.getText().toString().equals("")) {
                                UHFUtils.Str2Hex(rw_password_kill_edittext.getText().toString(),
                                        rw_password_kill_edittext.getText().toString().length(), killpaswd);
                            }
                            if(!setFilter()){
                                ReadWriteLockActivity.this.runOnUiThread(new Runnable() {
                                    @Override
                                    public void run() {
                                        Toast.makeText(getApplicationContext(),"设置过滤失败！",Toast.LENGTH_SHORT).show();
                                    }
                                });

                                return;
                            }
                            Reader.READER_ERR er = UHFEngine.getEngine().killTag(
                                    1,
                                    killpaswd,
                                    (short) 1000);

                            if (er == Reader.READER_ERR.MT_OK_ERR) {
                                ReadWriteLockActivity.this.runOnUiThread(new Runnable() {
                                    @Override
                                    public void run() {
                                        Toast.makeText(getApplicationContext(),"Kill success!",Toast.LENGTH_SHORT).show();
                                    }
                                });
                            } else {
                                ReadWriteLockActivity.this.runOnUiThread(new Runnable() {
                                    @Override
                                    public void run() {
                                        Toast.makeText(getApplicationContext(),"Kill failed!",Toast.LENGTH_SHORT).show();
                                    }
                                });
                            }
                            resetFilter();
                        }
                    });
                    builder.setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {
                        @Override
                        public void onClick(DialogInterface dialog, int which) {
                            dialog.cancel();
                        }
                    });

                    AlertDialog alertDialog = builder.create();
                    alertDialog.show(); // 显示对话框
                }

        });
    }

    private boolean setFilter(){
        //int readlength = Integer.valueOf(rw_read_length_edittext.getText().toString().trim());
        //int startaddr = Integer.valueOf(rw_address_read_edittext.getText().toString().trim());
        int blocks = Integer.valueOf(rw_read_length_edittext.getText().toString().trim());
        //byte[] rpaswd = new byte[rw_password_read_edittext.getText().length()/2];
        //UHFUtils.Str2Hex(rw_password_read_edittext.getText().toString(), rw_password_read_edittext.getText().toString().length(), rpaswd);

        byte[] rdata = new byte[blocks*2];//读取存放的存储空间

        Reader.TagFilter_ST g2tf = new Reader.TagFilter_ST();//创建过滤器
        //转换成字节数组
        if(filterdata_edittext.getText().toString().length() == 0 || filterdata_edittext.getText().toString().length()%2 != 0){
            return false;
        }
        byte[] fdata = new byte[filterdata_edittext.getText().toString().length() / 2];
        UHFUtils.Str2Hex(filterdata_edittext.getText().toString(), filterdata_edittext.getText().toString().length(), fdata);

        g2tf.fdata = fdata;
        g2tf.flen = fdata.length * 8;//长度单位是bit，所以用字节数乘以8
        g2tf.isInvert = 0;

        //g2tf.bank = InventoryModeParams.BANK.EPC;//设置过滤的分区为EPC
        g2tf.bank = filter_mem_bank_spinner.getSelectedItemPosition();
        //g2tf.startaddr = 32;//开始地址，EPC分区前32个bit是PC等数据，所以跳过前32个bit

        g2tf.startaddr = Integer.valueOf(filter_address_edittext.getText().toString())*2*8;//一个块2个字节，每个字节8个bit


        Reader.READER_ERR er = UHFParamsOperator.getInstance().setTagFilter(g2tf);//设置过滤条件
        if (er == Reader.READER_ERR.MT_OK_ERR) {
            Log.e("###","设置过滤成功！");
            return true;
        }
        return false;
    }
    private void resetFilter(){
        UHFParamsOperator.getInstance().setTagFilter(null);//读取完毕，恢复过滤设置为null
    }

    protected void onResume() {
        //上电
        UHFEngine.getEngine().powerOn();
        //连接模块
        Reader.READER_ERR er = UHFEngine.getEngine().connectModule(DefaultConfigure.UART_DEV_PATH, 1);
        if(er == Reader.READER_ERR.MT_OK_ERR){
            DefaultConfigure.defaultInitModule();
            //AntPowerConfResult result = UHFParamsOperator.getInstance().getAntPowerConf();
            Log.e("####","connect success!");
        }else{
            Log.e("####","connect failed!");

        }
        super.onResume();
    }

    @Override
    protected void onPause() {
        //断开连接
        UHFEngine.getEngine().disconnectModule();
        //下电
        UHFEngine.getEngine().powerOff();
        super.onPause();
    }

}
```

