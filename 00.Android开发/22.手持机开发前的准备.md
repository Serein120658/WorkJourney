# 智慧仓库手持机开发文档

本文档记录手持机RFID功能的集成开发流程,包括原生插件接入、UHF模块封装和扫码模块配置。手持机配备UHF超高频模块和扫码模块,用于货物标签读取、批量盘点和精准定位。

------

## 一、原生插件接入到uni-app项目

### 配置步骤

1. 将nativeplugins目录下的所有内容复制到项目根目录
2. 打开manifest.json文件,找到`"distribute":{}"`配置节点
3. 在其下方插入以下插件配置:

```json
"nativePlugins" : {
    "UniUHF" : {
        "__plugin_info__" : {
            "name" : "UniUHF",
            "description" : "UHF SDK",
            "platforms" : "Android",
            ...
        }
    },
    "UniScan" : {
        "__plugin_info__" : {
            "name" : "UniScan", 
            "description" : "Uni Scan SDK",
            "platforms" : "Android",
            ...
        }
    }
}
```

### 插件说明

- **UniUHF插件**: 超高频RFID标签读写,用于货物标签扫描、盘点、查找
- **UniScan插件**: 一维/二维码扫描,用于条码识别
- 两个插件仅支持Android平台,`isCloud`必须设置为`false`

![image-20251107173708115](22.手持机开发前的准备.assets/image-20251107173708115.png)

------

## 二、打包自定义基座

原生插件无法在标准基座中运行,需要打包自定义基座才能在真机上调试。打包后可以实时测试硬件交互(按键、广播)和验证插件配置。

详细打包步骤参考项目文档`07.真机连接`,主要流程:

1. HBuilderX选择"发行" -> "原生App-制作自定义调试基座"
2. 选择Android平台并配置应用标识
3. 等待云端打包完成并安装到测试设备

**注意**: 每次修改插件配置后需重新打包基座

------

## 三、UHF超高频模块

### 模块概述

UHF(Ultra High Frequency)工作频段为860-960MHz,具有读取距离远(最远10米)、读取速度快(每秒数百个标签)、支持批量识别等特点。封装的UHFManager类采用单例模式,统一管理设备生命周期和操作。

### 封装后的代码

```js
/**
 * UHF超高频模块管理器
 * 封装UHF设备的初始化、广播注册、扫描控制等功能
 */

const plugin = uni.requireNativePlugin('UniUHF');

class UHFManager {
	constructor() {
		this.isInitialized = false;
		this.isScanning = false;
		this.main = null;
		this.receiver = null;
		this.filter = null;
		this.onTagDataCallback = null;
		this.onKeyScanCallback = null;
		this.currentConfig = null;
	}

	/**
	 * 初始化UHF模块
	 * @param {Object} config - 配置参数
	 * @param {Number} config.power - 功率 (0-3300)
	 * @param {Number} config.zone - 区域代码 (6=中国)
	 * @param {Number} config.inventoryMode - 盘点模式 (0=单标签, 1=正常, 2=快速)
	 * @param {Number} config.session - Session (0=动态, 1=静态)
	 * @param {Boolean} config.audioTip - 是否开启提示音
	 * @returns {Boolean} 初始化是否成功
	 */
	init(config) {
		if (this.isInitialized) {
			console.warn('UHF已经初始化，跳过重复初始化');
			return true;
		}

		const result = plugin.initUHFManager();
		
		if (result === 1 || result === true) {
			this.isInitialized = true;
			this.currentConfig = config;
			
			// 应用配置
			this.applyConfig(config);
			
			// 注册广播接收器
			this.registerReceiver();
			
			console.log('UHF初始化成功，配置:', config);
			return true;
		} else {
			console.error('UHF初始化失败');
			return false;
		}
	}

	/**
	 * 应用UHF配置
	 * @param {Object} config - 配置参数
	 */
	applyConfig(config) {
		if (!this.isInitialized) {
			console.error('UHF未初始化，无法应用配置');
			return;
		}

		try {
			plugin.setUHFPower(config.power || 3300);
			plugin.setUHFZone(config.zone || 6);
			plugin.setUHFInventoryMode(config.inventoryMode || 2);
			plugin.setUHFSession(config.session || 1);
			plugin.setAudioTip(config.audioTip !== false);
			
			this.currentConfig = config;
			console.log('UHF配置已应用:', config);
		} catch (error) {
			console.error('应用UHF配置失败:', error);
		}
	}

	/**
	 * 反初始化UHF模块
	 */
	uninit() {
		if (!this.isInitialized) return;

		// 先停止扫描
		this.stopScan();
		
		// 注销广播接收器
		this.unregisterReceiver();
		
		// 反初始化模块
		if (plugin) {
			plugin.uninitUHFManager();
			console.log('UHF已反初始化');
		}
		
		this.isInitialized = false;
		this.currentConfig = null;
	}

	/**
	 * 注册广播接收器
	 */
	registerReceiver() {
		// #ifdef APP-PLUS
		try {
			this.main = plus.android.runtimeMainActivity();
			
			const IntentFilter = plus.android.importClass('android.content.IntentFilter');
			this.filter = new IntentFilter();
			this.filter.addAction("com.pda.keycode.broacast");
			this.filter.addAction("uni.pda.uhf.data");
			
			const _this = this;
			this.receiver = plus.android.implements('io.dcloud.feature.internal.reflect.BroadcastReceiver', {
				onReceive: function(context, intent) {
					plus.android.importClass(intent);
					const action = intent.getAction();
					
					// 处理按键广播
					if (action === "com.pda.keycode.broacast") {
						const keycode = intent.getIntExtra("keycode", 0);
						const isKeyDown = intent.getBooleanExtra("isdown", false);
						
						// 手柄按键292
						if (keycode === 292) {
							if (_this.onKeyScanCallback) {
								_this.onKeyScanCallback(isKeyDown);
							}
						}
					}
					// 处理标签数据广播
					else if (action === "uni.pda.uhf.data") {
						const uhfdata = intent.getStringExtra("uhfdata");
						if (_this.onTagDataCallback) {
							_this.onTagDataCallback(uhfdata);
						}
					}
				}
			});
			
			this.main.registerReceiver(this.receiver, this.filter);
			console.log('广播接收器已注册');
		} catch (error) {
			console.error('注册广播接收器失败:', error);
		}
		// #endif
	}

	/**
	 * 注销广播接收器
	 */
	unregisterReceiver() {
		// #ifdef APP-PLUS
		try {
			if (this.main && this.receiver) {
				this.main.unregisterReceiver(this.receiver);
				this.receiver = null;
				this.filter = null;
				console.log('广播接收器已注销');
			}
		} catch (error) {
			console.error('注销广播接收器失败:', error);
		}
		// #endif
	}

	/**
	 * 开始扫描
	 * @returns {Boolean} 是否成功启动
	 */
	startScan() {
		if (!this.isInitialized) {
			console.error('UHF未初始化');
			return false;
		}

		if (this.isScanning) {
			console.warn('已经在扫描中');
			return true;
		}

		try {
			const result = plugin.startInventory();
			if (result) {
				this.isScanning = true;
				console.log('开始盘点');
				return true;
			} else {
				console.error('启动盘点失败');
				return false;
			}
		} catch (error) {
			console.error('启动扫描异常:', error);
			return false;
		}
	}

	/**
	 * 停止扫描
	 * @returns {Boolean} 是否成功停止
	 */
	stopScan() {
		if (!this.isScanning) {
			return true;
		}

		try {
			const result = plugin.stopInventory();
			if (result) {
				this.isScanning = false;
				console.log('停止盘点');
				return true;
			} else {
				console.error('停止盘点失败');
				return false;
			}
		} catch (error) {
			console.error('停止扫描异常:', error);
			return false;
		}
	}

	/**
	 * 设置标签数据回调
	 * @param {Function} callback - 回调函数 (uhfdata) => {}
	 */
	setOnTagDataCallback(callback) {
		this.onTagDataCallback = callback;
	}

	/**
	 * 设置按键扫描回调
	 * @param {Function} callback - 回调函数 (isKeyDown) => {}
	 */
	setOnKeyScanCallback(callback) {
		this.onKeyScanCallback = callback;
	}

	/**
	 * 获取当前配置
	 * @returns {Object} 当前配置
	 */
	getCurrentConfig() {
		return this.currentConfig;
	}

	/**
	 * 检查是否已初始化
	 * @returns {Boolean}
	 */
	isReady() {
		return this.isInitialized;
	}

	/**
	 * 检查是否正在扫描
	 * @returns {Boolean}
	 */
	isScanningNow() {
		return this.isScanning;
	}
}

// 导出单例
export default new UHFManager();
```

### 核心功能

#### 初始化与配置

`init(config)` - 初始化UHF模块并应用配置参数

- **config.power**: 发射功率(0-3300),影响读取距离
- **config.zone**: 区域代码(6=中国)
- **config.inventoryMode**: 盘点模式(0=单标签,1=正常,2=快速)
- **config.session**: Session模式(0=动态/移动标签,1=静态/静止标签)
- **config.audioTip**: 是否开启提示音

初始化时会自动注册广播接收器,监听手柄按键(keycode 292)和标签数据。

#### 扫描控制

`startScan()` - 开始盘点标签,设备开始发射射频信号 `stopScan()` - 停止盘点,结束扫描

扫描过程中通过广播接收标签数据,数据格式为EPC编码字符串。

#### 数据回调

`setOnTagDataCallback(callback)` - 设置标签数据回调,参数为标签的EPC编码 `setOnKeyScanCallback(callback)` - 设置按键回调,参数为按键状态(按下/释放)

通过回调函数可以实时处理扫描到的标签数据和响应按键操作。

#### 广播机制

系统通过Android广播机制传递数据:

- `com.pda.keycode.broacast` - 按键事件广播(手柄按键keycode=292)
- `uni.pda.uhf.data` - 标签数据广播(携带uhfdata字段)

UHFManager内部使用plus.android注册BroadcastReceiver监听这两个广播,并转换为JavaScript回调。

#### 生命周期管理

`uninit()` - 反初始化模块,会自动停止扫描、注销广播接收器、释放资源

------

## 四、场景配置管理

### 配置管理器概述

ConfigManager管理不同业务场景下的UHF配置参数,提供预设场景和自定义配置功能。配置数据持久化存储在本地,支持场景快速切换。

### 封装后的代码

```js
/**
 * UHF配置管理器
 * 管理不同场景下的UHF配置参数
 */

// 功率与距离对照表（近似值，实际会受环境影响）
const POWER_DISTANCE_MAP = [
	{ power: 500, distance: 0.01 }, // 与实际场景对比
	{ power: 1000, distance: 0.1 },
	{ power: 1500, distance: 0.15 },
	{ power: 2000, distance: 0.2 },
	{ power: 2200, distance: 0.22 },
	{ power: 2500, distance: 0.3 },
	{ power: 2800, distance: 0.4 },
	{ power: 3000, distance: 0.8 },
	{ power: 3300, distance: 1.0 }
];

// 预设场景配置
const PRESET_SCENES = {
	// 盘库场景 - 大功率、多标签、快速模式
	inventory: {
		name: '盘库',
		description: '适用于仓库盘点，大范围多标签扫描',
		power: 3300,
		zone: 6,
		inventoryMode: 2,  // 快速模式
		session: 1,        // 静态Session，适合大量静止标签
		audioTip: true
	},
	
	// 入库场景 - 中功率、批量绑定
	inbound: {
		name: '入库',
		description: '批量标签与货物关联',
		power: 2500,
		zone: 6,
		inventoryMode: 1,  // 正常模式
		session: 0,        // 动态Session
		audioTip: true
	},
	
	// 出库场景 - 中功率、验证模式
	outbound: {
		name: '出库',
		description: '验证标签并清零EPC',
		power: 2500,
		zone: 6,
		inventoryMode: 1,  // 正常模式
		session: 0,
		audioTip: true
	},
	
	// 查找场景 - 小功率、单标签、精确定位
	search: {
		name: '查找',
		description: '精确定位单个标签',
		power: 1500,
		zone: 6,
		inventoryMode: 0,  // 单标签模式
		session: 0,
		audioTip: true
	},
	
	// 验货场景 - 中等功率
	verify: {
		name: '验货',
		description: '货物验收检查',
		power: 2200,
		zone: 6,
		inventoryMode: 1,
		session: 0,
		audioTip: true
	}
};

const CONFIG_STORAGE_KEY = 'uhf_scene_configs';
const CURRENT_SCENE_KEY = 'uhf_current_scene';

class ConfigManager {
	constructor() {
		this.configs = {};
		this.currentScene = 'inventory';
		this.loadConfigs();
	}

	/**
	 * 加载配置
	 */
	loadConfigs() {
		try {
			// 从本地存储加载自定义配置
			const savedConfigs = uni.getStorageSync(CONFIG_STORAGE_KEY);
			const currentScene = uni.getStorageSync(CURRENT_SCENE_KEY);
			
			if (savedConfigs) {
				this.configs = JSON.parse(savedConfigs);
			} else {
				// 首次使用，使用预设配置
				this.configs = JSON.parse(JSON.stringify(PRESET_SCENES));
				this.saveConfigs();
			}
			
			if (currentScene) {
				this.currentScene = currentScene;
			}
			
			console.log('配置加载成功:', this.configs);
		} catch (error) {
			console.error('加载配置失败:', error);
			// 使用默认配置
			this.configs = JSON.parse(JSON.stringify(PRESET_SCENES));
		}
	}

	/**
	 * 保存配置
	 */
	saveConfigs() {
		try {
			uni.setStorageSync(CONFIG_STORAGE_KEY, JSON.stringify(this.configs));
			console.log('配置保存成功');
		} catch (error) {
			console.error('保存配置失败:', error);
		}
	}

	/**
	 * 保存当前场景
	 */
	saveCurrentScene() {
		try {
			uni.setStorageSync(CURRENT_SCENE_KEY, this.currentScene);
		} catch (error) {
			console.error('保存当前场景失败:', error);
		}
	}

	/**
	 * 获取场景配置
	 * @param {String} scene - 场景名称
	 * @returns {Object} 配置对象
	 */
	getConfig(scene) {
		return this.configs[scene] || this.configs.inventory;
	}

	/**
	 * 获取当前场景配置
	 * @returns {Object} 配置对象
	 */
	getCurrentConfig() {
		return this.getConfig(this.currentScene);
	}

	/**
	 * 设置场景配置
	 * @param {String} scene - 场景名称
	 * @param {Object} config - 配置对象
	 */
	setConfig(scene, config) {
		this.configs[scene] = {
			...this.configs[scene],
			...config
		};
		this.saveConfigs();
	}

	/**
	 * 切换当前场景
	 * @param {String} scene - 场景名称
	 */
	setCurrentScene(scene) {
		if (this.configs[scene]) {
			this.currentScene = scene;
			this.saveCurrentScene();
			console.log('切换场景:', scene);
		} else {
			console.error('场景不存在:', scene);
		}
	}

	/**
	 * 获取当前场景名称
	 * @returns {String}
	 */
	getCurrentScene() {
		return this.currentScene;
	}

	/**
	 * 获取所有场景列表
	 * @returns {Array}
	 */
	getAllScenes() {
		return Object.keys(this.configs).map(key => ({
			key: key,
			...this.configs[key]
		}));
	}

	/**
	 * 重置场景配置为预设值
	 * @param {String} scene - 场景名称
	 */
	resetConfig(scene) {
		if (PRESET_SCENES[scene]) {
			this.configs[scene] = JSON.parse(JSON.stringify(PRESET_SCENES[scene]));
			this.saveConfigs();
		}
	}

	/**
	 * 重置所有配置
	 */
	resetAllConfigs() {
		this.configs = JSON.parse(JSON.stringify(PRESET_SCENES));
		this.saveConfigs();
	}

	/**
	 * 功率转距离（米）
	 * @param {Number} power - 功率值 (0-3300)
	 * @returns {Number} 距离（米）
	 */
	powerToDistance(power) {
		// 线性插值计算
		for (let i = 0; i < POWER_DISTANCE_MAP.length - 1; i++) {
			const current = POWER_DISTANCE_MAP[i];
			const next = POWER_DISTANCE_MAP[i + 1];
			
			if (power >= current.power && power <= next.power) {
				const ratio = (power - current.power) / (next.power - current.power);
				return (current.distance + (next.distance - current.distance) * ratio).toFixed(1);
			}
		}
		
		// 超出范围
		if (power < POWER_DISTANCE_MAP[0].power) {
			return POWER_DISTANCE_MAP[0].distance.toFixed(1);
		}
		return POWER_DISTANCE_MAP[POWER_DISTANCE_MAP.length - 1].distance.toFixed(1);
	}

	/**
	 * 距离转功率
	 * @param {Number} distance - 距离（米）
	 * @returns {Number} 功率值
	 */
	distanceToPower(distance) {
		// 线性插值计算
		for (let i = 0; i < POWER_DISTANCE_MAP.length - 1; i++) {
			const current = POWER_DISTANCE_MAP[i];
			const next = POWER_DISTANCE_MAP[i + 1];
			
			if (distance >= current.distance && distance <= next.distance) {
				const ratio = (distance - current.distance) / (next.distance - current.distance);
				return Math.round(current.power + (next.power - current.power) * ratio);
			}
		}
		
		// 超出范围
		if (distance < POWER_DISTANCE_MAP[0].distance) {
			return POWER_DISTANCE_MAP[0].power;
		}
		return POWER_DISTANCE_MAP[POWER_DISTANCE_MAP.length - 1].power;
	}

	/**
	 * 获取功率距离对照表
	 * @returns {Array}
	 */
	getPowerDistanceMap() {
		return POWER_DISTANCE_MAP;
	}

	/**
	 * 获取盘点模式说明
	 * @param {Number} mode - 模式值
	 * @returns {String}
	 */
	getInventoryModeDesc(mode) {
		const modes = {
			0: '单标签模式 - 适合精确查找',
			1: '正常模式 - 平衡速度和准确性',
			2: '快速模式 - 适合大批量扫描'
		};
		return modes[mode] || '未知模式';
	}

	/**
	 * 获取Session说明
	 * @param {Number} session - Session值
	 * @returns {String}
	 */
	getSessionDesc(session) {
		const sessions = {
			0: 'Session 0 - 适合移动标签',
			1: 'Session 1 - 适合静止标签'
		};
		return sessions[session] || '未知Session';
	}
}

// 导出单例
export default new ConfigManager();
```

### 预设场景   

系统内置5种典型业务场景,每种场景有最优配置参数:

**盘库场景(inventory)**

- 功率: 3300(最大功率,读取距离约1米)
- 盘点模式: 快速模式(2)
- Session: 静态(1)
- 用途: 仓库大范围盘点,快速扫描大量静止标签

**入库场景(inbound)**

- 功率: 2500(中等功率,读取距离约0.3米)
- 盘点模式: 正常模式(1)
- Session: 动态(0)
- 用途: 批量标签与货物关联绑定

**出库场景(outbound)**

- 功率: 2500(中等功率)
- 盘点模式: 正常模式(1)
- Session: 动态(0)
- 用途: 验证标签并清零EPC

**查找场景(search)**

- 功率: 1500(低功率,读取距离约0.15米)
- 盘点模式: 单标签模式(0)
- Session: 动态(0)
- 用途: 精确定位单个标签,避免误读

**验货场景(verify)**

- 功率: 2200(中等功率,读取距离约0.22米)
- 盘点模式: 正常模式(1)
- Session: 动态(0)
- 用途: 货物验收检查

### 功率与距离对照

功率值与实际读取距离的对应关系(受环境影响会有偏差):

| 功率值 | 读取距离 |
| ------ | -------- |
| 500    | 0.01米   |
| 1000   | 0.1米    |
| 1500   | 0.15米   |
| 2000   | 0.2米    |
| 2500   | 0.3米    |
| 3000   | 0.8米    |
| 3300   | 1.0米    |

ConfigManager提供`powerToDistance()`和`distanceToPower()`方法进行功率与距离的相互转换。

### 配置持久化

配置数据使用uni.storage存储在本地:

- `uhf_scene_configs` - 存储所有场景配置
- `uhf_current_scene` - 存储当前选中场景

首次使用时自动初始化为预设配置,后续修改会实时保存。

### 核心方法

`getConfig(scene)` - 获取指定场景配置 `getCurrentConfig()` - 获取当前场景配置 `setConfig(scene, config)` - 更新场景配置并保存 `setCurrentScene(scene)` - 切换当前场景 `getAllScenes()` - 获取所有场景列表 `resetConfig(scene)` - 重置场景为预设值 `resetAllConfigs()` - 重置所有场景为预设值

### 使用示例

```javascript
import ConfigManager from '@/utils/ConfigManager'
import UHFManager from '@/utils/UHFManager'

// 切换到盘库场景
ConfigManager.setCurrentScene('inventory')
const config = ConfigManager.getCurrentConfig()
UHFManager.init(config)

// 自定义修改当前场景功率
const newConfig = { ...config, power: 2800 }
ConfigManager.setConfig('inventory', newConfig)
UHFManager.applyConfig(newConfig)
```

------

## 五、SCAN扫码模块

### 模块说明

UniScan插件支持一维码和二维码扫描,适用于商品条码、二维码标签等场景。

### 功能封装

```js
/**
 * 扫码模块管理器
 * 封装UniScan插件的初始化、按键监听、数据回调、灯光控制等功能
 */

const plugin = uni.requireNativePlugin('UniScan');

class ScanManager {
	constructor() {
		this.isInitialized = false;
		this.isScanning = false;
		this.lightsOn = false;
		
		// 配置参数
		this.config = {
			vibrate: true,
			sound: true,
			scanInterval: 500,
			autoFocusInput: true
		};
		
		// 回调函数
		this.onScanCallback = null;
		this.onKeyScanCallback = null;
		
		// 防抖相关
		this.lastScanData = '';
		this.lastScanTime = 0;
		
		// Android广播相关
		this.main = null;
		this.receiver = null;
		this.filter = null;
		
		// 输入框相关
		this.scanInputTimer = null;
		this.refocusTimer = null;
		this.inputFocused = false;
		this.scanInputValue = '';
	}

	/**
	 * 初始化扫码模块
	 * @param {Object} config - 配置参数
	 * @param {Boolean} config.vibrate - 是否震动反馈
	 * @param {Boolean} config.sound - 是否提示音
	 * @param {Number} config.scanInterval - 防抖间隔(毫秒)
	 * @param {Boolean} config.autoFocusInput - 是否自动聚焦输入框
	 * @returns {Boolean} 初始化是否成功
	 */
	init(config = {}) {
		if (this.isInitialized) {
			console.warn('扫码模块已初始化,跳过重复初始化');
			return true;
		}

		try {
			// 检查扫码功能是否可用
			const result = plugin.isOpenScan();
			
			if (!result) {
				console.error('扫码功能未开启');
				uni.showToast({
					title: '扫码功能不可用',
					icon: 'none'
				});
				return false;
			}

			// 合并配置
			this.config = { ...this.config, ...config };
			
			// 应用配置
			plugin.setDecodeTipVibrator(this.config.vibrate);
			
			// 注册按键监听
			this.registerKeyListener();
			
			this.isInitialized = true;
			console.log('✓ 扫码模块初始化成功', this.config);
			return true;
			
		} catch (e) {
			console.error('✗ 初始化扫码模块失败:', e);
			return false;
		}
	}

	/**
	 * 注册手柄按键监听
	 */
	registerKeyListener() {
		// #ifdef APP-PLUS
		try {
			this.main = plus.android.runtimeMainActivity();
			const IntentFilter = plus.android.importClass('android.content.IntentFilter');
			
			this.filter = new IntentFilter();
			this.filter.addAction("com.pda.keycode.broacast");
			
			const _this = this;
			this.receiver = plus.android.implements('io.dcloud.feature.internal.reflect.BroadcastReceiver', {
				onReceive: function(context, intent) {
					plus.android.importClass(intent);
					const action = intent.getAction();
					
					if (action === "com.pda.keycode.broacast") {
						const keycode = intent.getIntExtra("keycode", 0);
						const isKeyDown = intent.getBooleanExtra("isdown", false);
						
						// 扫描键(292)
						if (keycode === 292) {
							_this.isScanning = isKeyDown;
							
							// 触发按键回调
							if (_this.onKeyScanCallback) {
								_this.onKeyScanCallback(isKeyDown);
							}
							
							// 按下时确保输入框聚焦
							if (isKeyDown && _this.config.autoFocusInput) {
								_this.focusInput();
							}
						}
					}
				}
			});
			
			this.main.registerReceiver(this.receiver, this.filter);
			console.log('✓ 按键监听已注册');
			
		} catch (e) {
			console.error('✗ 注册按键监听失败:', e);
		}
		// #endif
	}

	/**
	 * 注销按键监听
	 */
	unregisterKeyListener() {
		// #ifdef APP-PLUS
		try {
			if (this.main && this.receiver) {
				this.main.unregisterReceiver(this.receiver);
				this.main = null;
				this.receiver = null;
				this.filter = null;
				console.log('✓ 按键监听已注销');
			}
		} catch (e) {
			console.error('✗ 注销按键监听失败:', e);
		}
		// #endif
	}

	/**
	 * 处理扫码数据(带防抖)
	 * @param {String} scanData - 扫码数据
	 */
	handleScanData(scanData) {
		scanData = scanData.trim();
		
		if (!scanData) {
			return;
		}

		const now = Date.now();
		
		// 防抖处理
		if (scanData === this.lastScanData && 
			now - this.lastScanTime < this.config.scanInterval) {
			console.log('⊗ 忽略重复扫描(防抖)');
			return;
		}
		
		this.lastScanData = scanData;
		this.lastScanTime = now;
		
		// 触发回调
		if (this.onScanCallback) {
			this.onScanCallback(scanData);
		}
		
		// 提示音
		if (this.config.sound) {
			uni.showToast({
				title: '扫描成功',
				icon: 'success',
				duration: 800
			});
		}
		
		console.log('✓ 扫描数据:', scanData);
	}

	/**
	 * 输入框输入事件处理
	 * @param {Object} e - 事件对象
	 */
	onInput(e) {
		if (this.scanInputTimer) {
			clearTimeout(this.scanInputTimer);
		}
		
		const _this = this;
		// 等待输入完成后处理(扫码枪输入很快)
		this.scanInputTimer = setTimeout(() => {
			const value = e.detail.value.trim();
			if (value) {
				_this.handleScanData(value);
				_this.scanInputValue = ''; // 清空
			}
		}, 150);
	}

	/**
	 * 输入框确认事件处理
	 * @param {Object} e - 事件对象
	 */
	onConfirm(e) {
		const value = e.detail.value.trim();
		if (value) {
			this.handleScanData(value);
			this.scanInputValue = '';
		}
	}

	/**
	 * 输入框失焦处理
	 */
	onBlur() {
		if (!this.isInitialized || !this.config.autoFocusInput) {
			return;
		}
		
		if (this.refocusTimer) {
			clearTimeout(this.refocusTimer);
		}
		
		const _this = this;
		// 延迟重新聚焦
		this.refocusTimer = setTimeout(() => {
			_this.focusInput();
		}, 100);
	}

	/**
	 * 聚焦输入框并隐藏键盘
	 */
	focusInput() {
		this.inputFocused = true;
		
		// 立即隐藏键盘
		setTimeout(() => {
			// #ifdef APP-PLUS
			try {
				plus.key.hideSoftKeybord();
			} catch (e) {
				console.log('隐藏键盘失败:', e);
			}
			// #endif
		}, 50);
	}

	/**
	 * 确保输入框聚焦(用于页面点击)
	 */
	ensureInputFocus() {
		if (this.isInitialized && !this.inputFocused) {
			this.focusInput();
		}
	}

	/**
	 * 开启灯光
	 */
	turnOnLight() {
		try {
			plugin.setIllPowerLevel(5);
			plugin.setAim(true);
			this.lightsOn = true;
			console.log('✓ 灯光已开启');
		} catch (e) {
			console.error('✗ 开启灯光失败:', e);
		}
	}

	/**
	 * 关闭灯光
	 */
	turnOffLight() {
		try {
			plugin.setIllPowerLevel(0);
			plugin.setAim(false);
			this.lightsOn = false;
			console.log('✓ 灯光已关闭');
		} catch (e) {
			console.error('✗ 关闭灯光失败:', e);
		}
	}

	/**
	 * 切换灯光
	 */
	toggleLight() {
		if (this.lightsOn) {
			this.turnOffLight();
		} else {
			this.turnOnLight();
		}
		return this.lightsOn;
	}

	/**
	 * 设置扫码数据回调
	 * @param {Function} callback - 回调函数 (data) => {}
	 */
	setOnScanCallback(callback) {
		this.onScanCallback = callback;
	}

	/**
	 * 设置按键回调
	 * @param {Function} callback - 回调函数 (isKeyDown) => {}
	 */
	setOnKeyScanCallback(callback) {
		this.onKeyScanCallback = callback;
	}

	/**
	 * 获取当前配置
	 * @returns {Object} 当前配置
	 */
	getCurrentConfig() {
		return this.config;
	}

	/**
	 * 更新配置
	 * @param {Object} config - 新配置
	 */
	updateConfig(config) {
		this.config = { ...this.config, ...config };
		
		if (this.isInitialized) {
			plugin.setDecodeTipVibrator(this.config.vibrate);
		}
	}

	/**
	 * 检查是否已初始化
	 * @returns {Boolean}
	 */
	isReady() {
		return this.isInitialized;
	}

	/**
	 * 检查是否正在扫描
	 * @returns {Boolean}
	 */
	isScanningNow() {
		return this.isScanning;
	}

	/**
	 * 检查灯光状态
	 * @returns {Boolean}
	 */
	isLightOn() {
		return this.lightsOn;
	}

	/**
	 * 反初始化
	 */
	uninit() {
		if (!this.isInitialized) return;

		// 注销监听
		this.unregisterKeyListener();
		
		// 清除定时器
		if (this.scanInputTimer) {
			clearTimeout(this.scanInputTimer);
			this.scanInputTimer = null;
		}
		
		if (this.refocusTimer) {
			clearTimeout(this.refocusTimer);
			this.refocusTimer = null;
		}
		
		// 关闭灯光
		if (this.lightsOn) {
			this.turnOffLight();
		}
		
		// 重置状态
		this.inputFocused = false;
		this.isInitialized = false;
		this.isScanning = false;
		this.scanInputValue = '';
		
		console.log('✓ 扫码模块已反初始化');
	}
}

// 导出单例
export default new ScanManager();
```

## 附录

### 开发注意事项

1. **权限配置**: 确保manifest.json中配置了必要的Android权限(相机、存储等)
2. **设备兼容性**: 不同手持机厂商的广播action可能不同,需适配
3. **错误处理**: 所有硬件操作都应添加try-catch异常捕获
4. **资源释放**: 页面卸载时必须调用uninit()释放资源,避免内存泄漏
5. **并发控制**: 避免同时初始化多个UHF实例,使用单例模式

### 常见问题

**Q: 扫描不到标签?** A: 检查功率设置、标签是否在读取范围内、设备是否正确初始化

**Q: 标签重复读取?**
 A: 调整Session模式,静态标签使用Session 1,移动标签使用Session 0

**Q: 按键无响应?** A: 确认广播接收器已注册,检查keycode是否匹配设备

**Q: 自定义基座安装失败?** A: 检查应用签名、包名是否一致,确保卸载旧版本
