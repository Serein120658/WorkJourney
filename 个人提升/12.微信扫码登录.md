# 微信扫码登录完整实现指南

## 一、功能概述

微信扫码登录允许用户在移动应用内生成二维码，通过微信客户端扫描后登录应用。适用场景：

- 多设备登录
- 智能硬件
- 电视盒子
- 大屏设备

## 二、实现流程图

```
┌─────────────┐
│  APP发起授权  │
└──────┬──────┘
       │
       ▼
┌─────────────────┐
│ 后端生成签名参数  │
│ (signature等)   │
└──────┬──────────┘
       │
       ▼
┌─────────────────┐
│ 调用微信SDK获取  │
│    二维码图片    │
└──────┬──────────┘
       │
       ▼
┌─────────────────┐
│  APP展示二维码   │
└──────┬──────────┘
       │
       ▼
┌─────────────────┐
│ 用户微信扫描授权 │
└──────┬──────────┘
       │
       ▼
┌─────────────────┐
│ 回调返回authCode │
└──────┬──────────┘
       │
       ▼
┌─────────────────┐
│ 后端用authCode   │
│ 换取access_token │
└──────┬──────────┘
       │
       ▼
┌─────────────────┐
│   登录成功      │
└─────────────────┘
```

## 三、前置准备

### 3.1 微信开放平台配置

1. 在[微信开放平台](https://open.weixin.qq.com/)注册账号
2. 创建移动应用并通过审核
3. 获取 `AppID` 和 `AppSecret`
4. 配置应用包名和签名

### 3.2 集成微信SDK

根据平台选择对应SDK：

- iOS: 集成 WechatOpenSDK
- Android: 集成 libammsdk.jar
- uni-app: 使用官方插件或原生插件

## 四、后端实现

### 4.1 获取 sdk_ticket

**步骤1：获取 access_token**

```http
GET https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=APPID&secret=APPSECRET
```

返回示例：

```json
{
  "access_token": "ACCESS_TOKEN",
  "expires_in": 7200
}
```

**步骤2：获取 sdk_ticket**

```http
GET https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=ACCESS_TOKEN&type=2
```

返回示例：

```json
{
  "errcode": 0,
  "errmsg": "ok",
  "ticket": "sdk_ticket_string",
  "expires_in": 7200
}
```

⚠️ **注意事项：**

- sdk_ticket 有效期 7200 秒（2小时）
- 获取接口调用次数有限，需要缓存
- 建议在服务端维护 ticket 池，定时刷新

### 4.2 生成签名

**签名算法：**

```
1. 准备参数：appid, noncestr, sdk_ticket, timestamp
2. 按 ASCII 码排序：appid → noncestr → sdk_ticket → timestamp
3. 拼接字符串：key1=value1&key2=value2...
4. SHA1 加密生成 signature
```

#### **Node.js 示例代码：**

```javascript
const crypto = require('crypto');

function generateSignature(appid, noncestr, sdk_ticket, timestamp) {
  // 1. 参数排序并拼接
  const str = `appid=${appid}&noncestr=${noncestr}&sdk_ticket=${sdk_ticket}&timestamp=${timestamp}`;
  
  // 2. SHA1 加密
  const signature = crypto.createHash('sha1').update(str).digest('hex');
  
  return signature;
}

// 使用示例
const params = {
  appid: 'your_appid',
  noncestr: Math.random().toString(36).substr(2, 15),
  sdk_ticket: 'cached_sdk_ticket',
  timestamp: Math.floor(Date.now() / 1000).toString()
};

const signature = generateSignature(
  params.appid,
  params.noncestr,
  params.sdk_ticket,
  params.timestamp
);
```

#### **Python 示例代码：**

```python
import hashlib
import time
import random
import string

def generate_signature(appid, noncestr, sdk_ticket, timestamp):
    # 拼接字符串
    string1 = f"appid={appid}&noncestr={noncestr}&sdk_ticket={sdk_ticket}&timestamp={timestamp}"
    
    # SHA1 加密
    signature = hashlib.sha1(string1.encode('utf-8')).hexdigest()
    
    return signature

# 使用示例
params = {
    'appid': 'your_appid',
    'noncestr': ''.join(random.choices(string.ascii_letters + string.digits, k=15)),
    'sdk_ticket': 'cached_sdk_ticket',
    'timestamp': str(int(time.time()))
}

signature = generate_signature(**params)
```

#### Java 示例代码

```java
// ==================== 1. WechatConfig.java ====================
@Configuration
public class WechatConfig {
    @Value("${wechat.app.id}")
    private String appId;
    
    @Value("${wechat.app.secret}")
    private String appSecret;
    
    // Getters
    public String getAppId() {
        return appId;
    }
    
    public String getAppSecret() {
        return appSecret;
    }
}

// ==================== 2. WechatTicketService.java ====================
@Service
public class WechatTicketService {
    
    @Autowired
    private WechatConfig wechatConfig;
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    private static final String ACCESS_TOKEN_KEY = "wechat:access_token";
    private static final String SDK_TICKET_KEY = "wechat:sdk_ticket";
    private static final String ACCESS_TOKEN_URL = "https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=%s&secret=%s";
    private static final String SDK_TICKET_URL = "https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=%s&type=2";
    
    /**
     * 获取 AccessToken（带缓存）
     */
    public String getAccessToken() {
        // 1. 先从Redis获取
        String accessToken = redisTemplate.opsForValue().get(ACCESS_TOKEN_KEY);
        if (StringUtils.isNotBlank(accessToken)) {
            return accessToken;
        }
        
        // 2. 缓存没有，重新获取
        try {
            String url = String.format(ACCESS_TOKEN_URL, wechatConfig.getAppId(), wechatConfig.getAppSecret());
            String response = HttpUtil.get(url);
            
            JSONObject jsonObject = JSON.parseObject(response);
            if (jsonObject.containsKey("access_token")) {
                accessToken = jsonObject.getString("access_token");
                Integer expiresIn = jsonObject.getInteger("expires_in");
                
                // 3. 存入Redis，提前5分钟过期
                redisTemplate.opsForValue().set(ACCESS_TOKEN_KEY, accessToken, expiresIn - 300, TimeUnit.SECONDS);
                
                return accessToken;
            } else {
                throw new RuntimeException("获取AccessToken失败: " + response);
            }
        } catch (Exception e) {
            throw new RuntimeException("获取AccessToken异常", e);
        }
    }
    
    /**
     * 获取 SDK Ticket（带缓存）
     */
    public String getSdkTicket() {
        // 1. 先从Redis获取
        String sdkTicket = redisTemplate.opsForValue().get(SDK_TICKET_KEY);
        if (StringUtils.isNotBlank(sdkTicket)) {
            return sdkTicket;
        }
        
        // 2. 缓存没有，重新获取
        try {
            String accessToken = getAccessToken();
            String url = String.format(SDK_TICKET_URL, accessToken);
            String response = HttpUtil.get(url);
            
            JSONObject jsonObject = JSON.parseObject(response);
            if (jsonObject.getInteger("errcode") == 0) {
                sdkTicket = jsonObject.getString("ticket");
                Integer expiresIn = jsonObject.getInteger("expires_in");
                
                // 3. 存入Redis，提前5分钟过期
                redisTemplate.opsForValue().set(SDK_TICKET_KEY, sdkTicket, expiresIn - 300, TimeUnit.SECONDS);
                
                return sdkTicket;
            } else {
                throw new RuntimeException("获取SDK Ticket失败: " + response);
            }
        } catch (Exception e) {
            throw new RuntimeException("获取SDK Ticket异常", e);
        }
    }
}

// ==================== 3. WechatSignatureUtil.java ====================
public class WechatSignatureUtil {
    
    /**
     * 生成微信扫码登录签名
     * @param appId 应用ID
     * @param nonceStr 随机字符串
     * @param timestamp 时间戳
     * @param sdkTicket SDK票据
     * @return 签名
     */
    public static String generateSignature(String appId, String nonceStr, String timestamp, String sdkTicket) {
        // 1. 参数按字典序排序并拼接
        String string1 = "appid=" + appId 
                       + "&noncestr=" + nonceStr 
                       + "&sdk_ticket=" + sdkTicket 
                       + "&timestamp=" + timestamp;
        
        // 2. SHA1加密
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-1");
            byte[] hash = digest.digest(string1.getBytes(StandardCharsets.UTF_8));
            
            // 3. 转换为十六进制字符串
            StringBuilder hexString = new StringBuilder();
            for (byte b : hash) {
                String hex = Integer.toHexString(0xff & b);
                if (hex.length() == 1) {
                    hexString.append('0');
                }
                hexString.append(hex);
            }
            
            return hexString.toString();
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("SHA-1加密失败", e);
        }
    }
    
    /**
     * 生成随机字符串
     * @param length 长度
     * @return 随机字符串
     */
    public static String generateNonceStr(int length) {
        String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        Random random = new Random();
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < length; i++) {
            sb.append(chars.charAt(random.nextInt(chars.length())));
        }
        return sb.toString();
    }
}

// ==================== 4. WechatScanParamsVO.java ====================
@Data
public class WechatScanParamsVO {
    /**
     * 应用ID
     */
    private String appid;
    
    /**
     * 授权作用域
     */
    private String scope;
    
    /**
     * 随机字符串
     */
    private String noncestr;
    
    /**
     * 时间戳（秒）
     */
    private String timestamp;
    
    /**
     * 签名
     */
    private String signature;
}

// ==================== 5. WechatLoginController.java ====================
@RestController
@RequestMapping("/api/wechat")
public class WechatLoginController {
    
    @Autowired
    private WechatConfig wechatConfig;
    
    @Autowired
    private WechatTicketService ticketService;
    
    @Autowired
    private WechatLoginService loginService;
    
    /**
     * 获取微信扫码登录参数
     */
    @GetMapping("/scan-params")
    public Result<WechatScanParamsVO> getScanParams() {
        try {
            // 1. 生成随机字符串和时间戳
            String nonceStr = WechatSignatureUtil.generateNonceStr(16);
            String timestamp = String.valueOf(System.currentTimeMillis() / 1000);
            
            // 2. 获取 SDK Ticket
            String sdkTicket = ticketService.getSdkTicket();
            
            // 3. 生成签名
            String signature = WechatSignatureUtil.generateSignature(
                wechatConfig.getAppId(), 
                nonceStr, 
                timestamp, 
                sdkTicket
            );
            
            // 4. 组装返回参数
            WechatScanParamsVO params = new WechatScanParamsVO();
            params.setAppid(wechatConfig.getAppId());
            params.setScope("snsapi_userinfo");
            params.setNoncestr(nonceStr);
            params.setTimestamp(timestamp);
            params.setSignature(signature);
            
            return Result.success(params);
        } catch (Exception e) {
            return Result.error("获取扫码参数失败: " + e.getMessage());
        }
    }
    
    /**
     * 微信扫码登录
     */
    @PostMapping("/login")
    public Result<LoginVO> wechatLogin(@RequestBody @Valid WechatLoginRequest request) {
        try {
            // 1. 用 authCode 换取 access_token 和 openid
            WechatUserInfo userInfo = loginService.getUserInfoByAuthCode(request.getAuthCode());
            
            // 2. 根据 openid 查询或创建用户
            User user = loginService.getOrCreateUser(userInfo);
            
            // 3. 生成登录令牌
            String token = loginService.generateToken(user);
            
            // 4. 返回登录信息
            LoginVO loginVO = new LoginVO();
            loginVO.setToken(token);
            loginVO.setUserInfo(user);
            
            return Result.success(loginVO);
        } catch (Exception e) {
            return Result.error("登录失败: " + e.getMessage());
        }
    }
}

// ==================== 6. WechatLoginService.java ====================
@Service
public class WechatLoginService {
    
    @Autowired
    private WechatConfig wechatConfig;
    
    @Autowired
    private UserMapper userMapper;
    
    private static final String AUTH_ACCESS_TOKEN_URL = "https://api.weixin.qq.com/sns/oauth2/access_token?appid=%s&secret=%s&code=%s&grant_type=authorization_code";
    private static final String USER_INFO_URL = "https://api.weixin.qq.com/sns/userinfo?access_token=%s&openid=%s";
    
    /**
     * 通过 authCode 获取用户信息
     */
    public WechatUserInfo getUserInfoByAuthCode(String authCode) {
        try {
            // 1. 用 authCode 换取 access_token
            String url = String.format(AUTH_ACCESS_TOKEN_URL, 
                wechatConfig.getAppId(), 
                wechatConfig.getAppSecret(), 
                authCode
            );
            String response = HttpUtil.get(url);
            JSONObject tokenJson = JSON.parseObject(response);
            
            if (tokenJson.containsKey("errcode")) {
                throw new RuntimeException("获取AccessToken失败: " + response);
            }
            
            String accessToken = tokenJson.getString("access_token");
            String openid = tokenJson.getString("openid");
            
            // 2. 用 access_token 获取用户信息
            String userInfoUrl = String.format(USER_INFO_URL, accessToken, openid);
            String userInfoResponse = HttpUtil.get(userInfoUrl);
            JSONObject userInfoJson = JSON.parseObject(userInfoResponse);
            
            if (userInfoJson.containsKey("errcode")) {
                throw new RuntimeException("获取用户信息失败: " + userInfoResponse);
            }
            
            // 3. 封装用户信息
            WechatUserInfo userInfo = new WechatUserInfo();
            userInfo.setOpenid(userInfoJson.getString("openid"));
            userInfo.setUnionid(userInfoJson.getString("unionid"));
            userInfo.setNickname(userInfoJson.getString("nickname"));
            userInfo.setHeadimgurl(userInfoJson.getString("headimgurl"));
            userInfo.setSex(userInfoJson.getInteger("sex"));
            userInfo.setProvince(userInfoJson.getString("province"));
            userInfo.setCity(userInfoJson.getString("city"));
            userInfo.setCountry(userInfoJson.getString("country"));
            
            return userInfo;
        } catch (Exception e) {
            throw new RuntimeException("获取微信用户信息失败", e);
        }
    }
    
    /**
     * 根据微信信息获取或创建用户
     */
    @Transactional
    public User getOrCreateUser(WechatUserInfo wechatUserInfo) {
        // 1. 查询是否已存在
        User user = userMapper.selectByOpenid(wechatUserInfo.getOpenid());
        
        if (user != null) {
            // 2. 存在则更新信息
            user.setNickname(wechatUserInfo.getNickname());
            user.setAvatar(wechatUserInfo.getHeadimgurl());
            user.setUpdateTime(new Date());
            userMapper.updateById(user);
        } else {
            // 3. 不存在则创建新用户
            user = new User();
            user.setOpenid(wechatUserInfo.getOpenid());
            user.setUnionid(wechatUserInfo.getUnionid());
            user.setNickname(wechatUserInfo.getNickname());
            user.setAvatar(wechatUserInfo.getHeadimgurl());
            user.setLoginType("wechat");
            user.setCreateTime(new Date());
            user.setUpdateTime(new Date());
            userMapper.insert(user);
        }
        
        return user;
    }
    
    /**
     * 生成登录令牌
     */
    public String generateToken(User user) {
        // 使用 JWT 生成 token
        return JwtUtil.createToken(user.getId(), user.getOpenid());
    }
}

// ==================== 7. application.yml ====================
/*
wechat:
  app:
    id: your_wechat_appid
    secret: your_wechat_appsecret

spring:
  redis:
    host: localhost
    port: 6379
    database: 0
*/
```

按照公司的架构  获取签证会在后端生成一个消息  消息再到

### 4.3 提供接口给前端

**接口设计：**

```javascript
// 请求
GET /api/wechat/scan-params

// 响应
{
  "code": 200,
  "data": {
    "appid": "wxappid",
    "noncestr": "Wm3WZYTPz0wzccnW",
    "timestamp": "1417508194",
    "signature": "429eaaa13fd71efbc3fd344d0a9a9126835e7303",
    "scope": "snsapi_userinfo"
  }
}
```

### 4.4 authCode 换取用户信息

**步骤1：获取 access_token**

```http
GET https://api.weixin.qq.com/sns/oauth2/access_token?
  appid=APPID&
  secret=SECRET&
  code=CODE&
  grant_type=authorization_code
```

**步骤2：获取用户信息**

```http
GET https://api.weixin.qq.com/sns/userinfo?
  access_token=ACCESS_TOKEN&
  openid=OPENID
```

## 五、前端实现（uni-app）

### 5.1 当前代码问题分析

你提供的代码存在以下问题：

❌ **问题1：自己生成二维码内容**

```javascript
// 错误做法
const virtualUnionId = "88888888888888";
const qrcodeData = virtualUnionId + timestamp;
this.qrcodeLogin.content = qrcodeData;
```

这不是微信扫码登录的正确方式！微信二维码必须由微信SDK生成。

❌ **问题2：缺少微信SDK调用** 当前代码没有调用微信SDK的授权接口。

❌ **问题3：缺少签名参数** 没有从后端获取签名等必要参数。

### 5.2 正确的实现方式

#### 方案A：使用原生插件（推荐）

**第一步：引入微信登录插件**

```javascript
// 在 main.js 或页面中引入
const wxLogin = uni.requireNativePlugin('WX-Login');
```

**第二步：修改扫码登录逻辑**

```javascript
// ==================== 扫码登录 ====================
async initQrcode() {
    console.log('初始化微信扫码登录');
    
    // 1. 从后端获取签名参数
    const params = await this.getWechatScanParams();
    
    if (!params) {
        uni.showToast({
            title: '获取参数失败',
            icon: 'none'
        });
        return;
    }
    
    // 2. 调用微信SDK生成二维码
    this.startWechatAuth(params);
},

// 从后端获取签名参数
async getWechatScanParams() {
    try {
        const res = await uni.request({
            url: 'https://your-api.com/api/wechat/scan-params',
            method: 'GET'
        });
        
        if (res.statusCode === 200 && res.data.code === 200) {
            return res.data.data;
        }
        return null;
    } catch (error) {
        console.error('获取微信参数失败:', error);
        return null;
    }
},

// 调用微信SDK授权
startWechatAuth(params) {
    // #ifdef APP-PLUS
    const wxLogin = uni.requireNativePlugin('WX-Login');
    
    wxLogin.auth({
        appId: params.appid,
        scope: params.scope,
        nonceStr: params.noncestr,
        timeStamp: params.timestamp,
        signature: params.signature
    }, (result) => {
        if (result.errCode === 0) {
            // 获取到二维码
            this.showQrcode(result.qrcodeImage);
        } else {
            uni.showToast({
                title: '获取二维码失败',
                icon: 'none'
            });
        }
    }, (authResult) => {
        if (authResult.errCode === 0) {
            // 用户扫码授权成功，获取到 authCode
            this.handleAuthCode(authResult.authCode);
        }
    });
    // #endif
    
    // #ifndef APP-PLUS
    uni.showToast({
        title: '仅支持APP端',
        icon: 'none'
    });
    // #endif
},

// 展示二维码（如果SDK返回base64图片）
showQrcode(qrcodeImage) {
    this.qrcodeLogin.content = qrcodeImage;
    this.qrcodeLogin.timestamp = moment().format("YYYY年MM月DD日 HH:mm:ss");
},

// 处理 authCode
async handleAuthCode(authCode) {
    uni.showLoading({ title: '登录中...' });
    
    try {
        const res = await uni.request({
            url: 'https://your-api.com/api/wechat/login',
            method: 'POST',
            data: {
                authCode: authCode
            }
        });
        
        if (res.statusCode === 200 && res.data.code === 200) {
            // 保存token等信息
            uni.setStorageSync('token', res.data.data.token);
            uni.setStorageSync('userInfo', res.data.data.userInfo);
            
            uni.hideLoading();
            this.loginCallback();
        } else {
            uni.hideLoading();
            uni.showToast({
                title: res.data.message || '登录失败',
                icon: 'none'
            });
        }
    } catch (error) {
        uni.hideLoading();
        console.error('登录失败:', error);
        uni.showToast({
            title: '登录失败',
            icon: 'none'
        });
    }
},

// 刷新二维码（重新获取参数）
refreshQrcode() {
    console.log('手动刷新二维码');
    this.initQrcode();
}
```

#### 方案B：使用网页授权（H5/小程序）

对于H5或小程序，微信扫码登录需要使用网页授权方式：

```javascript
// H5 跳转到微信授权页面
handleWechatLogin() {
    const appid = 'your_appid';
    const redirect_uri = encodeURIComponent('https://your-domain.com/callback');
    const scope = 'snsapi_userinfo';
    const state = Math.random().toString(36).substr(2);
    
    const authUrl = `https://open.weixin.qq.com/connect/oauth2/authorize?appid=${appid}&redirect_uri=${redirect_uri}&response_type=code&scope=${scope}&state=${state}#wechat_redirect`;
    
    window.location.href = authUrl;
}
```

### 5.3 完整的 Vue 代码示例

```vue
<template>
    <view class="qrcode-content">
        <view class="qrcode-area">
            <!-- 显示二维码图片 -->
            <view v-if="qrcodeLogin.imageBase64" class="qrcode-wrapper">
                <image 
                    :src="qrcodeLogin.imageBase64" 
                    mode="aspectFit"
                    class="qrcode-img"
                ></image>
            </view>
            
            <!-- 加载中状态 -->
            <view v-else class="qrcode-loading">
                <text>二维码生成中...</text>
            </view>
            
            <!-- 时间显示 -->
            <view class="timetxt">{{qrcodeLogin.timestamp}}</view>
            
            <!-- 扫码状态提示 -->
            <text class="qrcode-tip" v-if="qrcodeLogin.status === 'waiting'">
                请使用微信扫描二维码登录
            </text>
            <text class="qrcode-tip success" v-else-if="qrcodeLogin.status === 'scanned'">
                已扫描，请在手机上确认
            </text>
        </view>
        
        <view class="refreshcode" @click="refreshQrcode">
            <image src="/static/image/home/reload.png" 
                   style="width:25rpx;height: 25rpx; margin-right: 5px;">
            </image>
            刷新二维码
        </view>
    </view>
</template>

<script>
export default {
    data() {
        return {
            qrcodeLogin: {
                imageBase64: '',
                timestamp: '',
                status: 'waiting', // waiting | scanned | expired
                timer: null,
                refreshInterval: 2 * 60 * 1000 // 2分钟
            }
        }
    },
    
    mounted() {
        this.initQrcode();
    },
    
    beforeDestroy() {
        this.clearQrcodeTimer();
    },
    
    methods: {
        async initQrcode() {
            // 1. 获取后端签名参数
            const params = await this.getWechatScanParams();
            if (!params) return;
            
            // 2. 调用微信SDK
            this.startWechatAuth(params);
            
            // 3. 启动定时刷新
            this.startQrcodeTimer();
        },
        
        async getWechatScanParams() {
            try {
                uni.showLoading({ title: '加载中...' });
                
                const [error, res] = await uni.request({
                    url: this.$config.apiUrl + '/api/wechat/scan-params',
                    method: 'GET'
                });
                
                uni.hideLoading();
                
                if (!error && res.statusCode === 200) {
                    return res.data.data;
                }
                
                uni.showToast({
                    title: '获取参数失败',
                    icon: 'none'
                });
                return null;
            } catch (error) {
                uni.hideLoading();
                console.error('获取参数异常:', error);
                return null;
            }
        },
        
        startWechatAuth(params) {
            // #ifdef APP-PLUS
            const wxLogin = uni.requireNativePlugin('WX-Login');
            
            // 发起授权
            wxLogin.auth({
                appId: params.appid,
                scope: params.scope || 'snsapi_userinfo',
                nonceStr: params.noncestr,
                timeStamp: params.timestamp,
                signature: params.signature
            }, (result) => {
                // 回调1：获取二维码
                if (result.errCode === 0) {
                    this.qrcodeLogin.imageBase64 = 'data:image/png;base64,' + result.qrcodeImage;
                    this.qrcodeLogin.timestamp = this.$moment().format("YYYY年MM月DD日 HH:mm:ss");
                    this.qrcodeLogin.status = 'waiting';
                } else {
                    uni.showToast({
                        title: '二维码获取失败: ' + result.errMsg,
                        icon: 'none'
                    });
                }
            }, (scanResult) => {
                // 回调2：用户扫码
                if (scanResult.type === 'scanned') {
                    this.qrcodeLogin.status = 'scanned';
                }
            }, (authResult) => {
                // 回调3：授权结果
                if (authResult.errCode === 0) {
                    this.handleAuthCode(authResult.authCode);
                } else {
                    uni.showToast({
                        title: '授权失败: ' + authResult.errMsg,
                        icon: 'none'
                    });
                }
            });
            // #endif
            
            // #ifndef APP-PLUS
            uni.showToast({
                title: '微信扫码登录仅支持APP',
                icon: 'none',
                duration: 2000
            });
            // #endif
        },
        
        async handleAuthCode(authCode) {
            uni.showLoading({ title: '登录中...' });
            
            try {
                const [error, res] = await uni.request({
                    url: this.$config.apiUrl + '/api/wechat/login',
                    method: 'POST',
                    data: { authCode }
                });
                
                uni.hideLoading();
                
                if (!error && res.statusCode === 200 && res.data.code === 200) {
                    // 保存登录信息
                    const { token, userInfo } = res.data.data;
                    uni.setStorageSync('token', token);
                    uni.setStorageSync('userInfo', userInfo);
                    
                    // 登录成功
                    this.loginCallback();
                } else {
                    uni.showToast({
                        title: res.data.message || '登录失败',
                        icon: 'none'
                    });
                }
            } catch (error) {
                uni.hideLoading();
                console.error('登录异常:', error);
                uni.showToast({
                    title: '登录失败，请重试',
                    icon: 'none'
                });
            }
        },
        
        startQrcodeTimer() {
            this.clearQrcodeTimer();
            this.qrcodeLogin.timer = setTimeout(() => {
                this.qrcodeLogin.status = 'expired';
                uni.showToast({
                    title: '二维码已过期，请刷新',
                    icon: 'none'
                });
            }, this.qrcodeLogin.refreshInterval);
        },
        
        clearQrcodeTimer() {
            if (this.qrcodeLogin.timer) {
                clearTimeout(this.qrcodeLogin.timer);
                this.qrcodeLogin.timer = null;
            }
        },
        
        refreshQrcode() {
            this.clearQrcodeTimer();
            this.qrcodeLogin.imageBase64 = '';
            this.qrcodeLogin.status = 'waiting';
            this.initQrcode();
        },
        
        loginCallback() {
            uni.reLaunch({
                url: '/pages/tabBar/home/index'
            });
        }
    }
}
</script>

<style scoped>
.qrcode-img {
    width: 100%;
    height: 100%;
}

.qrcode-loading {
    width: 460rpx;
    height: 460rpx;
    display: flex;
    align-items: center;
    justify-content: center;
    border: 2rpx dashed #E5E5E5;
    border-radius: 12rpx;
}

.qrcode-tip.success {
    color: #60CABB;
}
</style>
```

## 六、关键注意事项

### 6.1 安全性

✅ **必须做：**

- 签名计算必须在服务端完成
- AppSecret 不能暴露在客户端
- sdk_ticket 要缓存，避免频繁请求
- authCode 要设置有效期并一次性使用

❌ **不要做：**

- 不要在前端计算签名
- 不要把 AppSecret 写在前端代码
- 不要跳过签名验证

### 6.2 性能优化

```javascript
// 后端缓存 ticket 示例（Node.js + Redis）
class WechatTicketManager {
    async getTicket() {
        // 1. 先从缓存取
        let ticket = await redis.get('wechat:sdk_ticket');
        
        if (ticket) {
            return ticket;
        }
        
        // 2. 缓存没有，重新获取
        ticket = await this.fetchTicketFromWechat();
        
        // 3. 存入缓存（7000秒，留200秒余量）
        await redis.setex('wechat:sdk_ticket', 7000, ticket);
        
        return ticket;
    }
}
```

### 6.3 错误处理

```javascript
// 常见错误码处理
const ERROR_CODES = {
    '-1': '系统错误',
    '-2': '网络错误',
    '-3': '授权被拒绝',
    '-4': '用户取消',
    '40001': 'AppSecret错误',
    '40013': 'AppID无效',
    '40029': 'code无效',
    '42001': 'access_token过期'
};

function handleWechatError(errCode) {
    const message = ERROR_CODES[errCode] || '未知错误';
    uni.showToast({
        title: message,
        icon: 'none'
    });
}
```

## 七、测试要点

### 7.1 功能测试

- [ ] 二维码正常生成显示
- [ ] 扫码后能收到回调
- [ ] 授权后能获取到 authCode
- [ ] authCode 能正常换取用户信息
- [ ] 二维码过期能正常刷新

### 7.2 异常测试

- [ ] 网络断开时的处理
- [ ] 用户拒绝授权的处理
- [ ] 二维码过期的处理
- [ ] 后端接口异常的处理

## 八、总结

### 核心流程

1. 后端维护 sdk_ticket 并生成签名
2. 前端调用微信SDK获取二维码
3. 用户扫码授权
4. SDK回调返回 authCode
5. 后端用 authCode 换取用户信息
6. 完成登录

### 与你当前代码的区别

| 项目       | 当前错误做法       | 正确做法           |
| ---------- | ------------------ | ------------------ |
| 二维码生成 | 自己拼接字符串生成 | 调用微信SDK生成    |
| 参数来源   | 前端虚拟数据       | 后端提供签名参数   |
| 授权流程   | 无SDK调用          | 完整的SDK授权流程  |
| 安全性     | 无签名验证         | 服务端签名保证安全 |

### 下一步

1. 申请微信开放平台账号
2. 搭建后端签名服务
3. 集成微信原生SDK
4. 按照本文档改造前端代码
5. 完整测试授权流程



