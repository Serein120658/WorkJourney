# @Transactional 注解详解

## 一、注解简介

`@Transactional` 是 Spring 框架中用于**声明式事务管理的核心注解**。通过该注解，可以在方法或类级别声明事务属性，Spring 会自动为标注的方法添加事务管理功能。

## 二、事务管理方式

Spring 支持两种事务管理方式：

### 1. 编程式事务管理

- 使用 `TransactionTemplate` 或直接使用 `PlatformTransactionManager`
- Spring 推荐使用 `TransactionTemplate`
- 需要手动编写事务管理代码

### 2. 声明式事务管理（推荐）

- 建立在 AOP 之上
- 本质是对方法前后进行拦截
- 在目标方法开始前创建或加入事务
- 执行完目标方法后根据执行情况提交或回滚事务

声明式事务管理的两种实现方式：

- 基于 XML 配置文件（tx 和 aop 命名空间）
- 基于 `@Transactional` 注解（更简单易用，推荐）

## 三、核心语法

### 基本用法

```java
// 作用于类上 - 该类的所有 public 方法都具有事务属性
@Transactional
public class UserService {
    // ...
}

// 作用于方法上 - 可以覆盖类级别的定义
@Transactional(rollbackFor = Exception.class)
public void saveUser(User user) {
    // ...
}
```

### 常用配置示例

```java
// 遇到任何异常都回滚
@Transactional(rollbackFor = Exception.class)

// 只读事务（用于查询操作，可以优化性能）
@Transactional(readOnly = true)

// 设置事务超时时间（秒）
@Transactional(timeout = 30)

// 指定事务传播行为
@Transactional(propagation = Propagation.REQUIRED)

// 指定事务隔离级别
@Transactional(isolation = Isolation.READ_COMMITTED)

// 组合使用
@Transactional(
    rollbackFor = Exception.class,
    timeout = 30,
    propagation = Propagation.REQUIRED
)
```

## 四、注解属性详解

| 属性                     | 类型              | 描述                                                     |
| ------------------------ | ----------------- | -------------------------------------------------------- |
| `value`                  | String            | 可选的限定描述符，指定使用的事务管理器                   |
| `propagation`            | enum: Propagation | 可选的事务传播行为设置                                   |
| `isolation`              | enum: Isolation   | 可选的事务隔离级别设置                                   |
| `readOnly`               | boolean           | 读写或只读事务，默认为读写（false）                      |
| `timeout`                | int（秒）         | 事务超时时间设置                                         |
| `rollbackFor`            | Class对象数组     | 导致事务回滚的异常类数组（必须继承自 Throwable）         |
| `rollbackForClassName`   | 类名数组          | 导致事务回滚的异常类名字数组（必须继承自 Throwable）     |
| `noRollbackFor`          | Class对象数组     | 不会导致事务回滚的异常类数组（必须继承自 Throwable）     |
| `noRollbackForClassName` | 类名数组          | 不会导致事务回滚的异常类名字数组（必须继承自 Throwable） |

## 五、异常处理机制

### 异常分类

Java 中的异常体系：

```
Throwable
├── Error（一定会回滚）
└── Exception
    ├── RuntimeException（运行时异常）
    │   ├── NullPointerException
    │   ├── ArrayIndexOutOfBoundsException
    │   └── ...
    └── 非 RuntimeException（检查型异常）
        ├── IOException
        ├── SQLException
        └── ...
```

### 默认回滚规则

**重要提示：** 如果 `@Transactional` 注解中不配置 `rollbackFor` 属性：

- **只有遇到 `RuntimeException` 时才会回滚**
- 遇到非运行时异常（检查型异常）**不会回滚**

### 推荐配置

```java
@Transactional(rollbackFor = Exception.class)
```

使用 `rollbackFor = Exception.class` 的好处：

- 可以让事务在遇到**任何异常**时都回滚
- 包括运行时异常和非运行时异常
- 提高数据一致性保障

## 六、重要注意事项

### 1. 作用范围

- 作用于类上：该类的**所有 public 方法**都具有该类型的事务属性
- 作用于方法上：方法级别的配置会**覆盖**类级别的定义

### 2. 运行时异常处理

- 如果不对运行时异常进行处理，出现异常后要么线程中止，要么主程序终止
- 如果不想终止，必须捕获所有运行时异常
- 建议：出现异常数据时，应舍弃异常数据并记录日志，不应影响正常数据的处理

### 3. 检查型异常

- 非运行时异常（RuntimeException 以外的异常）属于 Exception 类及其子类
- Java 编译器**强制要求**必须对这些异常进行 catch 处理
- 程序不处理则无法编译通过

### 4. 方法可见性

- `@Transactional` 只能应用于 **public 方法**
- 如果应用于 protected、private 或 package-visible 方法，不会报错，但事务配置会被忽略

### 5. 自调用问题

```java
@Service
public class UserService {
    
    // 不会生效！
    public void methodA() {
        methodB(); // 同一个类内部调用，事务不会生效
    }
    
    @Transactional
    public void methodB() {
        // 事务操作
    }
}
```

- 同一个类中的方法相互调用，`@Transactional` 不会生效
- 原因：Spring AOP 使用代理模式，内部调用不会经过代理

### 6. 异常被捕获

```java
@Transactional(rollbackFor = Exception.class)
public void saveUser(User user) {
    try {
        // 数据库操作
    } catch (Exception e) {
        // 异常被捕获，事务不会回滚！
        e.printStackTrace();
    }
}
```

- 如果在方法内部捕获了异常，事务**不会回滚**
- 解决方案：在 catch 块中手动抛出异常，或使用 `TransactionAspectSupport.currentTransactionStatus().setRollbackOnly()`

## 七、最佳实践

### 1. 推荐配置

```java
@Transactional(rollbackFor = Exception.class)
public void businessMethod() {
    // 业务逻辑
}
```

### 2. 查询方法使用只读事务

```java
@Transactional(readOnly = true)
public User getUserById(Long id) {
    return userRepository.findById(id);
}
```

### 3. 设置合理的超时时间

```java
@Transactional(rollbackFor = Exception.class, timeout = 30)
public void longRunningTask() {
    // 长时间运行的任务
}
```

### 4. 异常处理建议

```java
@Transactional(rollbackFor = Exception.class)
public void saveData(Data data) {
    try {
        // 业务逻辑
        dataRepository.save(data);
    } catch (Exception e) {
        // 记录日志
        log.error("保存数据失败", e);
        // 重新抛出异常，确保事务回滚
        throw e;
    }
}
```

## 八、常见事务传播行为

```java
// REQUIRED（默认）：如果当前存在事务，则加入该事务；如果不存在，则创建新事务
@Transactional(propagation = Propagation.REQUIRED)

// REQUIRES_NEW：创建新事务，如果当前存在事务，则挂起当前事务
@Transactional(propagation = Propagation.REQUIRES_NEW)

// SUPPORTS：如果当前存在事务，则加入该事务；如果不存在，则以非事务方式执行
@Transactional(propagation = Propagation.SUPPORTS)

// NOT_SUPPORTED：以非事务方式执行，如果当前存在事务，则挂起当前事务
@Transactional(propagation = Propagation.NOT_SUPPORTED)

// MANDATORY：如果当前存在事务，则加入该事务；如果不存在，则抛出异常
@Transactional(propagation = Propagation.MANDATORY)

// NEVER：以非事务方式执行，如果当前存在事务，则抛出异常
@Transactional(propagation = Propagation.NEVER)

// NESTED：如果当前存在事务，则在嵌套事务内执行
@Transactional(propagation = Propagation.NESTED)
```

## 九、总结

- `@Transactional` 是 Spring 声明式事务管理的核心注解
- 默认只对 `RuntimeException` 回滚，建议配置 `rollbackFor = Exception.class`
- 只能应用于 public 方法
- 注意同类方法调用和异常捕获导致的事务失效问题
- 合理使用事务传播行为和隔离级别
- 查询操作建议使用 `readOnly = true` 优化性能

------

**参考资料：** Spring 官方文档 - Transaction Management