

[官方文档](http://www.postgres.cn/docs/9.3/sql-createindex.html)



## CONCURRENTLY

当使用这个选项时, PostgreSQL在生成索引时将不会在表上加任何锁阻止并发的插入,更新,删除.而标准的建立一个索引将产生一个阻止写(不包括读)的锁直到索引建立完毕.当使用这个选项时有一些问题需要注意,

### 并发建立索引

建立一个索引将影响正常的数据库操作.一般的 PostgreSQL锁住建立索引的表防止写，然后通过扫描表来建立整个索引.其他的事物可以读表,但是插入,更新,删除操作将被锁住直到索引建立完成.如果这是一个线上的生成库将会有较严重的影响.非常大的表将使用数个小时来建立索引,即使一个较小的表,对于生产库也会在一个不可接受的时间内锁住该表的写操作.

**PostgreSQL支持建立索引时不锁写操作.这个方法通过`CREATE INDEX`时指定`CONCURRENTLY`选项,当使用这个选项时, PostgreSQL必须扫描表2次,它必须等待所有的将要使用该索引的事物结束.所以这个方法比标准的建立索引需要更多的工作并且花费更多的时间.然而,在建立索引的时候它允许正常的操作所以对于生产环境它是非常有用的.当然在建立索引时额外的CPU和I/o开销可能会降低其他操作的效率.**

在并发创建索引中，索引在一个事物中进入系统表，然后两表扫描发生在另外的事物中．在第二遍扫描时任何活跃的事物（在该表上）将会阻塞并发索引的建立直到事物完成．甚至在第二遍表扫描时事物仅仅涉及到该表．并发建立索引使用[第 47.59 节](http://www.postgres.cn/docs/9.3/view-pg-locks.html)中的方法等待每一个发生的事物完成．

当扫描表时发生了问题，例如一个唯一索引违反了唯一性，`CREATE INDEX`将会失败并且留下一个 "invalid"索引．在查询时这个索引将会被忽略因为他是不完整的；然而它仍然会增加更新的开销．psql`\d`命令将列出带 `INVALID`的索引．

```shell
postgres=# \d tab
       Table "public.tab"
 Column |  Type   | Modifiers 
--------+---------+-----------
 col    | integer | 
Indexes:
    "idx" btree (col) INVALID
```

这种情况推荐的恢复方法是删除掉索引并且再次执行`CREATE INDEX CONCURRENTLY`. （另一种重建索引的方法是使用`REINDEX`.然而，因为`REINDEX`不支持并发建立索引，所以这种方式可用性不高．）

另一个缺点是当并发建立唯一索引第二遍扫描表后唯一性将会约束其他事物．这意味着在索引建立完成前在其他查询中违反了该索引将会报违反约束错误，即使最后索引建立失败．如果在第二遍扫描发生了错误，在后续的操作中"invalid"索引也会（在相关列上）保持该唯一性．

支持建立并发索引和部分索引．在这些语句中出现错误将会产生和前面违反唯一性约束相似的错误．

标准建立索引允许并行的执行其他标准的建立索引语句，但是在一个表上一次仅可以有一个并发建立索引语句．在这两种情况下，建立索引的同时不允许有其他模式类型的修改．另一个不同点是 `CREATE INDEX`可以在一个阻塞的事物里执行，而 `CREATE INDEX CONCURRENTLY`不可以．







在[第 11 章](http://www.postgres.cn/docs/9.3/indexes.html)中描述了什么时候会使用索引，什么时候不使用索引，以及在什么情况下索引是有用的．