## PDA上出库的理解

扫到多少标签    计算出出库量   可以手动修改库存

![image-20260114103659954](17.出库.assets/image-20260114103659954.png)

对表的操作   ：

buy_foodoutstorage    进行基本信息的插入    谁出的这次库   token  -->  guid  --> loginuser

buy_foodoutstoragedetail        出库都出了些啥东西  是否修改了出库量？？  

buy_foodoutstoragedetail_rfid        详细出了那些东西   那一批次   标签携带的有信息



再对buy_foodstoragedetail   修改匹配 foodsnum  和 batchnum   的库存oprnum   oprjin        
 		避免出现输入的出库量大于库存量   **需要在前端进行判断**    后端也进行判断一次



再去buy_foodstoragedetail_rfid     对扫描到的相应标签的状态进行修改   并删除    status为0      isdel设置为1





## 疑问：

出库编号是如何生成的？outnum      盘库编号又是如何生成的？checknum  
  `outnumber = jQuery.getparent().getPLANNO("CK"),`  如果也要前端生成   那么 小程序下可调用不了jqery     就需要清楚是如何生成的  ？？？？？？  





## 童帮系统的处理参考

```js
/**
 * 确认出库
 */
function saveEvent(cb) {
    var $trs = $(".div-food[data-key]"),
        arrpm = [],
        isok = true,
        isval = true,
        whid = objdata.whid,
        ftype = objdata.objWareHouse[whid].target,
        intime = $("#txttime").val(),
        outnumber = jQuery.getparent().getPLANNO("CK"),
        my = jQuery.getparent().objdata.my;
    if (!intime) {
        return jQuery.getparent().layer.msg("请选择出库时间！");
    }
    if ($trs.length == 0) {
        return jQuery.getparent().layer.msg("请先添加出库商品！");
    }
    $trs.each(function () {
        var _this = $(this),
            $batchs = _this.find(".div-batch"),
            key = _this.data("key"),
            stock = parseFloat(_this.data("stock")),
            oprjin = parseFloat(_this.find(".oprjin").val() || 0),
            stock = _this.attr("data-stock") || 0;
        if (!oprjin) {
            isval = false;
        }
        if (oprjin > stock) {
            isok = false;
        }
        //遍历明细
        if ($batchs.length > 0) {
            var ishaveout = false;
            $batchs.each(function () {
                var $this = $(this),
                    id = $this.data("id"),
                    batchnum = $this.data("batchnum"),
                    outnum = $this.find(".outnum").val(),
                    outjin = $this.find(".outjin").val(),
                    outoldnum = $this.find(".outoldnum").text(),
                    objbatch = objdata.objStorage[whid][key].objfood[id];
                if (outnum == 0 && outnum == outoldnum) {
                } else {
                    var objcolumn = {};
                    if (objbatch.productiondate) {
                        objcolumn.columndate = [objbatch.productiondate];
                    } else {
                        objcolumn.columnnull = [];
                    }
                    var objsavedate = {};
                    if (objbatch.savedate) {
                        objsavedate.columndate = [objbatch.savedate];
                    } else {
                        objsavedate.columnnull = [];
                    }
                    arrpm.push(["foodoutstoragedetail.insert", outnumber, intime, batchnum, objbatch.ordernum, objbatch.foodnum, objbatch.foodname, objbatch.buy_supplier_id, objbatch.buy_supplier_sname, objbatch.buy_food_id, objbatch.relatename, objbatch.buy_foodspec_id, objbatch.unit, objbatch.conversion, $.msgwhere(objcolumn), (objbatch.productionnum || ''), objbatch.savedays, objbatch.savecycle, $.msgwhere(objsavedate), outnum, outjin, objbatch.oprnum, parseFloat(objbatch.oprnum).mul(objbatch.conversion), ftype, whid]);
                    arrpm.push(["foodstoragedetail.update", outnum, outjin, id]);
                    ishaveout = true;
                }
            });
            if (ishaveout) {//校正库存

            }
        }
    });
    if (!isok) {
        return parent.layer.msg("存在出库量大于库存量商品，请检查！");
    }
    if (!isval) {
        return parent.layer.msg("请先填写完商品信息，再保存！");
    }
    arrpm.push(["orderOutstorage.outstorage", outnumber, intime, ftype, my.id, my.name, '2', 'null', '', '', whid]);//入库主表
    for (var i = 0; i < objdata.arrmsg.length; i++) {
        arrpm.push(objdata.arrmsg[i]);
    }
    jQuery.getparent().layer.confirm("请确认是否进行出库操作？", function (idx) {
        jQuery.getparent().layer.close(idx);
        jQuery.getparent().layer.load();
        $.sm(function (re, err) {
            jQuery.getparent().layer.closeAll("loading");
            if (err) {
                jQuery.getparent().layer.msg(err);
            } else {
                jQuery.getparent().layer.msg("出库成功！");
                cb && cb();
            }
        }, arrpm, null, null, null, null, 1);
    });
}

```

根据不同的表走不同的数据，需要调整

现有代码中的

## 明日待做

```vue
// 执行出库操作
			doOutbound() {
				// uni.showLoading({
				// 	title: '出库中...'
				// });

				const outnum = generateOrderNumber('CK');

				// 构建出库数据结构
				const outboundData = {
					// 主表数据
					main: {
						outnum: outnum,
						outtime: this.selectedDate,
						ordernum: " ",
						out_uid: "",

						oprin: this.totalMatched,
						status: 1
					},

					// 明细表数据
					details: [],

					// RFID表数据
					rfids: []
				};

				// 构建明细表数据
				this.warehouses.forEach(warehouse => {
					warehouse.foods.forEach(food => {
						food.batches.forEach(batch => {
							if (batch.scannedOprjin > 0) {
								outboundData.details.push({
									outnum: outnum,
									whid: warehouse.whid,
									foodnum: food.foodnum,
									batchnum: batch.batchnum,
									conversion: food.conversion || 1,
									unit: food.unit || '斤',
									rfidnum: batch.rfidCount || 0,
									oprjin: batch.scannedOprjin,
									isdel: 0,
									isModified: batch.isModified ? 1 : 0
								});
							}
						});
					});
				});

				// 构建RFID表数据 - 匹配的RFID
				const matchedEpcs = new Set();
				this.warehouses.forEach(warehouse => {
					warehouse.foods.forEach(food => {
						food.batches.forEach(batch => {
							if (batch.epcs && batch.epcs.length > 0) {
								batch.epcs.forEach(epc => {
									matchedEpcs.add(epc);
									outboundData.rfids.push({
										outnum: outnum,
										whid: warehouse.whid,
										rfidnum: epc
									});
								});
							}
						});
					});
				});

				// 如果batch中没有epcs数组，使用全部扫描的标签作为匹配标签
				if (outboundData.rfids.length === 0 && this.totalMatched > 0) {
					this.tagList.forEach(tag => {
						if (!this.unmatchedRfids.includes(tag.epc)) {
							outboundData.rfids.push({
								outnum: outnum,
								whid: this.warehouses[0]?.whid || null,
								productoutdocument: tag.epc,
								valueid: 1
							});
						}
					});
				}

				// 构建RFID表数据 - 无效的RFID
				this.unmatchedRfids.forEach(rfid => {
					outboundData.rfids.push({
						whid: null,
						rfidnum: rfid,
						valueid: 0
					});
				});

				console.log('出库数据结构:', outboundData);

				// 调用出库接口

			},

```

### 实现

基于系统去实现的，扫描出库，一次组成了一个出库单

```vue
	doOutbound() {
				if (!this.selectedDate) {
					uni.showToast({
						title: '请选择出库时间',
						icon: 'none'
					});
					return;
				}

				uni.showLoading({
					title: '出库中...'
				});

				try {
					const arrpm = [];
					const outnum = generateOrderNumber('CK');
					const outtime = this.selectedDate;

					// 遍历仓库、商品和批次
					this.warehouses.forEach(warehouse => {
						const whid = warehouse.whid;

						warehouse.foods.forEach(food => {
							const foodnum = food.foodnum;
							const foodname = food.foodname;

							food.batches.forEach(batch => {
								let outjin, outoprnum;

								if (batch.isModified) {
									outjin = parseFloat(batch.scannedOprjin);
									const conversion = parseFloat(batch.conversion);

									if (conversion && conversion > 0) {
										outoprnum = outjin / conversion;

									} else {
										outoprnum = 1;
										console.warn('没有规格信息,数量默认为1');
									}
								} else {
									outjin = batch.scannedOprjin;
									outoprnum = batch.scannedOprnum;
								}

								const ftype = batch.ftype;

								if (outoprnum > 0 && outjin > 0) {
									const batchnum = batch.batchnum;
									const ordernum = food.ordernum;
									const buy_supplier_id = batch.supplierId;
									const buy_supplier_sname = batch.supplierName || '';
									const buy_food_id = batch.buy_food_id || '';
									const relatename = '';
									const buy_foodspec_id = batch.buy_foodspec_id || '';
									const unit = batch.unit || '斤';
									const conversion = batch.conversion || '';
									const productiondate = batch.productiondate || '';
									const productionnum = batch.productionnum || '';
									const savedays = batch.savedays || '';
									const savecycle = batch.savecycle || '';
									const savedate = batch.savedate || '';

									const oldnum = batch.detailOprnum;
									const oldjin = batch.detailOprjin;

									// 插入出库明细
									arrpm.push([
										"buy_foodoutstoragedetail.insertbyapp",
										outnum,
										outtime,
										batchnum,
										ordernum,
										foodnum,
										foodname,
										buy_supplier_id,
										buy_supplier_sname,
										buy_food_id,
										relatename,
										buy_foodspec_id,
										unit,
										conversion,
										productiondate,
										productionnum,
										savedays,
										savecycle,
										savedate,
										outoprnum,
										outjin,
										oldnum,
										oldjin,
										ftype,
										whid
									]);

									if (batch.rfidTags && batch.rfidTags.length > 0) {
										batch.rfidTags.forEach(rfidTag => {
											const rfidConversion = rfidTag
												.rfid_conversion || '';
											const rfidOprnum = rfidTag.rfid_oprnum || 0;
											const rfidOprjin = rfidTag.rfid_oprjin || 0;

											arrpm.push([
												"buy_foodoutstoragedetail_rfid.insertbyapp",
												outnum,
												foodnum,
												batchnum,
												whid,
												rfidTag.rfidnum,
												rfidConversion,
												unit,
												rfidOprnum,
												rfidOprjin
											]);
										});
									}
								}
							});
						});
					});

					// 插入出库主表  todo 如果一次出过多个仓库的  那这里放哪一个仓库的id   
					const firstWhid = this.warehouses[0]?.whid || null;
					const modifiedInfo = this.modifiedBatches.length > 0 ?
						`, 手动修改${this.modifiedBatches.length}条` : '';
					const out_uname = app.globalData.objuserinfo.uname;

					arrpm.push([
						"buy_foodoutstorage.insertbyapp",
						outnum,
						outtime,
						1,
						'',
						out_uname,
						null,
						'',
						'',
						'',
						'',
						firstWhid
					]);

					console.log('出库数据 arrpm:', arrpm);

					// 调用接口
					uni.sm((re, err) => {
						uni.hideLoading();

						if (err) {
							console.error('出库失败:', err);
							uni.showToast({
								title: err || '出库失败',
								icon: 'none',
								duration: 2000
							});
							return;
						}

						console.log('出库成功返回:', re);
						// todo 成功后走另一个方法  用于 更新库存和  rfid 的库存状态
						// 更新库存的消息id 为  foodstoragedetail.updatebyapp  id 在 batch.detail_id
						// 根据扫描到的标签列表 更新  rfidnum = 标签列表中的

						// 更新库存和RFID状态
						this.updateStorageAndRfidStatus();
						uni.showToast({
							title: '出库成功',
							icon: 'success',
							duration: 2000
						});

						setTimeout(() => {
							this.resetPage();
						}, 2000);
					}, arrpm);


				} catch (error) {
					uni.hideLoading();
					console.error('构建出库数据失败:', error);
					uni.showToast({
						title: '出库失败',
						icon: 'none'
					});
				}
			},

			// 更新库存和RFID状态
			// 更新库存和RFID状态
			updateStorageAndRfidStatus() {
				const arrpm = [];
				
				// 遍历所有仓库、商品和批次
				this.warehouses.forEach(warehouse => {
					const whid = warehouse.whid;
					
					warehouse.foods.forEach(food => {
						const foodnum = food.foodnum;
						
						food.batches.forEach(batch => {
							// 获取实际出库量(可能是修改后的值)
							let outjin, outoprnum;
							
							if (batch.isModified) {
								// 如果手动修改过,使用修改后的值
								outjin = parseFloat(batch.scannedOprjin);
								const conversion = parseFloat(batch.conversion);
								
								if (conversion && conversion > 0) {
									outoprnum = outjin / conversion;
								} else {
									outoprnum = 1;
									console.warn('没有规格信息,数量默认为1');
								}
							} else {
								// 使用原始扫描值
								outjin = batch.scannedOprjin;
								outoprnum = batch.scannedOprnum;
							}
							
							if (outoprnum > 0 && outjin > 0) {
								const detail_id = batch.detail_id;
								const batchnum = batch.batchnum;
								
								// 更新库存明细 - 直接传递出库量,数据库会自动计算剩余库存
								if (detail_id) {
									arrpm.push([
										"buy_foodstoragedetail.updatebyapp",
										outoprnum,  // #0# - 出库数量
										outjin,     // #1# - 出库重量
										detail_id   // #2# - 库存明细ID
									]);
								}
								
								// 更新RFID标签状态
								if (batch.rfidTags && batch.rfidTags.length > 0) {
									batch.rfidTags.forEach(rfidTag => {
										const rfidnum = rfidTag.rfidnum;
										
										// 将RFID标签状态更新为已出库(假设状态值为2表示已出库)
										arrpm.push([
											"buy_foodstoragedetail_rfid.updatebyapp",
											rfidnum
										]);
									});
								}
							}
						});
					});
				});
				
				// 如果有需要更新的数据
				if (arrpm.length > 0) {
					console.log('更新库存和RFID状态数据:', arrpm);
					
					uni.sm((re, err) => {
						if (err) {
							console.error('更新库存和RFID状态失败:', err);
							uni.showToast({
								title: '库存更新失败',
								icon: 'none',
								duration: 2000
							});
							return;
						}
						
						console.log('库存和RFID状态更新成功:', re);
					}, arrpm);
				} else {
					console.log('没有需要更新的库存数据');
				}
			},


```

## 调整

如果扫描到多个仓库   那么就生成多个的出库单





## 扫描出库也需要实现一下

manualRetrieval.vue

按照之前的逻辑  较迅速实现





## 明日

搜索出库实现    











