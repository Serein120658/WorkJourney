## 系统流程



### 消息

```xml

<!--    盘库 主表 -->
    <msg id="handCheckstorage.checkstoragebyapp" type="insert" d="y" did="{guid}"  v="
    buy_foodcheckstorage
    %16checknum,checktime,checktype,check_uid,check_uname,check_status,iseditkucun,whid,step
    %16'#0#','#1#',#2#,#3#,'#4#',#5#,#6#,#7#,#8#
    %16 isdel=0 and checknum='#0#'"/>

<!--   盘库  明细 -->
    <msg id="buy_foodcheckstoragedetail.insertbyapp" type="insert" d="y" did="{guid}" v="
    buy_foodcheckstoragedetail
    %16checknum,checktime,batchnum,ordernum,foodnum,foodname,buy_supplier_id,buy_supplier_sname,
    buy_food_id,relatename,buy_foodspec_id,unit,conversion,productiondate,productionnum,savedays,
    savecycle,savedate,oprnum,oprjin,oldnum,oldjin,ftype,whid,iseditkucun,isdel
    %16'#0#','#1#','#2#','#3#','#4#','#5#',#6#,'#7#',
    #8#,'#9#',#10#,'#11#',#12#,#13#,'#14#',#15#,
    '#16#',#17#,#18#,#19#,#20#,#21#,#22#,#23#,#24#,0
    %16 isdel=0 and checknum='#0#' and batchnum='#2#' and whid=#23#">
<!--        <where idx="13">-->
<!--            <p key="columndate">'{0}'</p>-->
<!--            <p key="columnnull">null</p>-->
<!--        </where>-->
<!--        <where idx="17">-->
<!--            <p key="columndate">'{0}'</p>-->
<!--            <p key="columnnull">null</p>-->
<!--        </where>-->
    </msg>

<!--    插入出库明细的  rfid表-->
    <msg id="buy_foodcheckstoragedetail_rfid.insertbyapp" type="insert" d="y" did="{guid}" v="
        buy_foodoutstoragedetail_rfid
        %16 checknum, foodnum, batchnum, whid, rfidnum, conversion, unit, oprnum, oprjin
        %16 '#0#',   '#1#',    '#2#',   #3#,  '#4#',    '#5#',   '#6#' , #7#, #8# ">
    </msg>

<!-- 如果有修改盘点量的 更新库存 -->
    <msg id="buy_foodstoragedetail.checkupdatebyapp" type="update" d="y" did="{guid}" v="
    update buy_foodstoragedetail set oprnum=(#0#),oprjin=(#1#)
    where isdel=0 and batchnum= '#2#' and foodnum = '#3#' "/>
```



### 遇到的问题

按照之前的出库结构去调整盘库的逻辑

盘库场景下一次请求头的数据太大，会超过tomcat的默认大小，

两个方法    

1. 调整tomcat的默认请求头大小   没调整   这种内置的知道就行了
2. 调整前端多次请求   可以根据仓库 去  一个仓库跑一次   多个仓库      一个仓库会有很多的商品   超过 8k还是会有问题 ！！！！





## 现在需要解决的一个大问题

回库后的 库存增加   新增加的库存部分在标签绑定部分显示出来，已绑定多少？

逻辑上：获取当前绑定的商品

新操作  根据不同食物的不同批次获得的 rfid标签的oprjin累加  给到要返回的oprjin



出库的时候，哪怕修改了库存   扫描到的标签都是出去的





```
<!--        详情   批次  规格等  已经绑定的批次不显示 关联 buy_foodstoragedetail_rfid -->
<msg id="handCheckstorageDetail.appallstock" type="selectjson" d="y" did="{guid}" v="select id,batchnum,innum,
    to_char(intime,'YYYY-MM-DD') as intime,ordernum,foodnum,foodname,buy_supplier_id,
    buy_supplier_sname,buy_food_id,relatename,buy_foodspec_id,unit,conversion,
    to_char(productiondate,'YYYY-MM-DD') as productiondate,productionnum,savedays,savecycle,
    to_char(savedate, 'YYYY-MM-DD') as savedate,oprnum,oprjin,ftype,whid
    from buy_foodstoragedetail
    where isdel=0 #0# order by savedate asc">
    <where idx="0">
        <p key="hascheck">and foodnum in (select foodnum from buy_foodcheckstoragedetail bf where bf.isdel=0 and checktime between '{0}' and '{1}' and bf.whid={2} group by foodnum)</p>
        <p key="notcheck">and foodnum not in (select foodnum from buy_foodcheckstoragedetail bf where bf.isdel=0 and checktime between '{0}' and '{1}' and bf.whid={2} group by foodnum)</p>
        <p key="oprnum">and (oprnum=0 and oprjin=0)</p>
        <p key="oprnumgt">and (oprnum !=0 or oprjin!=0)</p>
        <p key="ftype">and ftype={0}</p>
        <p key="whid">and whid={0}</p>
        <p key="intime">and intime&lt;='{0}'</p>
        <p key="foodnum">and foodnum='{0}' and (oprnum>0 and oprjin>0)</p>
        <p key="hasrfid">and exists (select 1 from buy_foodstoragedetail_rfid rfid where rfid.detailid=buy_foodstoragedetail.id and rfid.isdel=0)</p>
        <p key="norfid">and not exists (select 1 from buy_foodstoragedetail_rfid rfid where rfid.detailid=buy_foodstoragedetail.id and rfid.isdel=0)</p>
        <p key="searchKey"> and relatename like '%{0}%'</p>
    </where>
</msg>


现有的这个查询有一个小问题：就是hasrfid和norfid这两个参数，现在的场景是这样的：
我初始化的时候根据库存的oprnum去绑定标签，绑定完成后，传递这两个参数的其中一个就拿不到数据了，我现在新回库了点，或者盘库的时候修改了库存量，这时候的detail表中的oprnum和oprjin是大于现在绑定的的标签所代表的oprnum或者oprjin的，那么我就需要调整返回的oprnum和oprjin了，返回的oprnum和oprjin应该是库存的减去一家绑定的部分
```





## 难处理

场景模拟：我扫描到了9个标签  单位是斤   表示我出库了9 斤  库存量是12斤  现在我修改出库量 ，如果修改量大于9斤  然后点击出库了后，更新了库存    然后这9个标都出库了，那么在系统中还存在的标签是3个   这时候咋处理？ 如果修改的出库量小于9斤，多的库存量可以重新绑定没问题，因为9个标签都没了。还有盘库的时候修改的库存也有这种情况



我扫描到到了9个签，无论修改与否都是出了的

这里的处理是很麻烦的，而且如果乱输入，这里只能判断他输入的值不能大于库存

**小于库存的任意情况都有，大于扫描到的标签数量和小于扫描到的标签数量**





**盘库不让其修改**   **修改的出库量不能大于扫描量！！   回库不能大于当时的出库量！！**





## 明日



### 标签绑定

绑定  数量为4.8   先绑定4   再去绑定0.8





### 如何重新拿到相应的没绑定的库存？？

这是难点！！！  现有的查询语句不支持！！！！



> <!--        详情   批次  规格等  已经绑定的批次不显示 关联 buy_foodstoragedetail_rfid -->
> <msg id="handCheckstorageDetail.appallstock" type="selectjson" d="y" did="{guid}" v="select id,batchnum,innum,
>     to_char(intime,'YYYY-MM-DD') as intime,ordernum,foodnum,foodname,buy_supplier_id,
>     buy_supplier_sname,buy_food_id,relatename,buy_foodspec_id,unit,conversion,
>     to_char(productiondate,'YYYY-MM-DD') as productiondate,productionnum,savedays,savecycle,
>     to_char(savedate, 'YYYY-MM-DD') as savedate,oprnum,oprjin,ftype,whid
>     from buy_foodstoragedetail
>     where isdel=0 #0# order by savedate asc">
>     <where idx="0">
>         <p key="hascheck">and foodnum in (select foodnum from buy_foodcheckstoragedetail bf where bf.isdel=0 and checktime between '{0}' and '{1}' and bf.whid={2} group by foodnum)</p>
>         <p key="notcheck">and foodnum not in (select foodnum from buy_foodcheckstoragedetail bf where bf.isdel=0 and checktime between '{0}' and '{1}' and bf.whid={2} group by foodnum)</p>
>         <p key="oprnum">and (oprnum=0 and oprjin=0)</p>
>         <p key="oprnumgt">and (oprnum !=0 or oprjin!=0)</p>
>         <p key="ftype">and ftype={0}</p>
>         <p key="whid">and whid={0}</p>
>         <p key="intime">and intime&lt;='{0}'</p>
>         <p key="foodnum">and foodnum='{0}' and (oprnum>0 and oprjin>0)</p>
>         <p key="hasrfid">and exists (select 1 from buy_foodstoragedetail_rfid rfid where rfid.detailid=buy_foodstoragedetail.id and rfid.isdel=0)</p>
>         <p key="norfid">and not exists (select 1 from buy_foodstoragedetail_rfid rfid where rfid.detailid=buy_foodstoragedetail.id and rfid.isdel=0)</p>
>         <p key="searchKey"> and relatename like '%{0}%'</p>
>     </where>
> </msg>
>
> 现有的这个查询有一个小问题：就是hasrfid和norfid这两个参数，现在的场景是这样的：
> 我初始化的时候根据库存的oprnum去绑定标签，绑定完成后，传递这两个参数的其中一个就拿不到数据了，我现在新回库了点，或者盘库的时候修改了库存量，这时候的detail表中的oprnum和oprjin是大于现在绑定的的标签所代表的oprnum或者oprjin的，那么我就需要调整返回的oprnum和oprjin了，返回的oprnum和oprjin应该是库存的减去已经绑定的部分







在操作上得前端改，模拟的场景就是有3.5桶油，我得分两步绑定，也就是前端的走两次，先绑定整数的部分，绑定完后刷新，重新获取数据，此时这个批次的数量应该剩下0.5，我在拿一个标签给其绑定





当前的goToBind是由index.vue文件点击进去获得的数据，当前的问题是：我不需要显示含小数标签，场景是这样的：有3个批次分别对应了20袋，12.5桶，2.6个。现在我选择了12.5桶的和2.6个的商品，此时扫描的标签数量应该为12+2得到14个，点击完成绑定后，刷新页面，重新请求接口获取新的数据，然后剩余0.5袋和0.6个的两个批次不能同时选中然后绑定，单独绑定的时候只能选择一个，这样他就知道标签和商品绑定了





调整绑定逻辑    

