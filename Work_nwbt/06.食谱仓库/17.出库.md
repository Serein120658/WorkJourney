## PDA上出库的理解

扫到多少标签    计算出出库量   可以手动修改库存

![image-20260114103659954](17.出库.assets/image-20260114103659954.png)

对表的操作   ：

buy_foodoutstorage    进行基本信息的插入    谁出的这次库   token  -->  guid  --> loginuser

buy_foodoutstoragedetail        出库都出了些啥东西  是否修改了出库量？？  

buy_foodoutstoragedetail_rfid        详细出了那些东西   那一批次   标签携带的有信息



再对buy_foodstoragedetail   修改匹配 foodsnum  和 batchnum   的库存oprnum   oprjin        
 		避免出现输入的出库量大于库存量   **需要在前端进行判断**    后端也进行判断一次



再去buy_foodstoragedetail_rfid     对扫描到的相应标签的状态进行修改   并删除    status为0      isdel设置为1





## 疑问：

出库编号是如何生成的？outnum      盘库编号又是如何生成的？checknum  
  `outnumber = jQuery.getparent().getPLANNO("CK"),`  如果也要前端生成   那么 小程序下可调用不了jqery     就需要清楚是如何生成的  ？？？？？？  





## 童帮系统的处理参考

```js
/**
 * 确认出库
 */
function saveEvent(cb) {
    var $trs = $(".div-food[data-key]"),
        arrpm = [],
        isok = true,
        isval = true,
        whid = objdata.whid,
        ftype = objdata.objWareHouse[whid].target,
        intime = $("#txttime").val(),
        outnumber = jQuery.getparent().getPLANNO("CK"),
        my = jQuery.getparent().objdata.my;
    if (!intime) {
        return jQuery.getparent().layer.msg("请选择出库时间！");
    }
    if ($trs.length == 0) {
        return jQuery.getparent().layer.msg("请先添加出库商品！");
    }
    $trs.each(function () {
        var _this = $(this),
            $batchs = _this.find(".div-batch"),
            key = _this.data("key"),
            stock = parseFloat(_this.data("stock")),
            oprjin = parseFloat(_this.find(".oprjin").val() || 0),
            stock = _this.attr("data-stock") || 0;
        if (!oprjin) {
            isval = false;
        }
        if (oprjin > stock) {
            isok = false;
        }
        //遍历明细
        if ($batchs.length > 0) {
            var ishaveout = false;
            $batchs.each(function () {
                var $this = $(this),
                    id = $this.data("id"),
                    batchnum = $this.data("batchnum"),
                    outnum = $this.find(".outnum").val(),
                    outjin = $this.find(".outjin").val(),
                    outoldnum = $this.find(".outoldnum").text(),
                    objbatch = objdata.objStorage[whid][key].objfood[id];
                if (outnum == 0 && outnum == outoldnum) {
                } else {
                    var objcolumn = {};
                    if (objbatch.productiondate) {
                        objcolumn.columndate = [objbatch.productiondate];
                    } else {
                        objcolumn.columnnull = [];
                    }
                    var objsavedate = {};
                    if (objbatch.savedate) {
                        objsavedate.columndate = [objbatch.savedate];
                    } else {
                        objsavedate.columnnull = [];
                    }
                    arrpm.push(["foodoutstoragedetail.insert", outnumber, intime, batchnum, objbatch.ordernum, objbatch.foodnum, objbatch.foodname, objbatch.buy_supplier_id, objbatch.buy_supplier_sname, objbatch.buy_food_id, objbatch.relatename, objbatch.buy_foodspec_id, objbatch.unit, objbatch.conversion, $.msgwhere(objcolumn), (objbatch.productionnum || ''), objbatch.savedays, objbatch.savecycle, $.msgwhere(objsavedate), outnum, outjin, objbatch.oprnum, parseFloat(objbatch.oprnum).mul(objbatch.conversion), ftype, whid]);
                    arrpm.push(["foodstoragedetail.update", outnum, outjin, id]);
                    ishaveout = true;
                }
            });
            if (ishaveout) {//校正库存

            }
        }
    });
    if (!isok) {
        return parent.layer.msg("存在出库量大于库存量商品，请检查！");
    }
    if (!isval) {
        return parent.layer.msg("请先填写完商品信息，再保存！");
    }
    arrpm.push(["orderOutstorage.outstorage", outnumber, intime, ftype, my.id, my.name, '2', 'null', '', '', whid]);//入库主表
    for (var i = 0; i < objdata.arrmsg.length; i++) {
        arrpm.push(objdata.arrmsg[i]);
    }
    jQuery.getparent().layer.confirm("请确认是否进行出库操作？", function (idx) {
        jQuery.getparent().layer.close(idx);
        jQuery.getparent().layer.load();
        $.sm(function (re, err) {
            jQuery.getparent().layer.closeAll("loading");
            if (err) {
                jQuery.getparent().layer.msg(err);
            } else {
                jQuery.getparent().layer.msg("出库成功！");
                cb && cb();
            }
        }, arrpm, null, null, null, null, 1);
    });
}

```

根据不同的表走不同的数据，需要调整

现有代码中的

## 明日待做

```vue
// 执行出库操作
			doOutbound() {
				// uni.showLoading({
				// 	title: '出库中...'
				// });

				const outnum = generateOrderNumber('CK');

				// 构建出库数据结构
				const outboundData = {
					// 主表数据
					main: {
						outnum: outnum,
						outtime: this.selectedDate,
						ordernum: " ",
						out_uid: "",

						oprin: this.totalMatched,
						status: 1
					},

					// 明细表数据
					details: [],

					// RFID表数据
					rfids: []
				};

				// 构建明细表数据
				this.warehouses.forEach(warehouse => {
					warehouse.foods.forEach(food => {
						food.batches.forEach(batch => {
							if (batch.scannedOprjin > 0) {
								outboundData.details.push({
									outnum: outnum,
									whid: warehouse.whid,
									foodnum: food.foodnum,
									batchnum: batch.batchnum,
									conversion: food.conversion || 1,
									unit: food.unit || '斤',
									rfidnum: batch.rfidCount || 0,
									oprjin: batch.scannedOprjin,
									isdel: 0,
									isModified: batch.isModified ? 1 : 0
								});
							}
						});
					});
				});

				// 构建RFID表数据 - 匹配的RFID
				const matchedEpcs = new Set();
				this.warehouses.forEach(warehouse => {
					warehouse.foods.forEach(food => {
						food.batches.forEach(batch => {
							if (batch.epcs && batch.epcs.length > 0) {
								batch.epcs.forEach(epc => {
									matchedEpcs.add(epc);
									outboundData.rfids.push({
										outnum: outnum,
										whid: warehouse.whid,
										rfidnum: epc
									});
								});
							}
						});
					});
				});

				// 如果batch中没有epcs数组，使用全部扫描的标签作为匹配标签
				if (outboundData.rfids.length === 0 && this.totalMatched > 0) {
					this.tagList.forEach(tag => {
						if (!this.unmatchedRfids.includes(tag.epc)) {
							outboundData.rfids.push({
								outnum: outnum,
								whid: this.warehouses[0]?.whid || null,
								productoutdocument: tag.epc,
								valueid: 1
							});
						}
					});
				}

				// 构建RFID表数据 - 无效的RFID
				this.unmatchedRfids.forEach(rfid => {
					outboundData.rfids.push({
						whid: null,
						rfidnum: rfid,
						valueid: 0
					});
				});

				console.log('出库数据结构:', outboundData);

				// 调用出库接口

			},

```

### 实现

基于系统去实现的，扫描出库，一次组成了一个出库单

```vue
	doOutbound() {
				if (!this.selectedDate) {
					uni.showToast({
						title: '请选择出库时间',
						icon: 'none'
					});
					return;
				}

				uni.showLoading({
					title: '出库中...'
				});

				try {
					const arrpm = [];
					const outnum = generateOrderNumber('CK');
					const outtime = this.selectedDate;

					// 遍历仓库、商品和批次
					this.warehouses.forEach(warehouse => {
						const whid = warehouse.whid;

						warehouse.foods.forEach(food => {
							const foodnum = food.foodnum;
							const foodname = food.foodname;

							food.batches.forEach(batch => {
								let outjin, outoprnum;

								if (batch.isModified) {
									outjin = parseFloat(batch.scannedOprjin);
									const conversion = parseFloat(batch.conversion);

									if (conversion && conversion > 0) {
										outoprnum = outjin / conversion;

									} else {
										outoprnum = 1;
										console.warn('没有规格信息,数量默认为1');
									}
								} else {
									outjin = batch.scannedOprjin;
									outoprnum = batch.scannedOprnum;
								}

								const ftype = batch.ftype;

								if (outoprnum > 0 && outjin > 0) {
									const batchnum = batch.batchnum;
									const ordernum = food.ordernum;
									const buy_supplier_id = batch.supplierId;
									const buy_supplier_sname = batch.supplierName || '';
									const buy_food_id = batch.buy_food_id || '';
									const relatename = '';
									const buy_foodspec_id = batch.buy_foodspec_id || '';
									const unit = batch.unit || '斤';
									const conversion = batch.conversion || '';
									const productiondate = batch.productiondate || '';
									const productionnum = batch.productionnum || '';
									const savedays = batch.savedays || '';
									const savecycle = batch.savecycle || '';
									const savedate = batch.savedate || '';

									const oldnum = batch.detailOprnum;
									const oldjin = batch.detailOprjin;

									// 插入出库明细
									arrpm.push([
										"buy_foodoutstoragedetail.insertbyapp",
										outnum,
										outtime,
										batchnum,
										ordernum,
										foodnum,
										foodname,
										buy_supplier_id,
										buy_supplier_sname,
										buy_food_id,
										relatename,
										buy_foodspec_id,
										unit,
										conversion,
										productiondate,
										productionnum,
										savedays,
										savecycle,
										savedate,
										outoprnum,
										outjin,
										oldnum,
										oldjin,
										ftype,
										whid
									]);

									if (batch.rfidTags && batch.rfidTags.length > 0) {
										batch.rfidTags.forEach(rfidTag => {
											const rfidConversion = rfidTag
												.rfid_conversion || '';
											const rfidOprnum = rfidTag.rfid_oprnum || 0;
											const rfidOprjin = rfidTag.rfid_oprjin || 0;

											arrpm.push([
												"buy_foodoutstoragedetail_rfid.insertbyapp",
												outnum,
												foodnum,
												batchnum,
												whid,
												rfidTag.rfidnum,
												rfidConversion,
												unit,
												rfidOprnum,
												rfidOprjin
											]);
										});
									}
								}
							});
						});
					});

					// 插入出库主表  todo 如果一次出过多个仓库的  那这里放哪一个仓库的id   
					const firstWhid = this.warehouses[0]?.whid || null;
					const modifiedInfo = this.modifiedBatches.length > 0 ?
						`, 手动修改${this.modifiedBatches.length}条` : '';
					const out_uname = app.globalData.objuserinfo.uname;

					arrpm.push([
						"buy_foodoutstorage.insertbyapp",
						outnum,
						outtime,
						1,
						'',
						out_uname,
						null,
						'',
						'',
						'',
						'',
						firstWhid
					]);

					console.log('出库数据 arrpm:', arrpm);

					// 调用接口
					uni.sm((re, err) => {
						uni.hideLoading();

						if (err) {
							console.error('出库失败:', err);
							uni.showToast({
								title: err || '出库失败',
								icon: 'none',
								duration: 2000
							});
							return;
						}

						console.log('出库成功返回:', re);
						// todo 成功后走另一个方法  用于 更新库存和  rfid 的库存状态
						// 更新库存的消息id 为  foodstoragedetail.updatebyapp  id 在 batch.detail_id
						// 根据扫描到的标签列表 更新  rfidnum = 标签列表中的

						// 更新库存和RFID状态
						this.updateStorageAndRfidStatus();
						uni.showToast({
							title: '出库成功',
							icon: 'success',
							duration: 2000
						});

						setTimeout(() => {
							this.resetPage();
						}, 2000);
					}, arrpm);


				} catch (error) {
					uni.hideLoading();
					console.error('构建出库数据失败:', error);
					uni.showToast({
						title: '出库失败',
						icon: 'none'
					});
				}
			},

			// 更新库存和RFID状态
			// 更新库存和RFID状态
			updateStorageAndRfidStatus() {
				const arrpm = [];
				
				// 遍历所有仓库、商品和批次
				this.warehouses.forEach(warehouse => {
					const whid = warehouse.whid;
					
					warehouse.foods.forEach(food => {
						const foodnum = food.foodnum;
						
						food.batches.forEach(batch => {
							// 获取实际出库量(可能是修改后的值)
							let outjin, outoprnum;
							
							if (batch.isModified) {
								// 如果手动修改过,使用修改后的值
								outjin = parseFloat(batch.scannedOprjin);
								const conversion = parseFloat(batch.conversion);
								
								if (conversion && conversion > 0) {
									outoprnum = outjin / conversion;
								} else {
									outoprnum = 1;
									console.warn('没有规格信息,数量默认为1');
								}
							} else {
								// 使用原始扫描值
								outjin = batch.scannedOprjin;
								outoprnum = batch.scannedOprnum;
							}
							
							if (outoprnum > 0 && outjin > 0) {
								const detail_id = batch.detail_id;
								const batchnum = batch.batchnum;
								
								// 更新库存明细 - 直接传递出库量,数据库会自动计算剩余库存
								if (detail_id) {
									arrpm.push([
										"buy_foodstoragedetail.updatebyapp",
										outoprnum,  // #0# - 出库数量
										outjin,     // #1# - 出库重量
										detail_id   // #2# - 库存明细ID
									]);
								}
								
								// 更新RFID标签状态
								if (batch.rfidTags && batch.rfidTags.length > 0) {
									batch.rfidTags.forEach(rfidTag => {
										const rfidnum = rfidTag.rfidnum;
										
										// 将RFID标签状态更新为已出库(假设状态值为2表示已出库)
										arrpm.push([
											"buy_foodstoragedetail_rfid.updatebyapp",
											rfidnum
										]);
									});
								}
							}
						});
					});
				});
				
				// 如果有需要更新的数据
				if (arrpm.length > 0) {
					console.log('更新库存和RFID状态数据:', arrpm);
					
					uni.sm((re, err) => {
						if (err) {
							console.error('更新库存和RFID状态失败:', err);
							uni.showToast({
								title: '库存更新失败',
								icon: 'none',
								duration: 2000
							});
							return;
						}
						
						console.log('库存和RFID状态更新成功:', re);
					}, arrpm);
				} else {
					console.log('没有需要更新的库存数据');
				}
			},


```

## 调整

如果扫描到多个仓库   那么就生成多个的出库单





## 扫描出库也需要实现一下

manualRetrieval.vue

按照之前的逻辑  较迅速实现





## 明日

搜索出库实现    



**搜索未绑标签的商品出库**







## 在出库单回库

出库单详情点击回库

**回库   修改原始的出库明细  然后更新库存**

### 存在个小问题

如果一开始绑定的商品  不同批次都绑定了的

现在我进行出库，发现扫描了部分的和上面某个商品绑定的标签，然后进行出库，没问题，下次依然能扫到，也能正常进行出库



问题来了  如果进行回库操作更新完信息后，再次回到标签绑定是搜索不到的信息的

#### 处理1：

修改现有的查询，极大增加查询复杂度，    



#### 处理2 

回库的过程中为回库的商品进行绑定，绑定成功后方可入库

再次绑定的数量根据计算后的oprnum和oprjin  





是否需要回库记录表？ ？？

```xml
<msg id="handCheckstorageDetail.appallstock" type="selectjson" d="y" did="{guid}" v="select id,batchnum,innum,
    to_char(intime,'YYYY-MM-DD') as intime,ordernum,foodnum,foodname,buy_supplier_id,
    buy_supplier_sname,buy_food_id,relatename,buy_foodspec_id,unit,conversion,
    to_char(productiondate,'YYYY-MM-DD') as productiondate,productionnum,savedays,savecycle,
    to_char(savedate, 'YYYY-MM-DD') as savedate,oprnum,oprjin,ftype,whid
    from buy_foodstoragedetail
    where isdel=0 #0# order by savedate asc">
    <where idx="0">
        <p key="hascheck">and foodnum in (select foodnum from buy_foodcheckstoragedetail bf where bf.isdel=0 and checktime between '{0}' and '{1}' and bf.whid={2} group by foodnum)</p>
        <p key="notcheck">and foodnum not in (select foodnum from buy_foodcheckstoragedetail bf where bf.isdel=0 and checktime between '{0}' and '{1}' and bf.whid={2} group by foodnum)</p>
        <p key="oprnum">and (oprnum=0 and oprjin=0)</p>
        <p key="oprnumgt">and (oprnum !=0 or oprjin!=0)</p>
        <p key="ftype">and ftype={0}</p>
        <p key="whid">and whid={0}</p>
        <p key="intime">and intime&lt;='{0}'</p>
        <p key="foodnum">and foodnum='{0}' and (oprnum>0 and oprjin>0)</p>
        <p key="hasrfid">and exists (select 1 from buy_foodstoragedetail_rfid rfid where rfid.detailid=buy_foodstoragedetail.id and rfid.isdel=0)</p>
        <p key="norfid">and not exists (select 1 from buy_foodstoragedetail_rfid rfid where rfid.detailid=buy_foodstoragedetail.id and rfid.isdel=0)</p>
        <p key="searchKey"> and relatename like '%{0}%'</p>
    </where>
</msg>
```



现有的这个查询有点潦草，遇到的问题是这样的：
在绑定 的时候传递的是norfid，这样我就拿到了没有绑定标签的商品，现在我绑定了商品了，出库了部分，现在需要回库，回库完修改了库存之后，想为回库的商品重新绑定，此时就拿不到了，
如果一开始绑定的商品  不同批次都绑定了的

现在我进行出库，发现扫描了部分的和上面某个商品绑定的标签，然后进行出库，没问题，下次依然能扫到，也能正常进行出库





#### 处理2 

回库的过程中为回库的商品进行绑定，绑定成功后方可入库

再次绑定的数量根据计算后的oprnum和oprjin  
这是我能想到的两种方式，理论上第二种比较符合逻辑，但是新问题，这是根据出库单去知道的出库商品，然后我晚上才能知道商品是啥，需要回库这种操作，用户体验：我得从很多张出库单中找对应的商品，很不好，因此要采取第一种方案，但是第一种方案，需要计算出当前的库存量需要绑定多少标签，那些批次是绑定完的？那些批次需要新绑定？等都很麻烦，在数据库里面设计到计算不太行，还有一种方式就是把绑定的标签信息也返回给前端，让前端进行计算那些需要重新绑定









一个批次有很多的标签,它是跟着数量走的,我如何确定那些给那些设置status?这个字段现有的表结构是有的，扫描标签出库的时候我知道是哪些标签，因为我会根据标签去更新状态和设置isdel,问题是我回库，回库更新了库存，理论上就是绑定新标签，不存在更新状态，因为，更新状态的话，我怎么知道是哪些标签，这样标签就混乱了





## 新考虑的问题

新问题       搜索的出库是否支持输入 ？？？？？？







## 下周需要解决的问题

1. 回库后重新绑定标签的数据如何拿？？   修改查询又比较麻烦

2. 搜索出库是否需要批次的斤数进行修改？？？

   ![image-20260116165623537](17.出库.assets/image-20260116165623537.png)

   搜索选中的不同批次的提交给上一个页面 ，

   ![image-20260116165636791](17.出库.assets/image-20260116165636791.png)   

类似效果

![image-20260116170122065](17.出库.assets/image-20260116170122065.png)



