

## PostgreSQL 批量更新、删除或插入数据

 批量操作可以减少数据库与应用程序的交互次数，提高数据处理的吞吐量。本文将通过示例介绍如何批量插入、更新和删除数据。

### **批量插入数据**

您可以通过如下四种方法进行批量插入数据。

以下示例以命令行终端工具psql为例，所使用的测试表（tbl1）的建表语句如下：

 

```sql
CREATE TABLE tbl1 (
    id SERIAL PRIMARY KEY,
    info TEXT,
    crt_time TIMESTAMP
);
```

#### **方式一：**使用INSERT INTO ... SELECT

示例语句

```sql
-- 向tbl1表中批量插入数据
INSERT INTO tbl1 (id, info ,crt_time) SELECT GENERATE_SERIES(1,10000),'test',NOW(); 

-- 查询数据量
SELECT COUNT(*) FROM tbl1;
```

返回结果

```sql
   count     
  -------    
   10000    
  (1 row)
```

#### **方式二：**使用VALUES(),(),...();

示例语句

```sql
-- 向tbl1表中批量插入数据
INSERT INTO tbl1 (id,info,crt_time) VALUES (1,'test',NOW()), (2,'test2',NOW()), (3,'test3',NOW());

-- 查询数据量
SELECT COUNT(*) FROM tbl1;
```

返回结果

```sql
   count     
  -------    
       3    
  (1 row)
```

#### **方式三：**使用BEGIN; ...多条INSERT...; END;

**说明**

**严格来说，此方式不属于批量，但可以减少事务提交时的同步等待，同样可以提升性能。**

示例语句

```sql
-- 向tbl1表中批量插入数据
BEGIN;
INSERT INTO tbl1 (id,info,crt_time) VALUES (1,'test',NOW()); 
INSERT INTO tbl1 (id,info,crt_time) VALUES (2,'test2',NOW());
INSERT INTO tbl1 (id,info,crt_time) VALUES (3,'test3',NOW());
END; 

-- 查询数据量
SELECT COUNT(*) FROM tbl1;
```

返回结果

```sql
   count     
  -------    
       3    
  (1 row)
```

#### **方式四：使用COPY协议**

**说明：**COPY协议与INSERT协议不一样，更加精简，插入效率高。

示例语句

```sql
-- 从标准输入流中读取数据，并将数据复制到tbl1表中，其中输入数据的不同列使用|分割。
COPY tbl1 FROM stdin WITH (DELIMITER '|');

-- 输入第一条数据
1|'test'|'2023-01-01'
-- 输入第二条数据
2|'test1'|'2023-02-02'
-- 结束
\.

-- 查询数据量
SELECT COUNT(*) FROM tbl1;
```

返回结果

```sql
   count     
  -------    
       2    
  (1 row)
```

**说明**

不同的语言驱动，对应的COPY接口不同，请参见如下文档：

- [PostgreSQL JDBC Driver - JDBC 4.2 9.4.1209 API](https://jdbc.postgresql.org/documentation/publicapi/index.html)
- [PostgreSQL 9.6.2 Documentation — Functions Associated with the COPY Command](https://www.postgresql.org/docs/9.6/static/libpq-copy.html)

### 批量更新数据

示例语句

```sql
-- 批量更新数据
UPDATE tbl1 SET info=tmp.info from (VALUES (1,'new1'),(2,'new2'),(6,'new6')) AS tmp (id,info) WHERE tbl1.id=tmp.id; 

-- 查询表数据
SELECT * FROM tbl1; 
```

返回结果

```sql
 id |     info     |          crt_time            
----+--------------+----------------------------  
  3 | hello        | 2017-04-24 15:31:49.14291  
  4 | digoal0123   | 2017-04-24 15:42:50.912887  
  5 | hello digoal | 2017-04-24 15:57:29.622045  
  1 | new1         | 2017-04-24 15:58:55.610072  
  2 | new2         | 2017-04-24 15:28:20.37392  
  6 | new6         | 2017-04-24 15:59:12.265915  
(6 rows)
```

### 批量删除数据

#### 批量清除部分表数据

示例语句

```sql
-- 批量删除数据
DELETE FROM tbl1 USING (VALUES (3),(4),(5)) AS tmp(id) WHERE tbl1.id=tmp.id; 

-- 查询表数据
SELECT * FROM tbl1;
```

返回结果

```sql
 id |  info   |          crt_time            
----+---------+----------------------------  
  1 | new1    | 2017-04-24 15:58:55.610072  
  2 | new2    | 2017-04-24 15:28:20.37392  
  6 | new6    | 2017-04-24 15:59:12.265915
```

#### 清除全表数据，建议您使用TRUNCATE。

示例语句：

```sql
-- 设置锁超时时间
SET lock_timeout = '1s';

-- 清空名为tbl1的表中的所有数据
TRUNCATE tbl1;

-- 查询表数据
SELECT * FROM tbl1;
```

返回结果

```
 id | info | crt_time   
----+------+----------  
(0 rows)
```

------

## 使用 DBUtil 实现批量插入

#### **方式一：使用 DBUtil.ExecuteSqls() 批量事务插入（推荐）**

这是最推荐的方式，支持事务回滚，性能最优。所有SQL要么全部成功，要么全部回滚。

```java
/**
 * 使用批量事务方式插入数据
 * @return 执行结果
 */
public JSONObject batchInsertWithTransaction() {
    List<String> sqlList = new ArrayList<>();
    
    try {
        // 准备批量插入SQL
        for (int i = 1; i <= 10000; i++) {
            String sql = "INSERT INTO tbl1 (id, info, crt_time) " +
                        "VALUES (" + i + ", 'test" + i + "', current_timestamp)";
            sqlList.add(sql);
        }
        
        // 批量执行（带事务，全部成功或全部回滚）
        JSONObject result = DBUtil.ExecuteSqls("w", "", sqlList);
        
        if (result.has("error")) {
            log.error("批量插入失败：" + result.optString("error"));
        } else {
            log.info("批量插入成功：" + result.optString("re"));
        }
        
        return result;
        
    } catch (Exception e) {
        log.error("批量插入异常", e);
        JSONObject error = new JSONObject();
        error.put("error", e.getMessage());
        return error;
    }
}
```

#### **方式二：使用 DBUtil.insert() 方法（支持 upsert）**

适用于需要判断记录是否存在的场景，存在则更新，不存在则插入。



java

```java
/**
 * 批量插入数据（支持upsert）
 */
public void batchInsertWithUpsert(List<Map<String, Object>> dataList) {
    try {
        int successCount = 0;
        int failCount = 0;
        
        for (Map<String, Object> data : dataList) {
            Integer id = (Integer) data.get("id");
            String info = (String) data.get("info");
            
            String fields = "id,info,crt_time";
            String values = id + ",'" + info + "',current_timestamp";
            
            // 如果id存在则更新，不存在则插入
            String where = "id=" + id;
            
            JSONObject result = DBUtil.insert("w", "", "tbl1", fields, values, where);
            
            if (result.has("error")) {
                log.error("插入失败 id=" + id + "：" + result.optString("msg"));
                failCount++;
            } else {
                successCount++;
            }
        }
        
        log.info("批量插入完成，成功：" + successCount + "，失败：" + failCount);
        
    } catch (Exception e) {
        log.error("批量插入异常", e);
    }
}
```

#### **方式三：使用多行 VALUES 语法批量插入**

直接使用 PostgreSQL 的多行 VALUES 语法，一次性插入多条数据。



java

```java
/**
 * 使用多行VALUES方式批量插入
 */
public JSONObject batchInsertMultipleValues(List<Map<String, Object>> dataList) {
    try {
        StringBuilder sql = new StringBuilder("INSERT INTO tbl1 (id, info, crt_time) VALUES ");
        
        for (int i = 0; i < dataList.size(); i++) {
            if (i > 0) {
                sql.append(",");
            }
            Map<String, Object> data = dataList.get(i);
            Integer id = (Integer) data.get("id");
            String info = (String) data.get("info");
            
            sql.append("(").append(id).append(", '").append(info).append("', current_timestamp)");
        }
        
        log.info("执行批量插入SQL: " + sql.toString());
        
        // 使用 insertSql 方法执行
        JSONObject result = DBUtil.insertSql("w", "", sql.toString());
        
        if (result.has("error")) {
            log.error("批量插入失败：" + result.optString("msg"));
        } else {
            log.info("批量插入成功");
        }
        
        return result;
        
    } catch (Exception e) {
        log.error("批量插入异常", e);
        JSONObject error = new JSONObject();
        error.put("error", e.getMessage());
        return error;
    }
}
```

#### **方式四：使用 DBUtil.insertSql() 循环插入（获取自增ID）**

适用于需要获取每条记录自增ID的场景。



java

```java
/**
 * 循环单条插入（可获取自增ID）
 */
public List<Integer> batchInsertWithGeneratedKeys(List<Map<String, Object>> dataList) {
    List<Integer> generatedIds = new ArrayList<>();
    
    try {
        for (Map<String, Object> data : dataList) {
            String info = (String) data.get("info");
            
            String sql = "INSERT INTO tbl1 (info, crt_time) " +
                        "VALUES ('" + info + "', current_timestamp)";
            
            JSONObject result = DBUtil.insertSql("w", "", sql);
            
            if (result.has("re")) {
                generatedIds.add(result.optInt("re"));
            } else if (result.has("error")) {
                log.error("插入失败：" + result.optString("msg"));
            }
        }
        
        log.info("批量插入完成，生成ID数量：" + generatedIds.size());
        return generatedIds;
        
    } catch (Exception e) {
        log.error("批量插入异常", e);
        return generatedIds;
    }
}
```



## 使用 DBUtil 实现批量更新

### **方式一：使用 DBUtil.ExecuteSqls() 批量事务更新（推荐）**

这是最推荐的方式，支持事务回滚，性能最优。

```java
/**
 * 使用批量事务方式更新数据
 * @param updateDataList 需要更新的数据列表
 * @return 执行结果
 */
public JSONObject batchUpdateWithTransaction(List<Map<String, Object>> updateDataList) {
    List<String> sqlList = new ArrayList<>();
    
    try {
        // 准备批量更新SQL
        for (Map<String, Object> data : updateDataList) {
            Long id = (Long) data.get("id");
            String info = (String) data.get("info");
            
            String sql = "UPDATE tbl1 SET info='" + info + "', altime=current_timestamp WHERE id=" + id;
            sqlList.add(sql);
        }
        
        // 批量执行（带事务，全部成功或全部回滚）
        JSONObject result = DBUtil.ExecuteSqls("w", "", sqlList);
        
        if (result.has("error")) {
            log.error("批量更新失败：" + result.optString("error"));
        } else {
            log.info("批量更新成功：" + result.optString("re"));
        }
        
        return result;
        
    } catch (Exception e) {
        log.error("批量更新异常", e);
        JSONObject error = new JSONObject();
        error.put("error", e.getMessage());
        return error;
    }
}

// 使用示例
public void exampleBatchUpdate() {
    List<Map<String, Object>> updateList = new ArrayList<>();
    
    Map<String, Object> data1 = new HashMap<>();
    data1.put("id", 1L);
    data1.put("info", "new1");
    updateList.add(data1);
    
    Map<String, Object> data2 = new HashMap<>();
    data2.put("id", 2L);
    data2.put("info", "new2");
    updateList.add(data2);
    
    Map<String, Object> data3 = new HashMap<>();
    data3.put("id", 6L);
    data3.put("info", "new6");
    updateList.add(data3);
    
    JSONObject result = batchUpdateWithTransaction(updateList);
}
```

### **方式二：使用 DBUtil.update() 循环更新**

适用于更新数量较少或需要单独处理每条更新结果的场景。

```java
/**
 * 循环批量更新（逐条更新）
 * @param updateDataList 需要更新的数据列表
 */
public void batchUpdateLoop(List<Map<String, Object>> updateDataList) {
    try {
        int successCount = 0;
        int failCount = 0;
        
        for (Map<String, Object> data : updateDataList) {
            Long id = (Long) data.get("id");
            String info = (String) data.get("info");
            
            String setClause = "info='" + info + "'";
            String where = "id=" + id;
            
            JSONObject result = DBUtil.update("w", "", "tbl1", setClause, where);
            
            if (result.has("error")) {
                log.error("更新失败 id=" + id + "：" + result.optString("msg"));
                failCount++;
            } else {
                successCount++;
            }
        }
        
        log.info("批量更新完成，成功：" + successCount + "，失败：" + failCount);
        
    } catch (Exception e) {
        log.error("批量更新异常", e);
    }
}
```

### **方式三：使用 PostgreSQL UPDATE FROM 语法**

直接使用原生 PostgreSQL 的 UPDATE FROM 语法，一次性完成批量更新。

```java
/**
 * 使用PostgreSQL特有的UPDATE FROM语法批量更新
 */
public JSONObject batchUpdateFromValues(List<Map<String, Object>> updateDataList) {
    try {
        // 构建 VALUES 子句
        StringBuilder valuesBuilder = new StringBuilder();
        for (int i = 0; i < updateDataList.size(); i++) {
            if (i > 0) {
                valuesBuilder.append(",");
            }
            Map<String, Object> data = updateDataList.get(i);
            Long id = (Long) data.get("id");
            String info = (String) data.get("info");
            
            valuesBuilder.append("(").append(id).append(",'").append(info).append("')");
        }
        
        // 构建完整SQL
        String sql = "UPDATE tbl1 SET info=tmp.info " +
                    "FROM (VALUES " + valuesBuilder.toString() + ") AS tmp (id,info) " +
                    "WHERE tbl1.id=tmp.id";
        
        log.info("执行批量更新SQL: " + sql);
        
        // 执行SQL
        List<String> sqlList = new ArrayList<>();
        sqlList.add(sql);
        JSONObject result = DBUtil.ExecuteSqls("w", "", sqlList);
        
        if (result.has("error")) {
            log.error("批量更新失败：" + result.optString("error"));
        } else {
            log.info("批量更新成功");
        }
        
        return result;
        
    } catch (Exception e) {
        log.error("批量更新异常", e);
        JSONObject error = new JSONObject();
        error.put("error", e.getMessage());
        return error;
    }
}
```

## 使用 DBUtil 实现批量查找

### **方式一：使用 IN 条件批量查询**

适用于根据多个ID查询数据的场景。

```java
/**
 * 使用IN条件批量查询
 * @param idList 需要查询的ID列表
 * @return 查询结果
 */
public JSONObject batchSelectWithIn(List<Integer> idList) {
    try {
        if (idList == null || idList.isEmpty()) {
            JSONObject error = new JSONObject();
            error.put("error", "查询ID列表为空");
            return error;
        }
        
        // 构建 IN 条件
        StringBuilder idsBuilder = new StringBuilder();
        for (int i = 0; i < idList.size(); i++) {
            if (i > 0) {
                idsBuilder.append(",");
            }
            idsBuilder.append(idList.get(i));
        }
        
        String sql = "SELECT * FROM tbl1 WHERE id IN (" + idsBuilder.toString() + ")";
        
        log.info("批量查询SQL: " + sql);
        
        JSONObject result = DBUtil.selectJSON("w", "", sql);
        
        if (result.has("error")) {
            log.error("批量查询失败：" + result.optString("msg"));
        } else {
            log.info("批量查询成功，查询到 " + result.optInt("length") + " 条数据");
        }
        
        return result;
        
    } catch (Exception e) {
        log.error("批量查询异常", e);
        JSONObject error = new JSONObject();
        error.put("error", e.getMessage());
        return error;
    }
}

// 使用示例
public void exampleBatchSelect() {
    List<Integer> idList = Arrays.asList(1, 2, 3, 4, 5);
    JSONObject result = batchSelectWithIn(idList);
    
    if (result.has("arrdata")) {
        JSONArray dataArray = result.getJSONArray("arrdata");
        for (int i = 0; i < dataArray.length(); i++) {
            JSONObject item = dataArray.getJSONObject(i);
            log.info("查询结果：" + item.toString());
        }
    }
}
```

### **方式二：使用 DBUtil.selectArray() 批量查询返回数组**

返回 JSONArray 格式，更方便遍历处理。

```java
/**
 * 批量查询返回数组格式
 * @param idList 需要查询的ID列表
 * @return JSONArray 结果数组
 */
public JSONArray batchSelectArray(List<Integer> idList) {
    try {
        if (idList == null || idList.isEmpty()) {
            return new JSONArray();
        }
        
        // 构建 IN 条件
        StringBuilder idsBuilder = new StringBuilder();
        for (int i = 0; i < idList.size(); i++) {
            if (i > 0) {
                idsBuilder.append(",");
            }
            idsBuilder.append(idList.get(i));
        }
        
        String sql = "SELECT * FROM tbl1 WHERE id IN (" + idsBuilder.toString() + ") ORDER BY id";
        
        log.info("批量查询SQL: " + sql);
        
        JSONArray result = DBUtil.selectArray("w", "", sql);
        
        log.info("批量查询成功，查询到 " + result.length() + " 条数据");
        
        return result;
        
    } catch (Exception e) {
        log.error("批量查询异常", e);
        return new JSONArray();
    }
}
```

### **方式三：根据多个条件批量查询**

适用于复杂查询条件的场景。

```java
/**
 * 根据多个条件批量查询
 * @param conditionList 条件列表，每个条件包含字段和值
 * @return 查询结果
 */
public JSONObject batchSelectWithConditions(List<Map<String, Object>> conditionList) {
    try {
        if (conditionList == null || conditionList.isEmpty()) {
            JSONObject error = new JSONObject();
            error.put("error", "查询条件列表为空");
            return error;
        }
        
        // 构建 WHERE 条件
        StringBuilder whereBuilder = new StringBuilder();
        for (int i = 0; i < conditionList.size(); i++) {
            if (i > 0) {
                whereBuilder.append(" OR ");
            }
            Map<String, Object> condition = conditionList.get(i);
            whereBuilder.append("(");
            
            boolean first = true;
            for (Map.Entry<String, Object> entry : condition.entrySet()) {
                if (!first) {
                    whereBuilder.append(" AND ");
                }
                whereBuilder.append(entry.getKey()).append("='").append(entry.getValue()).append("'");
                first = false;
            }
            whereBuilder.append(")");
        }
        
        String sql = "SELECT * FROM tbl1 WHERE " + whereBuilder.toString();
        
        log.info("批量查询SQL: " + sql);
        
        JSONObject result = DBUtil.selectJSON("w", "", sql);
        
        if (result.has("error")) {
            log.error("批量查询失败：" + result.optString("msg"));
        } else {
            log.info("批量查询成功，查询到 " + result.optInt("length") + " 条数据");
        }
        
        return result;
        
    } catch (Exception e) {
        log.error("批量查询异常", e);
        JSONObject error = new JSONObject();
        error.put("error", e.getMessage());
        return error;
    }
}
```

### **方式四：分页批量查询**

适用于数据量大，需要分批次查询的场景。

```java
/**
 * 分页批量查询
 * @param pageSize 每页大小
 * @param pageNum 页码（从1开始）
 * @return 查询结果
 */
public JSONObject batchSelectWithPagination(int pageSize, int pageNum) {
    try {
        int offset = (pageNum - 1) * pageSize;
        
        String sql = "SELECT * FROM tbl1 ORDER BY id LIMIT " + pageSize + " OFFSET " + offset;
        
        log.info("分页查询SQL: " + sql);
        
        JSONObject result = DBUtil.selectJSON("w", "", sql);
        
        if (result.has("error")) {
            log.error("分页查询失败：" + result.optString("msg"));
        } else {
            log.info("分页查询成功，第 " + pageNum + " 页，查询到 " + result.optInt("length") + " 条数据");
        }
        
        return result;
        
    } catch (Exception e) {
        log.error("分页查询异常", e);
        JSONObject error = new JSONObject();
        error.put("error", e.getMessage());
        return error;
    }
}

// 批量分页查询所有数据
public List<JSONObject> batchSelectAll(int pageSize) {
    List<JSONObject> allData = new ArrayList<>();
    int pageNum = 1;
    
    try {
        while (true) {
            JSONObject result = batchSelectWithPagination(pageSize, pageNum);
            
            if (result.has("arrdata")) {
                JSONArray dataArray = result.getJSONArray("arrdata");
                
                if (dataArray.length() == 0) {
                    break; // 没有更多数据
                }
                
                for (int i = 0; i < dataArray.length(); i++) {
                    allData.add(dataArray.getJSONObject(i));
                }
                
                pageNum++;
            } else {
                break;
            }
        }
        
        log.info("批量查询完成，共查询到 " + allData.size() + " 条数据");
        
    } catch (Exception e) {
        log.error("批量查询异常", e);
    }
    
    return allData;
}
```

### **方式五：使用 JOIN 批量关联查询**

适用于需要关联多表查询的场景。

```java
/**
 * 批量关联查询
 * @param idList 主表ID列表
 * @return 关联查询结果
 */
public JSONObject batchSelectWithJoin(List<Integer> idList) {
    try {
        if (idList == null || idList.isEmpty()) {
            JSONObject error = new JSONObject();
            error.put("error", "查询ID列表为空");
            return error;
        }
        
        // 构建 IN 条件
        StringBuilder idsBuilder = new StringBuilder();
        for (int i = 0; i < idList.size(); i++) {
            if (i > 0) {
                idsBuilder.append(",");
            }
            idsBuilder.append(idList.get(i));
        }
        
        // 关联查询示例（假设有关联表 tbl2）
        String sql = "SELECT t1.*, t2.detail_info " +
                    "FROM tbl1 t1 " +
                    "LEFT JOIN tbl2 t2 ON t1.id = t2.tbl1_id " +
                    "WHERE t1.id IN (" + idsBuilder.toString() + ")";
        
        log.info("批量关联查询SQL: " + sql);
        
        JSONObject result = DBUtil.selectJSON("w", "", sql);
        
        if (result.has("error")) {
            log.error("批量关联查询失败：" + result.optString("msg"));
        } else {
            log.info("批量关联查询成功，查询到 " + result.optInt("length") + " 条数据");
        }
        
        return result;
        
    } catch (Exception e) {
        log.error("批量关联查询异常", e);
        JSONObject error = new JSONObject();
        error.put("error", e.getMessage());
        return error;
    }
}
```

------

## 使用 DBUtil 实现批量删除(一般用不到)

### **方式一：使用 DBUtil.ExecuteSqls() 批量事务删除（推荐）**

这是最推荐的方式，支持事务回滚，性能最优。所有删除操作要么全部成功，要么全部回滚。

```java
/**
 * 使用批量事务方式删除数据
 * @param deleteIds 需要删除的ID列表
 * @return 执行结果
 */
public JSONObject batchDeleteWithTransaction(List<Integer> deleteIds) {
    List<String> sqlList = new ArrayList<>();
    
    try {
        // 准备批量删除SQL
        for (Integer id : deleteIds) {
            String sql = "DELETE FROM tbl1 WHERE id=" + id;
            sqlList.add(sql);
        }
        
        // 批量执行（带事务，全部成功或全部回滚）
        JSONObject result = DBUtil.ExecuteSqls("w", "", sqlList);
        
        if (result.has("error")) {
            log.error("批量删除失败：" + result.optString("error"));
        } else {
            log.info("批量删除成功：" + result.optString("re"));
        }
        
        return result;
        
    } catch (Exception e) {
        log.error("批量删除异常", e);
        JSONObject error = new JSONObject();
        error.put("error", e.getMessage());
        return error;
    }
}

// 使用示例
public void exampleBatchDelete() {
    List<Integer> deleteIds = Arrays.asList(3, 4, 5);
    JSONObject result = batchDeleteWithTransaction(deleteIds);
}
```

### **方式二：使用 DBUtil.delete() 循环删除**

适用于删除数量较少或需要单独处理每条删除结果的场景。

```java
/**
 * 循环批量删除
 * @param deleteIds 需要删除的ID列表
 */
public void batchDeleteLoop(List<Integer> deleteIds) {
    try {
        int successCount = 0;
        int failCount = 0;
        
        for (Integer id : deleteIds) {
            String where = "id=" + id;
            
            JSONObject result = DBUtil.delete("w", "", "tbl1", where);
            
            if (result.has("error")) {
                log.error("删除失败 id=" + id + "：" + result.optString("msg"));
                failCount++;
            } else {
                successCount++;
                log.info("删除成功 id=" + id + "，影响行数：" + result.optInt("re"));
            }
        }
        
        log.info("批量删除完成，成功：" + successCount + "，失败：" + failCount);
        
    } catch (Exception e) {
        log.error("批量删除异常", e);
    }
}
```

### **方式三：使用 IN 条件批量删除（推荐）**

一次性删除多条记录，适用于删除条件简单的场景，性能优于循环删除。

```java
/**
 * 使用IN条件批量删除
 * @param deleteIds 需要删除的ID列表
 * @return 执行结果
 */
public JSONObject batchDeleteWithIn(List<Integer> deleteIds) {
    try {
        if (deleteIds == null || deleteIds.isEmpty()) {
            JSONObject error = new JSONObject();
            error.put("error", "删除ID列表为空");
            return error;
        }
        
        // 构建 IN 条件
        StringBuilder idsBuilder = new StringBuilder();
        for (int i = 0; i < deleteIds.size(); i++) {
            if (i > 0) {
                idsBuilder.append(",");
            }
            idsBuilder.append(deleteIds.get(i));
        }
        
        String where = "id IN (" + idsBuilder.toString() + ")";
        
        log.info("批量删除条件: " + where);
        
        JSONObject result = DBUtil.delete("w", "", "tbl1", where);
        
        if (result.has("error")) {
            log.error("批量删除失败：" + result.optString("msg"));
        } else {
            log.info("批量删除成功，影响行数：" + result.optInt("re"));
        }
        
        return result;
        
    } catch (Exception e) {
        log.error("批量删除异常", e);
        JSONObject error = new JSONObject();
        error.put("error", e.getMessage());
        return error;
    }
}
```

### **方式四：使用 PostgreSQL DELETE USING 语法**

直接使用原生 PostgreSQL 的 DELETE USING 语法，适用于大批量删除。

```java
/**
 * 使用PostgreSQL特有的DELETE USING语法批量删除
 * @param deleteIds 需要删除的ID列表
 * @return 执行结果
 */
public JSONObject batchDeleteUsingValues(List<Integer> deleteIds) {
    try {
        if (deleteIds == null || deleteIds.isEmpty()) {
            JSONObject error = new JSONObject();
            error.put("error", "删除ID列表为空");
            return error;
        }
        
        // 构建 VALUES 子句
        StringBuilder valuesBuilder = new StringBuilder();
        for (int i = 0; i < deleteIds.size(); i++) {
            if (i > 0) {
                valuesBuilder.append(",");
            }
            valuesBuilder.append("(").append(deleteIds.get(i)).append(")");
        }
        
        // 构建完整SQL
        String sql = "DELETE FROM tbl1 USING (VALUES " + valuesBuilder.toString() + 
                    ") AS tmp(id) WHERE tbl1.id=tmp.id";
        
        log.info("执行批量删除SQL: " + sql);
        
        // 执行SQL
        List<String> sqlList = new ArrayList<>();
        sqlList.add(sql);
        JSONObject result = DBUtil.ExecuteSqls("w", "", sqlList);
        
        if (result.has("error")) {
            log.error("批量删除失败：" + result.optString("error"));
        } else {
            log.info("批量删除成功");
        }
        
        return result;
        
    } catch (Exception e) {
        log.error("批量删除异常", e);
        JSONObject error = new JSONObject();
        error.put("error", e.getMessage());
        return error;
    }
}
```

### **方式五：根据条件批量删除**

适用于需要根据复杂条件删除数据的场景。

```java
/**
 * 根据条件批量删除
 * @param conditions 删除条件，多个条件用 AND 连接
 * @return 执行结果
 */
public JSONObject batchDeleteWithConditions(Map<String, Object> conditions) {
    try {
        if (conditions == null || conditions.isEmpty()) {
            JSONObject error = new JSONObject();
            error.put("error", "删除条件为空");
            return error;
        }
        
        // 构建 WHERE 条件
        StringBuilder whereBuilder = new StringBuilder();
        boolean first = true;
        for (Map.Entry<String, Object> entry : conditions.entrySet()) {
            if (!first) {
                whereBuilder.append(" AND ");
            }
            whereBuilder.append(entry.getKey()).append("='").append(entry.getValue()).append("'");
            first = false;
        }
        
        String where = whereBuilder.toString();
        
        log.info("批量删除条件: " + where);
        
        JSONObject result = DBUtil.delete("w", "", "tbl1", where);
        
        if (result.has("error")) {
            log.error("批量删除失败：" + result.optString("msg"));
        } else {
            log.info("批量删除成功，影响行数：" + result.optInt("re"));
        }
        
        return result;
        
    } catch (Exception e) {
        log.error("批量删除异常", e);
        JSONObject error = new JSONObject();
        error.put("error", e.getMessage());
        return error;
    }
}

// 使用示例
public void exampleBatchDeleteByConditions() {
    Map<String, Object> conditions = new HashMap<>();
    conditions.put("status", "0");
    conditions.put("crt_time", "2024-01-01");
    
    JSONObject result = batchDeleteWithConditions(conditions);
}
```

### **方式六：清空全表数据（TRUNCATE）**

如果需要清空整张表的数据，建议使用 TRUNCATE，性能远优于 DELETE。

```java
/**
 * 清空表数据（TRUNCATE）
 * @param tableName 表名
 * @return 执行结果
 */
public JSONObject truncateTable(String tableName) {
    try {
        String sql = "TRUNCATE TABLE " + tableName;
        
        log.info("执行清空表SQL: " + sql);
        
        List<String> sqlList = new ArrayList<>();
        sqlList.add(sql);
        JSONObject result = DBUtil.ExecuteSqls("w", "", sqlList);
        
        if (result.has("error")) {
            log.error("清空表失败：" + result.optString("error"));
        } else {
            log.info("清空表成功");
        }
        
        return result;
        
    } catch (Exception e) {
        log.error("清空表异常", e);
        JSONObject error = new JSONObject();
        error.put("error", e.getMessage());
        return error;
    }
}
```

------

## 性能对比和最佳实践

### **各方案性能对比**

| 操作类型 | 方案            | 性能  | 事务支持 | 适用场景       |
| -------- | --------------- | ----- | -------- | -------------- |
| 批量插入 | ExecuteSqls()   | ⭐⭐⭐⭐⭐ | ✅        | 大批量插入     |
| 批量插入 | 多行VALUES      | ⭐⭐⭐⭐  | ❌        | 中等批量插入   |
| 批量插入 | insert() upsert | ⭐⭐⭐   | ❌        | 需要判断存在性 |
| 批量更新 | ExecuteSqls()   | ⭐⭐⭐⭐⭐ | ✅        | 大批量更新     |
| 批量更新 | UPDATE FROM     | ⭐⭐⭐⭐⭐ | ❌        | 一次性批量更新 |
| 批量查询 | IN 条件         | ⭐⭐⭐⭐  | -        | 简单ID查询     |
| 批量查询 | JOIN 关联       | ⭐⭐⭐   | -        | 多表关联查询   |
| 批量删除 | IN 条件         | ⭐⭐⭐⭐  | ❌        | 简单批量删除   |
| 批量删除 | DELETE USING    | ⭐⭐⭐⭐⭐ | ❌        | 大批量删除     |
| 清空表   | TRUNCATE        | ⭐⭐⭐⭐⭐ | -        | 清空整表       |

### **最佳实践建议**

1. **批量插入推荐**：优先使用 `ExecuteSqls()` 批量事务插入，数据安全且性能好
2. **批量更新推荐**：使用 `UPDATE FROM` 语法或 `ExecuteSqls()`，避免循环更新
3. **批量查询推荐**：使用 `IN` 条件，注意 IN 列表不要过长（建议不超过1000个）
4. **批量删除推荐**：使用 `IN` 条件或 `DELETE USING` 语法
5. **注意 SQL 注入**：所有用户输入都要做好转义处理
6. **事务控制**：重要操作务必使用 `ExecuteSqls()` 保证事务一致



