# 系统架构

WHOAMI支撑平台是补天公司拥有完全自主知识产品，采用“基于网络应用系统架构”与“软件开发架构”无缝结合的基于规则的壳模型多层体系架构基础平台，是在充分考虑和融合各类异质平台特点、敏捷软件开发技术以及CMMI模型中关键过程域、目标、方法基础上提出的，经过多年开发、应用并完善的创新性公司架构平台。平台架构如下图 。

![image.png](https://share.apifox.cn/api/v1/projects/3990113/resources/450645/image-preview?onlineShareType=shareDoc&locale=zh-CN)
WHOAMI架构最大特点是将开发中不变性因素与可变性因素精准统一，即：规则、模块、架构不变性表现、数据的可变性的精准统一，达到重用代码、完善架构与专注需求的完美统一。
在WHOAMI架构的优势：

安全，独特的“请求字典”模式，让任何侵犯无懈可击。

速度快，所有页面均为静态页面，静中含动，即静态中通过异步通信技术取得数据，不传输冗余代码，保证数据传输量最小。

快速开发，WHOAMI架构基本原则要求“以实现敏捷开发与CMMI模型规范作为指导思想”，并在架构实现过程中始终严格贯彻，将开发的信息系统中不变性因素与可变性因素进行精确分离，使得开发过程专注于可变因素——表现层和数据层，专注于需求，而可变因素在架构中只要进行极少规则/模块调整或者不进行任何调整即可成形、完善，因此采用产品化项目开发模式，实现系统性能质量可控、开发过程可控，极大降低了软件开发管理复杂度和难度，提高了开发进度，更好实施敏捷开发要求的“经常性交付”迭代开发过程。使用WHOAMI架构开发系统速度比常规开发提高40-60%。

# 规则介绍

Web端按照固定格式发送ajax请求 ，后台解析，处理后返回值。

## JAR包配置

pom.xml 引用com.btjkframe.whoami包

```xml
<dependency>
    <groupId>com.btkjframe</groupId>
    <artifactId>whoami-java</artifactId>
    <version>3.0.1</version>
</dependency>

或

使用starter自动注入配置
<dependency>
    <groupId>com.btkjframe</groupId>
    <artifactId>whoami-spring-boot-starter</artifactId>
    <version>3.0.1</version>
</dependency>
```

## 配置数据库

resource目录下 application.yml 配置文件

```yaml
# 项目相关配置
whoami:
  # 名称
  name: 项目名
  # 版本
  version: 3.0.1
  # 版权年份
  copyrightYear: 2024
  # 文件路径 示例（ Windows配置D:/uploadPath，Linux配置 /home/uploadPath）
  profile: D:/uploadPath
  # 获取ip地址开关
  addressEnabled: false

  # 数据库配置
  db:
    # 是否刷新消息，开发环境打开
    isReloadMsg: 1
    # 延迟刷新秒数
    delaySeconds: 30
    # 检测刷新间隔时间秒数
    sleepSeconds: 3
    # 是否密码加密
    isDecrypt: 
    # 数据读取扩展，结合MyRuleDefineImpl.msgExtend使用
    msgExtend:
    # 默认数据库标识
    defaultdbtype: w
    # 默认数据库连接字符串，分库访问时使用，单库可不传
    defaultdbdid:
    # 数据库类型，多个类型代表多个数据库源
    w:
      # 数据库类型，不传默认pg
      dbtype: pg
      # 连接url
      url: jdbc:postgresql://192.168.1.115:38593/
      # 数据库；分库时代表数据库前缀
      prefix: admin
      # 用户名
      username: postgres
      # 密码
      pwd: nwbt@123
      # 连接池初始化数
      initialSize: 1
      # 连接池最小数
      minIdle: 1
      # 连接池最大数
      maxActive: 1
    # 举例分库形式
    y:
      # 分库形式，总库需包含【server】表，包含字段【serverip,dbpost,dbusername,dbpassword,initialsize,minidle,maxactive】
      # 数据库前缀
      prefix: tb_y_
      # 去哪个数据库类型获取连接参数
      maintype: w 
      # 去哪个关联表获取连接参数
      maintable: yey
      # 用哪个字段关联获取
      maincolumn: guid
      
  # token配置
  token:
    # 令牌自定义标识
    header: Authorization
    # 令牌密钥
    secret: abcdefghijklmnopqrstuvwxyz
    # 令牌有效期（默认30分钟）
    expireTime: 30

  # 密码检验
  password:
    # 密码最大错误次数
    maxRetryCount: 5
    # 密码锁定时间（默认10分钟）
    lockTime: 10

  # OSS上传参数
  oss:
    # ID参数
    OSS_ACCESS_ID:
    # 密钥
    OSS_ACCESS_KEY:
    # 请求地址
    OSS_URI:
    # bucket名称
    OSS_BUCKETNAME:
```

## 消息说明

resources目录下的msg 文件夹下的xml文件

```xml
<msg id="demo.1" type="" v="" d="w"  did="">
    <where idx="0">
        <p key="id">and id={0}</p>
    </where>
</msg>
<msg id="demo.2" type="" v="" d="w"  did="">
    <include id=""/>
    <include id=""/>
</msg>
```

xml标签共包含：***msg、where、p、include*** 四种标签，说明如下：

### **msg标签参数说明**

| 序号 | 参数         | 名称                     | 示例说明                                                     |
| :--- | :----------- | :----------------------- | :----------------------------------------------------------- |
| 1    | id           | 消息id                   | 页面名+消息名                                                |
| 2    | type         | 消息类型                 | 参见[消息类型](https://share.apifox.cn/url)                  |
| 3    | v            | 消息内容                 | -                                                            |
| 4    | d            | 数据库类型               | 默认缺省为potgres数据库                                      |
| 5    | did          | 数据库标识               | 分库数据库标识                                               |
| 6    | rpc          | 对外系统提供服务         | 标识调用方系统名称                                           |
| 7    | colnull      | 针对数据库数字类型的null | selectonejson返回的是0问题，个别消息如果想返回空字符串，消息体上增加 colnull="true" 属性 |
| 8    | colstr       | 数据库字段类型读取方式   | true时按照字符串读取，避免json字符串返回前台精度丢失，如浮点型4.10 返回 4.1问题 |
| 9    | seer         | 可视化数据范围           | 针对查询类消息，表示此消息需要控制可视化数据范围，使用角色范围权限控制 （本人、本部门、本部门及下级、所有） |
| 10   | maintable    | 对应多表联合查询时主表   | 对应多表联合查询时，自动拼接条件，字段所属表，如w_user.id=1  |
| 11   | perms        | 功能权限                 | 多个权限用英文逗号分隔，如：sys:user:list,sys:user:sel       |
| 12   | title        | 功能名称                 | 写操作日志@Log注解所需，写此参数自动写操作日志               |
| 13   | businesstype | 业务操作类型             | 写操作日志@Log注解所需，如：OTHER（其他）、INSERT（新增）、UPDATE（修改）、DELETE（删除）、GRANT（授权）、EXPORT（导出）、INPORT（导入）、FORCE（强退）、CLEAN（清空） |
| 14   | classMethod  | 后台处理方法             | 支持调用后台方法，类需要实现com.whoami.service.Rule接口，方法固定参数(String[] p, String[] cp, HttpServletRequest request) 例如： classMethod="com.alotlove.zxxpt.auth.AppUtils.getApp" |

*其中 v、d和did的值允许接收前台传递参数 例如示例中#0#,#1#,#2# 对应sm的数组的第二,第三，第四个参数*

### **where标签参数说明**

消息where标签，在msg标签内部使用，支持各种条件、格式拼装，满足不同场景需求；

| 序号 | 参数        | 名称         | 示例说明                                                     |
| :--- | :---------- | :----------- | :----------------------------------------------------------- |
| 1    | idx         | 唯一标识     | 数字类型，对应消息中#?#参数位                                |
| 2    | join        | 连接符       | 多条件拼装使用，如：or、and                                  |
| 3    | prefix      | 拼装前缀     | 和join结合用 拼装前缀                                        |
| 4    | suffix      | 拼装后缀     | 和join结合用 拼装后缀                                        |
| 5    | default     | 默认值       | 默认值，如标签为空，默认拼接内容                             |
| 6    | classMethod | 后台返回条件 | 支持调用后台方法返回条件，便于后台控制条件，提高安全性；类需实现com.whoami.service.WhereRule接口，方法固定参数(Msg msg, String idx, String pmparam, ReqData req) 返回JSONObject带re或error属性 |

> 💡
>
> 1.其中规则layuitable对应idx为*laywhere*；flexigrid对应idx为*gridwhere*；inserjson\updatejson 对应idx为*columns*;
> 2.整体返回：如果不带join，判断拼接后的为空时，如果带default，值为 default ；
> 如果带join参数，判断拼接后的为空时，如果带default，值为 prefix + default + suffix ；
> 3.使用classMethod方法，将忽略where标签下其他条件。

```java
<msg id="msg.getusers" type="selectjson" v="select * from w_user where isdel=0 #0#">
    <where idx="0" classMethod="com.whoami.xxxx.WhereRuleUtils.getMsgWhere">
    </where>
</msg>

import com.whoami.entity.Msg;
import com.whoami.entity.ReqData;
import com.whoami.service.WhereRule;
import org.json.JSONObject;

/***
 * 扩展where标签后台条件
 */
public class WhereRuleUtils implements WhereRule {

    public static JSONObject getMsgWhere(Msg msg, String idx, String pmparam, ReqData reqData) {
        JSONObject resObj = new JSONObject();
        String roletype = "s";
        resObj.put("re", "and roletype='" + roletype + "'");
        return new JSONObject();
    }
}
```

### **p标签参数说明**

消息p标签，在where标签内部使用，支持各种条件、格式拼装，满足不同场景需求；

| 序号 | 参数     | 名称                                | 示例说明                                                     |
| :--- | :------- | :---------------------------------- | :----------------------------------------------------------- |
| 1    | key      | 唯一标识                            | 对应外部参数键值                                             |
| 2    | join     | 连接符                              | 多条件拼装使用，如：or、and                                  |
| 3    | prefix   | 拼装前缀                            | 和join结合用 拼装前缀                                        |
| 4    | suffix   | 拼装后缀                            | 和join结合用 拼装后缀                                        |
| 5    | default  | 默认值                              | 默认值，如标签为空，默认拼接内容                             |
| 6    | format   | 格式属性                            | 支持 ，int、long、float、decimal、boolean、string、date、timestamp、repcomma（如有其他类型可联系新增） |
| 7    | decode   | 是否decode                          | 值：1 ；前端数据encode后，后端自动decode                     |
| 8    | encode   | 是否encode                          | 值：1；增加后自动encode                                      |
| 9    | 模板参数 | 模版参数，对应format="repcomma"使用 | 外扩模板，支持更复杂语句拼装，注意模板名称不能和上面属性同名 |

> 📌1.format 支持 ，int、float、decimal、boolean、string、date、timestamp（如有其他类型可联系新增）、值为repcomma, 针对forminsert规则传入字符串参数数值 将逗号替换____，否则会报字段和字段值数目不一致
>
> 2.p标签增加多模版处理，开发过程中可能遇到拼接or条件，但每个条件不一样，可以用此方式拼装。p标签传固定值#{template}

> 💡
> 前端调用，二维数组第一位为模板的key，模板参数位值从{1}开始，如下：

```js
<p key="poplabel" join="or" prefix=" and (" suffix=")" muid="t.muid > 0" yeystate="t.yeysetstate ={1}">#{template}</p>

var objwhere = {
    poplabel: [
        ["muid"],
        ["yeystate", 2],
        ["yeystate", 1],
    ]
};
执行结果： and (t.muid > 0 or t.yeysetstate = 2 or t.yeysetstate = 1)
```

### **include标签参数说明**

消息include标签，在msg标签内部使用，配合消息类型为**batch、batchtrans、batchtransdb**使用，标识一组批量消息，包含哪些子语句；

| 序号 | 参数          | 名称                 | 示例说明                                                     |
| :--- | :------------ | :------------------- | :----------------------------------------------------------- |
| 1    | id            | 子消息id             | 对应消息中id参数位                                           |
| 2    | insertkeys    | 插入哪些字段特殊处理 | 逗号分隔；哪些字段需要引用其他消息返回值，如：depart_id,post_id |
| 3    | insertfromids | 读取哪些消息返回值   | 逗号分隔；对应insertkeys插入返回值，如：deptlist.add,postlist.add |

> 💡1.前端要按照执行先后顺序拼装arrmsg消息，被引用的消息要先执行；
>     2.当前引用值默认找前面执行insertfromids消息的最后一条取返回值；
> 支持形态：abbb, ababab,abcabc

### **消息格式示例及说明**

```xml
<msg id="system.select" type="select" v="select id,uname from w_user where isdel=0 and guid='#0#' #1# #2#">
    <where idx="1"><!--对应消息中#1#-->
        <p key="key1">and isdel=0 and id={0}</p><!--对应前端where条件-->
        <p key="key2">and isdel={0} and id={1}</p>
        <p key="key3">and isdel=0 and truename='{0}'</p>
        <p key="key4">and isdel=0</p>
        <p key="key5" join="or" prefix=" and (" suffix=")">and isdel=0</p>
        <p key="key6" format="date">'{0}'</p>
    </where>
</msg>
```

#### 1.p标签增加format参数,值为date,外部不需要判断值是否为空拼接单引号，传“”或null均可

```xml
    <where idx="0">
        <p key="workdate" format="date">'{0}'</p>
    </where>
    <!--前端调用$.msgwhere({workdate: [workdate || null]});-->
```

#### 2.p标签增加default参数,如果p标签最后结果是空字符串，会使用default内容代替，按需使用

```xml
    <where idx="0">
        <p key="workdate" join="," default="''">'{0}'</p>
    </where>
    <!--结果：select * from table where isdel=0 and workdate in('')-->
    <!--前端调用$.msgwhere({workdate: []});-->
```

#### 3.p标签join 标识支持or and , 等sql字符; prefix和suffix可以在主消息上面写，代表此消息一定拼接，也可以在p标签传入，代表p条件有值才使用此条件。

```xml
例1：想拼接 and classno in ('Ub0001','Ub0002','Ub0003'...);
wherestr += " and classno in (" + StringUtils.join(result, ",") + " )";
<p key="key5" join="," prefix=" and classno in(" suffix=")">'{0}'</p>
前端传入："key5"：[['Ub0001'],['Ub0002'],['Ub0003']],

例2：想拼接 and ((foodone='大米' and foodtwo='白面') or (foodone='白面' and foodtwo='大米')...)
<p key="key5" join="or" prefix=" and (" suffix=")">(foodone='{0}' and foodtwo='{1}')</p>
前端传入："key5"：[['大米','白面'],['白面','大米'],...],

例3：想拼接 foodone='大米' and foodone='白面' ...
<p key="key5" join="and">foodone='{0}'</p>
前端传入："key5"：[['大米'],['白面'],...],

例4：prefix 和 suffix支持参数传入，通过二维数组第一位参数，放在join参数位后面
<p key="key5" join="or" prefix=" and foodone!='{2}' and (" suffix=")">(foodone='{0}' and foodtwo='{1}')</p>
前端传入："key5"：[
                ['大米','白面', '玉米渣'],
                ['白面','大米'],
        ...],
```

#### 4.增加decode参数，如果有拼接是json的前端可以encodeURIComponent 一下，后台会decode回来

```xml
<p key="strdevalue" decode="1">'{0}'</p>
```

#### 5.where注解：join组合条件标识，对应前端多个不定个数条件处理，按顺序拼接，对于有顺序要求、或有多个不定参数消息使用。

```js
    where标签join 标识支持or and , 等sql字符
    prefix和suffix 前缀、后缀 按需传入，无值可以不传人参数。
    如果传入join参数必须按此方式调用，前端调用方式：
    $.msgArrwhere([
        {key1: [1]},
        {key2: [2]},
        {key3: [3]}
        ...
    ]); 
    注意：join、prefix、suffix 为消息系统关键字，消息key取值不能使用关键字。
```

### **前端发送说明**

```js
$.sm(function (re, err) {
    alert(re);
}, ["system.select", "",
    $.msgwhere({         //对应#1#参数，对应where:idx=1标签
        "key1"：[25],    //对应where标签下第一个p，数组内对应标签内占位符，如果标签内没有占位符，传入空数组；
        "key2"：[0, 25], //对应where标签下第二个p；0填入{0}，25填入{1}；
        "key3"：['张三']，//对应where标签下第三个p；传入字符串；         
        "key4"：[]，      //对应where标签下第四个p；传入空代表无占位符；
"key5"：[['大米'],['白面'],...]     
}),      
    $.msgwhere({         //对应#2#参数，对应where:idx=2标签
        "key1"：[25]     //同上注释
    });
]);
```

> 💡注意：
> ①where标签idx=1对应消息中的#1#，后台会解析替换到#1#处；
> ②前端发送消息#1#处传参是object类型，只有msg_where开头；如果不带，将按照传入内容拼接；
> ③为了安全，后期开发框架要求前端不能出现sql语句；

### **后端接收说明**

> 💡后端需要自写接收方式，Servlet 或 Controller 接收ajax请求，调用消息机制处理
> 参见whoami-spring-boot-starter Controller接收方式