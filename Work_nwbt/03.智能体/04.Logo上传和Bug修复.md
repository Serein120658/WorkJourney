# Logo上传

不知道有没有现成的接口,通过提供过来的spring-boot-admin 测试项目 
发现，对于上传貌似都没有封装好相应的接口

看提供的文档里面也没有相应的介绍，需要问一下李总

是自己写接口，然后将文件使用流的方式去存储到某个文件夹下呢？还是？

正常的情况下，上传文件，

按照现在的逻辑上传成功是会返回部分文件信息，然后去渲染的

需要去询问一下大佬了，😔

通过询问，了解到前端是有专门的工具类去接收的  uploadutil.js

该工具类中有一个方法   uploadFileUtil 用的是别的方法

```js
/**
 * 上传file
 * @param options oss配置
 * @param islocal 是否上传到本地
 * @param file 上传的文件
 * @param updir 保存到的文件夹
 * @param cb 上传完回调
 */
function uploadFileUtil(options, file, updir, progressCb, cb) {....}
```

![image-20250829103155002](04.Logo上传和Bug修复.assets/image-20250829103155002.png)

目前就知道在工具类中调用到了，但是对应的方法却没有被调用过

现在不好操作的地方就是  uploadUtil组件   与  layui中的 upload组件  有小冲突

![image-20250829105959061](04.Logo上传和Bug修复.assets/image-20250829105959061.png)

不知该如何修改

![image-20250829140629054](04.Logo上传和Bug修复.assets/image-20250829140629054.png)

按照上面的去实现，发现一直都出一个问题   <font color="red">未找到上传数据</font>

这就真不知道如何解决了   啊西巴

同样的代码，在飞哥那边没问题，在自己电脑这里传不了

## logo上传

编辑回显   展示logo  待补充

> 疑问点： 使用一样的工具类，为什么上传不成功？？？
>
> 使用oss传递文件到文件服务器

通过查看ueditorController  接口  这是前端上传工具类请求的接口，我们在后端查看相应的返回值后
![image-20250901142048620](04.Logo上传和Bug修复.assets/image-20250901142048620.png)

如图中的返回值，必定含有上传成功的url链接，然后我们在前端上传成功后得到cb(re)

而re 中含有url   给到我们要传递的地址即可



由于islocal是true  也就是上传到的本地的映射地址  

整体的上传逻辑是  用户上传文件  ----> 到服务器(java)   ---->  oss服务器  但是

由于会消耗额外的流量，因此已经不再实现了



**新的实现思路(这是一般个人用户去实现的)：**

创建一个controller  编写一个接口  使用文件流去读取文件  
再上传到oss

问题1



**企业用户采用的是服务端签名之后直接传递**  

目前项目里面也有签名的消息





那么前端就还得回归原来的上传方式

```js
upload.render({
    elem: '#uploadBtn',
    url: '/upload/image', // 这里需要替换为实际的上传接口
    accept: 'images',
    acceptMime: 'image/png,image/jpg,image/jpeg',
    size: 1024, // 1MB
    before: function(obj) {
        // 预读本地文件示例，不支持ie8
        obj.preview(function(index, file, result) {
            $('#imagePreview').attr('src', result).show();
            $('#uploadArea').hide();
        });
    },
    done: function(res) {
        // 如果上传失败
        if (res.code > 0) {
            return layer.msg('上传失败');
        }
        // 上传成功，保存图片地址
        uploadedImageUrl = res.data.url || res.url; // 根据实际接口返回字段调整
        console.log('上传成功：', res);
        layer.msg('图片上传成功');
    },
    error: function() {
        // 演示失败状态，并实现重传
        layer.msg('上传失败，请重试');
        $('#uploadArea').show();
        $('#imagePreview').hide();
    }
});
```

## 小bug

使用layuitable类型的时候使用了group by 去分组拿到节点数量没问题  因为一开始没有条件

此时，添加搜索功能  传递了参数  出现了错误  ，因为where出现在了gruop by 之后

```xml
<msg id="w_agent.getList" type="layuitable"
     v="ag.id, ag.agent_name, ag.logo, ag.description, ag.function_type, ag.status,
        ag.display_format, ag.applicable_end, ag.applicable_role, ag.time_granularity,
        ag.creatime, ag.altime, ag.display_sort, count(agn.id) AS num
        %16 w_agent AS ag left join w_agent_node AS agn on agn.agent_id = ag.id AND agn.isdel = 0
        %16 ag.isdel = 0
        GROUP BY ag.id, ag.agent_name, ag.logo, ag.description, ag.function_type, ag.status,
        ag.display_format, ag.applicable_end, ag.applicable_role, ag.time_granularity,
        ag.creatime, ag.altime, ag.display_sort">
    <where idx="laywhere">
        <p key="agentName">and ag.agent_name like '%{0}%'</p>
        <p key="status">and ag.status = {0}</p>
    </where>
</msg>
```

上面的问题要想和group by结合时，就必须要在where子句之前，但是这部分不太会加  ？？？？

需要去看看文档   看文档 后需要使用%16  分隔符  去

![image-20250902095736590](04.Logo上传和Bug修复.assets/image-20250902095736590.png)

代码修改后：

```xml
<msg id="w_agent.getList" type="layuitable"
     v="ag.id, ag.agent_name, ag.logo, ag.description, ag.function_type, ag.status,
        ag.display_format, ag.applicable_end, ag.applicable_role, ag.time_granularity,
        ag.creatime, ag.altime, ag.display_sort, count(agn.id) AS num
        %16 w_agent AS ag left join w_agent_node AS agn on agn.agent_id = ag.id AND agn.isdel = 0
        %16 ag.isdel = 0 %16 ag.id, ag.agent_name, ag.logo, ag.description, ag.function_type, ag.status,
        ag.display_format, ag.applicable_end, ag.applicable_role, ag.time_granularity,
        ag.creatime, ag.altime, ag.display_sort">
    <where idx="laywhere">
        <p key="agentName">and ag.agent_name like '%{0}%'</p>
        <p key="status">and ag.status = {0}</p>
    </where>
</msg>
```

## 最后实现

**还是使用了uploadFileUtil() ，下面的六个大问题  我说白了，不了解还真解决不了**  

![image-20250902153745204](04.Logo上传和Bug修复.assets/image-20250902153745204.png)

### 之前之所以没有上传成功

1. uploadFileUtil 中的islocal 设置的是true  也就意味着，文件走的是存储到本地，而且islocal 是全局变量，
   沟通之后将islocal 全局变量由true  修改为 false

2. oss的配置在yml文件中是没有配置    经过李总提交后传递了

3. 关于oss的依赖没有添加   在此之前自己已经尝试过了 添加依赖  但是在.m2文件夹下的setting.xml文件设置了获取jar包的地址 必须走公司的地址  因此没有添加成功  白建立  相关的controller 了

   ![image-20250902153604329](04.Logo上传和Bug修复.assets/image-20250902153604329.png)

4. 消息体 oss.getapptoken 获取oss上传的签名是注释了的，所以每次走到这部分都会报错 
   ![image-20250902152857688](04.Logo上传和Bug修复.assets/image-20250902152857688.png)

5. myrule2 这个消息类型本就不支持
   ![image-20250902153856781](04.Logo上传和Bug修复.assets/image-20250902153856781.png)

   就导致了请求消息体是不可能请求成功的，解决办法呢就是把myrule2 修改为 myrule

6. OSS.Wrapper()  没有在html文件中引入 ，而且在相应的js里面也没有引入相应的js

   说明：OSS.Wrapper() 是在oss的sdk 里面的，所以需要在插件中应用(但是之前引入G6图标的js的时候在js文件中引入就成功了，为什么这里还需要在html中加入呢？)  在js文件中再次引入对应的js

   ![image-20250902153222604](04.Logo上传和Bug修复.assets/image-20250902153222604.png)

   ![image-20250902153506930](04.Logo上传和Bug修复.assets/image-20250902153506930.png)



#### 效果

![image-20250902154106552](04.Logo上传和Bug修复.assets/image-20250902154106552.png)

上传文件的代码：

```js
upload.render({
    elem: '#uploadBtn',
    type: 'choose',
    accept: 'images',
    acceptMime: 'image/png,image/jpg,image/jpeg',
    auto: false,
    size: 1024,
    number: 1,
    choose: function(obj) {
        obj.preview(function(index, file, result) {
            var options = {
                region: 'oss-cn-beijing',
                bucket: bucketName,
                path: uploadPrefix + '/agent',
            };
            layer.msg('正在上传...', {icon: 16, time: 0});
            uploadFileUtil(options, file, null, null, function(uploadRes) {
                layer.closeAll('msg');
                console.log('上传结果：', uploadRes);

                if (uploadRes && uploadRes.res.status === 200) {
                    // 存储返回的name   前端拼接 ossPrefix + name  数据库存储name即可
                    var ossUrl = ossPrefix + uploadRes.name;
                    $('#imagePreview').attr('src', ossUrl).show();
                    $('#uploadArea').hide();
                    objdata.uploadedImageUrl = uploadRes.name;
                    layer.msg('图片上传成功');
                } else {
                    layer.msg('上传失败，请重试');
                    $('#uploadArea').show();
                    $('#imagePreview').hide();
                }
            });
        });
    },
    done: function(res) {
        console.log('done 回调触发：', res);
        if (res.status !== 200) {
            return layer.msg('上传失败');
        }
        layer.msg('图片上传成功');
    },
    error: function() {
        layer.msg('服务错误，请一会重试');
        $('#uploadArea').show();
        $('#imagePreview').hide();
        objdata.uploadedImageUrl = null;
    }
});
```

# Bug修复

## 节点回显

原始的父节点id 我想着比较多，就设置为输入的方式，但是原型提供的是下拉框，那就只能修改了

这次使用批量发送消息的方式去一次获得数据

**节点列表封面显示有问题**

## 智能体回显

回显保存的时候，封面必须选择一个才能提交，否则也没有显示，理想的效果应该是，编辑根据得到的logo 是否为纯数字  

现在的回显是有问题的，根据logo的值的类型来专门回显

## html节点

1. 问题1：初始没有节点的时候，在工具栏添加按钮点击添加节点后，画布没有显示，刷新也没有用

   通过对原有的渲染G6图标的js文件进行分析得到了

   > 我们在初始化页面的时候，会先loadAllNodeData  加载节点数据并渲染，但是没有数据的时候就直接给返回了
   >
   > ```
   > hideLoading();
   > if (!objdata.nodeRelationDataHTML || objdata.nodeRelationDataHTML.nodes.length === 0) {
   >     showEmptyState();
   >     return;
   > }
   > ```

2. 问题2：在展开编辑保存提交后，关闭了所有的弹窗，理论上应该是刷新画布

经历这么多次的调整和修改，代码结构太差，需要重新调整一下！！！

处理一下得到logo为空的情况，同时添加或者更新节点信息的时候，如果选择了关联插件，那么单选框默认选择使用数据插件内容，回显部分也得优化一下代码结构，调整整体代码顺序，将角色数据配置和适用端配置以及选中的值，给我放到objdata中，使代码结构更流畅

## 展开后编辑插件，编辑成功后页面全部关了

经过很久的修复，可算解决了，

又是缝缝补补









































