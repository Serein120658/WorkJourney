# 高并发秒杀系统设计指南

[原始博文](https://www.cnblogs.com/qdhxhz/p/15505767.html)

## 概述

秒杀系统是电商促销活动中的经典场景，其特点是**极少商品 + 极低价格 + 大量用户**，技术挑战在于如何在瞬时高并发下保证系统稳定性、数据一致性和用户体验。

## 一、系统特点分析

### 1.1 瞬时高并发特征

秒杀流量呈现明显的**脉冲式峰值**：

- **活动前**：用户提前进入页面等待，流量逐步上升
- **秒杀时刻**：并发量达到峰值（可能是平时的数百倍）
- **秒杀后**：绝大部分用户收到"商品已抢完"提示后离开，流量骤降

**核心矛盾**：大量用户抢少量商品，注定只有极少数人成功，绝大部分请求都是无效的。

### 1.2 典型业务流程

```
用户访问活动页面 → 秒杀按钮点亮 → 点击秒杀 → 库存校验 → 下单 → 支付
```

------

## 二、前端设计要点

### 2.1 页面静态化

**设计原则**：将活动页面做成静态页面，减少服务端压力。

**实现方案**：

- 商品信息（名称、描述、图片等）预先生成静态HTML
- 用户浏览商品时不请求服务端
- 只有点击秒杀按钮时才发起服务端请求

**效果**：过滤掉大部分无效的页面浏览请求。

### 2.2 CDN加速

**问题**：用户分布全国各地，网络延迟差异大。

**解决方案**：

- 将静态资源（HTML、CSS、JS、图片）部署到CDN
- 用户就近获取内容，降低延迟，提高访问速度

### 2.3 秒杀按钮交互设计

#### 按钮状态控制

- **秒杀前**：按钮置灰，不可点击
- **秒杀时**：按钮自动点亮，可点击
- **秒杀后**：根据库存情况显示相应状态

#### 动态更新机制

**挑战**：如何在静态页面中实时控制按钮状态？

**解决方案**：动态JS文件 + 随机参数

```javascript
// 秒杀前
https://cdn.example.com/seckill.js?v=random_1&flag=false

// 秒杀开始时
https://cdn.example.com/seckill.js?v=random_2&flag=true
```

**关键点**：

1. 系统在秒杀开始时生成新的JS文件，标志位改为true
2. 添加随机参数防止CDN缓存，确保获取最新版本
3. 前端通过标志位判断是否点亮按钮

#### 前端防重复提交

```javascript
// 定时器限流
let canClick = true;
function handleSeckill() {
  if (!canClick) return;
  canClick = false;
  
  // 发起请求
  requestSeckill();
  
  // 10秒后才能再次点击
  setTimeout(() => {
    canClick = true;
  }, 10000);
}
```

**效果**：限制用户在短时间内重复点击，减轻服务端压力。

### 2.4 验证码机制

**目的**：防止机器刷单，限制非法请求。

**类型选择**：

- **普通验证码**：数字/字符识别，生成快但易被破解
- **滑动验证**：移动滑块拼图，安全性高，主流方案

**实现要点**：

- 验证码一次性使用，用后即焚
- 服务端校验验证码有效性
- 平衡安全性和用户体验

------

## 三、后端核心设计

### 3.1 缓存架构

#### 为什么使用缓存？

**场景特点**：读多写少（大量查询库存，极少扣减成功）

**数据库问题**：

- 数据库连接数有限（如MySQL），无法支撑高并发
- 直接查询数据库会导致连接耗尽，系统崩溃

**解决方案**：使用Redis缓存 + 多节点部署

```
客户端请求 → 负载均衡 → Redis集群（多节点） → 数据库
```

#### 缓存击穿问题

**场景**：商品第一次秒杀，缓存中无数据，大量请求同时穿透到数据库。

**后果**：数据库瞬间压力过大，可能宕机。

**解决方案一**：分布式锁

```java
// 伪代码
String lockKey = "lock:product:" + productId;
if (redisLock.tryLock(lockKey)) {
    try {
        // 双重检查
        Product product = cache.get(productId);
        if (product == null) {
            product = db.query(productId);
            if (product != null) {
                cache.set(productId, product);
            }
        }
        return product;
    } finally {
        redisLock.unlock(lockKey);
    }
} else {
    // 等待其他线程加载完成
    Thread.sleep(50);
    return cache.get(productId);
}
```

**解决方案二**：缓存预热（推荐）

在系统启动时，提前将所有秒杀商品加载到缓存中。

#### 缓存穿透问题

**场景**：大量请求查询不存在的商品ID，每次都穿透到数据库。

**解决方案一**：布隆过滤器

```
请求 → 布隆过滤器（判断ID是否存在）→ Redis → 数据库
```

**适用场景**：缓存数据变化少的场景

**局限性**：布隆过滤器与缓存数据同步困难，无法保证实时一致性。

**解决方案二**：缓存空对象

```java
// 商品不存在时，也缓存一个特殊标记
if (product == null) {
    cache.set(productId, "NULL", 60); // 短期缓存，60秒过期
    return null;
}
```

### 3.2 库存管理

#### 预扣库存机制

**完整流程**：

```
1. 用户秒杀 → 预扣库存
2. 生成订单（待支付状态）
3. 15分钟内支付 → 确认扣库存
4. 超时未支付 → 回退库存，取消订单
```

#### 数据库扣减库存

**错误示例**：

```sql
-- 先查询
SELECT stock FROM product WHERE id = 123;

-- 再更新（非原子操作，高并发下会超卖）
UPDATE product SET stock = stock - 1 WHERE id = 123;
```

**正确方案**：使用乐观锁

```sql
-- 原子操作，避免超卖
UPDATE product SET stock = stock - 1 
WHERE id = 123 AND stock > 0;
```

**缺点**：

- 频繁访问数据库，连接资源消耗大
- 高并发下易出现行锁竞争，可能死锁

#### Redis扣减库存

**错误示例**：

```java
// 查询和扣减非原子操作，会超卖
int stock = redis.get("stock:" + productId);
if (stock > 0) {
    redis.decr("stock:" + productId);
}
```

**改进方案**：利用INCRBY原子性

```java
// 检查用户是否已秒杀
if (redis.exists("user:" + userId + ":product:" + productId)) {
    return "已经秒杀过";
}

// 原子扣减
long stock = redis.incrby("stock:" + productId, -1);
if (stock < 0) {
    return "库存不足";
}

// 记录秒杀记录
redis.set("user:" + userId + ":product:" + productId, "1");
return "秒杀成功";
```

**问题**：高并发下会有大量请求扣减后返回负数，导致库存值偏离实际。

#### Lua脚本扣减库存（推荐方案）

**优势**：保证原子性 + 精确控制

```lua
-- 检查商品是否存在
if (redis.call('exists', KEYS[1]) == 1) then
    local stock = tonumber(redis.call('get', KEYS[1]));
    
    -- -1表示不限制库存
    if (stock == -1) then
        return 1;
    end;
    
    -- 库存充足则扣减
    if (stock > 0) then
        redis.call('incrby', KEYS[1], -1);
        return stock;
    end;
    
    -- 库存不足
    return 0;
end;

-- 商品不存在
return -1;
```

**调用示例**：

```java
String script = "..."; // Lua脚本
Long result = redis.eval(script, 
    Collections.singletonList("stock:" + productId), 
    Collections.emptyList()
);
```

### 3.3 分布式锁应用

**使用场景**：防止缓存击穿

**实现方案**：基于Redis的分布式锁

```java
public Product getProduct(Long productId) {
    // 1. 先查缓存
    Product product = cache.get(productId);
    if (product != null) {
        return product;
    }
    
    // 2. 加分布式锁
    String lockKey = "lock:product:" + productId;
    boolean locked = redisLock.tryLock(lockKey, 10, TimeUnit.SECONDS);
    
    if (locked) {
        try {
            // 3. 双重检查
            product = cache.get(productId);
            if (product != null) {
                return product;
            }
            
            // 4. 查数据库
            product = productMapper.selectById(productId);
            
            // 5. 写入缓存
            if (product != null) {
                cache.set(productId, product, 3600);
            } else {
                cache.set(productId, "NULL", 60); // 防止缓存穿透
            }
            
            return product;
        } finally {
            redisLock.unlock(lockKey);
        }
    } else {
        // 等待片刻后重试
        Thread.sleep(50);
        return getProduct(productId);
    }
}
```

### 3.4 MQ异步处理

#### 为什么要异步？

**核心流程拆分**：

- **秒杀**：高并发（数十万QPS）
- **下单**：中等并发（可异步处理）
- **支付**：低并发（支付宝等本身就是异步）

**架构调整**：

```
同步流程：秒杀 → 下单 → 支付
异步流程：秒杀 → MQ → 下单（异步消费）→ 支付
```

#### 消息可靠性保障

**1. 防止消息丢失**

方案：消息发送表 + 重试机制

```
1. 秒杀成功 → 写消息发送表（状态：待处理）
2. 发送MQ消息
3. 消费者处理完成 → 回调接口更新状态（已处理）
4. JOB定时扫描待处理消息 → 重试发送
```

**消息发送表结构**：

```sql
CREATE TABLE message_send (
    id BIGINT PRIMARY KEY,
    message_id VARCHAR(64) UNIQUE,
    content TEXT,
    status TINYINT, -- 0:待处理 1:已处理
    retry_count INT DEFAULT 0,
    max_retry INT DEFAULT 3,
    create_time DATETIME
);
```

**2. 防止重复消费**

方案：消息处理表 + 幂等性保证

```java
@Transactional
public void consumeMessage(Message msg) {
    // 1. 检查是否已处理
    if (messageProcessMapper.exists(msg.getId())) {
        return; // 重复消息，直接返回
    }
    
    // 2. 处理业务（下单）
    createOrder(msg.getOrderInfo());
    
    // 3. 记录消息处理（同一事务）
    messageProcessMapper.insert(msg.getId());
}
```

**3. 控制垃圾消息**

如果消费一直失败，重试机制会产生大量垃圾消息。

**解决方案**：限制重试次数

```java
// JOB重试逻辑
if (message.getRetryCount() >= message.getMaxRetry()) {
    // 达到最大重试次数，标记为失败
    message.setStatus(MessageStatus.FAILED);
    messageMapper.update(message);
    return;
}

// 重试次数+1
message.setRetryCount(message.getRetryCount() + 1);
messageMapper.update(message);

// 发送消息
mqProducer.send(message);
```

**4. 延迟消费（订单超时取消）**

使用RocketMQ延迟队列实现订单超时自动取消：

```java
// 下单时发送延迟消息（15分钟后消费）
Message msg = new Message("order_cancel_topic", orderInfo);
msg.setDelayTimeLevel(16); // 延迟级别16 = 30分钟
producer.send(msg);

// 消费者处理
public void onMessage(Message msg) {
    Order order = getOrder(msg.getOrderId());
    
    // 如果订单仍是待支付状态，则取消订单
    if (order.getStatus() == OrderStatus.UNPAID) {
        cancelOrder(order.getId());
        rollbackStock(order.getProductId(), order.getQuantity());
    }
}
```

### 3.5 限流策略

#### 为什么要限流？

**威胁**：黄牛党使用脚本批量请求，一秒可发起上千次请求，远超正常用户。

**目标**：识别并限制非法请求，保护系统稳定性。

#### 限流方案

**1. 基于用户ID限流**

```nginx
# Nginx配置
limit_req_zone $request_uri zone=user_limit:10m rate=5r/m;

location /api/seckill {
    limit_req zone=user_limit burst=10 nodelay;
}
```

**效果**：限制同一用户每分钟最多请求5次。

**2. 基于IP限流**

```nginx
limit_req_zone $binary_remote_addr zone=ip_limit:10m rate=5r/m;

location /api/seckill {
    limit_req zone=ip_limit burst=10 nodelay;
}
```

**效果**：限制同一IP每分钟最多请求5次。

**缺点**：可能误杀（公司、网吧等共享IP的正常用户）。

**3. 基于接口限流**

```nginx
limit_req_zone $server_name zone=api_limit:10m rate=10000r/s;

location /api/seckill {
    limit_req zone=api_limit burst=20000 nodelay;
}
```

**效果**：限制接口总QPS，保护系统整体稳定性。

**缺点**：可能因非法请求过多，影响正常用户访问。

**4. 验证码（前面已讲）**

精准识别人机，不会误杀。

**5. 业务门槛**

**策略示例**：

- 只有会员才能参与秒杀
- 用户等级达到3级以上才有资格
- 实名认证用户才能参与

**优势**：从业务层面提高成本，黄牛党难以批量注册。

------

## 四、整体架构图

```
                    ┌─────────────┐
                    │   用户请求   │
                    └──────┬──────┘
                           │
                    ┌──────▼──────┐
                    │     CDN     │ (静态资源)
                    └──────┬──────┘
                           │
                    ┌──────▼──────┐
                    │  Nginx限流  │ (用户/IP/接口)
                    └──────┬──────┘
                           │
                ┌──────────▼──────────┐
                │   负载均衡(SLB)      │
                └──────────┬──────────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
   ┌────▼────┐        ┌────▼────┐       ┌────▼────┐
   │应用服务器1│       │应用服务器2│      │应用服务器N│
   └────┬────┘        └────┬────┘       └────┬────┘
        │                  │                  │
        └──────────────────┼──────────────────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
   ┌────▼────┐        ┌────▼────┐       ┌────▼────┐
   │ Redis1  │        │ Redis2  │       │ Redis3  │
   │(主从集群)│        │(主从集群)│       │(主从集群)│
   └────┬────┘        └────┬────┘       └────┬────┘
        │                  │                  │
        └──────────────────┼──────────────────┘
                           │
                    ┌──────▼──────┐
                    │     MQ      │ (异步下单)
                    └──────┬──────┘
                           │
                    ┌──────▼──────┐
                    │  订单服务    │
                    └──────┬──────┘
                           │
                    ┌──────▼──────┐
                    │   数据库    │ (主从读写分离)
                    └─────────────┘
```

------

## 五、关键指标与监控

### 5.1 核心指标

- **QPS**：每秒请求数，秒杀峰值可达数十万
- **RT**：响应时间，应控制在100ms以内
- **成功率**：扣减库存成功率，应接近100%
- **准确性**：库存不超卖、不少卖

### 5.2 监控告警

- **系统监控**：CPU、内存、网络、磁盘IO
- **应用监控**：接口响应时间、错误率、QPS
- **Redis监控**：连接数、内存使用率、命中率
- **MQ监控**：消息堆积量、消费延迟

------

## 六、总结

### 前端关键点

1. **页面静态化** + **CDN加速**：减少服务端压力
2. **秒杀按钮动态控制**：通过JS + 随机参数实现实时更新
3. **前端防重复提交**：定时器限流
4. **验证码**：防止机器刷单

### 后端关键点

1. **缓存架构**：Redis多节点 + 缓存预热 + 防击穿/穿透
2. **库存管理**：Lua脚本原子扣减 + 预扣库存机制
3. **分布式锁**：防止缓存击穿
4. **MQ异步**：削峰填谷 + 消息可靠性保障
5. **限流策略**：多维度限流（用户/IP/接口/验证码/业务门槛）

### 核心思想

- **能拦截在前端的，绝不打到后端**
- **能缓存的，绝不查数据库**
- **能异步的，绝不同步**
- **能限流的，绝不让系统超载**

秒杀系统是一个系统工程，需要前后端协同配合，从架构设计、技术选型、代码实现、监控运维等多方面保障系统的高可用和高性能。