# UniScan 扫描插件接口文档

## 1. 插件引入

### 1.1 获取插件实例

```javascript
const plugin = uni.requireNativePlugin('UniScan')
```

**说明：** 在使用任何接口前，必须先通过 `uni.requireNativePlugin` 方法获取 UniScan 插件实例。

------

## 2. 基础配置接口

### 2.1 isOpenScan()

**功能：** 检查扫描功能是否已开启

**返回值：**

- `true` - 扫描功能已开启
- `false` - 扫描功能未开启

**使用示例：**

```javascript
const result = plugin.isOpenScan();
if (result) {
    console.log('扫描功能已开启');
} else {
    console.log('扫描功能未开启');
}
```

------

### 2.2 setDecodeTipVibrator(boolean enable)

**功能：** 设置扫描成功后是否震动反馈

**参数：**

- ```
  enable
  ```

   (boolean)

  - `true` - 开启震动反馈
  - `false` - 关闭震动反馈

**返回值：** 无

**使用示例：**

```javascript
// 开启扫描震动反馈
plugin.setDecodeTipVibrator(true);

// 关闭扫描震动反馈
plugin.setDecodeTipVibrator(false);
```

**说明：** 震动反馈可以给用户明确的扫描成功提示，建议开启。

------

### 2.3 setInputMode(int mode)

**功能：** 设置扫描数据输入模式

**参数：**

- ```
  mode
  ```

   (int) - 输入模式

  - `0` - 广播模式（通过广播接收扫描数据）
  - `1` - 输入框模式（扫描数据直接输入到当前焦点输入框）
  - `2` - API模式（通过回调接口获取数据）

**返回值：** 无

**使用示例：**

```javascript
// 设置为广播模式
plugin.setInputMode(0);

// 设置为输入框模式
plugin.setInputMode(1);
```

**重要说明：**

- **广播模式(0)：** 扫描数据通过广播发送，需要注册广播接收器接收
- **输入框模式(1)：** 扫描数据自动填充到当前有焦点的输入框
- **API模式(2)：** 需要实现回调接口来接收数据

**推荐使用场景：**

- 需要自定义处理逻辑：使用广播模式
- 简单表单输入：使用输入框模式
- 需要实时处理：使用API模式

------

## 3. 灯光控制接口

### 3.1 setIllPowerLevel(int level)

**功能：** 设置扫描白色补光灯亮度等级

**参数：**

- ```
  level
  ```

   (int) - 补光灯等级（0-9）

  - `0` - 关闭补光灯
  - `1-9` - 补光等级，数值越大越亮

**返回值：** 无

**使用示例：**

```javascript
// 关闭补光灯
plugin.setIllPowerLevel(0);

// 设置中等亮度
plugin.setIllPowerLevel(5);

// 设置最大亮度
plugin.setIllPowerLevel(9);
```

**使用建议：**

- 光线充足环境：关闭或使用低等级（0-3）
- 一般室内环境：使用中等级（4-6）
- 暗光环境：使用高等级（7-9）
- 补光灯会增加功耗，建议按需使用

------

### 3.2 setAim(boolean enable)

**功能：** 设置瞄准灯（红色激光）开关

**参数：**

- ```
  enable
  ```

   (boolean)

  - `true` - 打开瞄准灯
  - `false` - 关闭瞄准灯

**返回值：** 无

**使用示例：**

```javascript
// 打开瞄准灯
plugin.setAim(true);

// 关闭瞄准灯
plugin.setAim(false);
```

**说明：** 瞄准灯帮助用户精确对准扫描目标，建议在需要精确扫描时开启。

------

## 4. 测温相关接口（可选功能）

### 4.1 initThermometryManager()

**功能：** 初始化测温管理器

**返回值：**

- `true` - 初始化成功
- `false` - 初始化失败

**使用示例：**

```javascript
const result = plugin.initThermometryManager();
if (result) {
    console.log('测温管理器初始化成功');
}
```

**注意事项：**

- 仅在设备支持测温功能时使用
- 必须在使用测温功能前调用

------

### 4.2 TrigerTemperature()

**功能：** 触发一次温度测量

**返回值：** 无

**使用示例：**

```javascript
plugin.TrigerTemperature();
```

**说明：** 触发后需要等待一段时间，然后通过 `getTemperature()` 获取测量结果。

------

### 4.3 getTemperature()

**功能：** 获取最近一次测温结果

**返回值：**

- (float/String) - 温度值（单位：摄氏度）

**使用示例：**

```javascript
let temp = plugin.getTemperature();
console.log('当前温度:', temp + '°C');
```

**注意事项：**

- 需要先调用 `TrigerTemperature()` 触发测温
- 建议在触发后延迟200-500ms再读取

------

## 5. 广播接收机制

### 5.1 广播原理

当设置为广播模式（`setInputMode(0)`）时，扫描到的数据会通过 Android 广播发送出来。应用需要：

1. **创建广播接收器**
2. **注册广播监听**
3. **在接收器中处理数据**
4. **页面销毁时注销接收器**

------

### 5.2 广播 Action 和数据字段

**广播 Action：** `android.scanservice.action.UPLOAD_BARCODE_DATA`

**数据字段：**

- `barcode` (String) - 扫描到的条码/二维码数据

**重要提示：**

- 不同厂商的设备可能使用不同的 Action 和字段名
- 需要根据实际设备调整（参考设备厂商文档）
- 提供的设备只有按键广播    扫码广播是没有的   但是支持输入框

------

### 5.3 完整实现示例

```javascript
export default {
    data() {
        return {
            scanData: '',
            main: null,
            receiver: null,
            filter: null
        }
    },
    
    onLoad() {
        // 1. 初始化插件配置
        const plugin = uni.requireNativePlugin('UniScan');
        plugin.isOpenScan();
        plugin.setDecodeTipVibrator(true);  // 开启震动
        plugin.setInputMode(0);              // 设置广播模式
    },
    
    created() {
        // 2. 初始化并注册广播
        this.initBroadcast();
        this.registerReceiver();
    },
    
    onHide() {
        // 3. 页面隐藏时注销广播
        this.unregisterReceiver();
    },
    
    destroyed() {
        // 4. 页面销毁时注销广播
        this.unregisterReceiver();
    },
    
    methods: {
        /**
         * 初始化广播接收器
         */
        initBroadcast() {
            // #ifdef APP-PLUS
            const _this = this;
            
            // 获取Android主Activity
            this.main = plus.android.runtimeMainActivity();
            
            // 导入IntentFilter类
            const IntentFilter = plus.android.importClass('android.content.IntentFilter');
            this.filter = new IntentFilter();
            
            // 添加广播Action（根据实际设备调整）
            this.filter.addAction("android.scanservice.action.UPLOAD_BARCODE_DATA");
            
            // 创建广播接收器
            this.receiver = plus.android.implements(
                'io.dcloud.feature.internal.reflect.BroadcastReceiver', 
                {
                    onReceive: function(context, intent) {
                        plus.android.importClass(intent);
                        
                        // 获取扫描数据（根据实际设备调整字段名）
                        const barcode = intent.getStringExtra("barcode");
                        
                        if (barcode) {
                            console.log('扫描到数据:', barcode);
                            _this.scanData = barcode;
                            
                            // 可以在这里处理扫描数据
                            _this.handleScanData(barcode);
                        }
                    }
                }
            );
            // #endif
        },
        
        /**
         * 注册广播接收器
         */
        registerReceiver() {
            // #ifdef APP-PLUS
            if (this.main && this.receiver && this.filter) {
                this.main.registerReceiver(this.receiver, this.filter);
                console.log('广播接收器已注册');
            }
            // #endif
        },
        
        /**
         * 注销广播接收器
         */
        unregisterReceiver() {
            // #ifdef APP-PLUS
            if (this.main && this.receiver) {
                this.main.unregisterReceiver(this.receiver);
                console.log('广播接收器已注销');
            }
            // #endif
        },
        
        /**
         * 处理扫描数据
         */
        handleScanData(barcode) {
            // 根据业务需求处理数据
            uni.showToast({
                title: '扫描成功',
                icon: 'success'
            });
            
            // 例如：查询数据库、调用API等
            // this.queryByBarcode(barcode);
        }
    }
}
```

------

## 6. 常见问题解答

### Q1: 收不到广播数据怎么办？

**A:** 检查以下几点：

1. 确认已设置为广播模式：`plugin.setInputMode(0)`
2. 检查广播 Action 是否正确（不同设备可能不同）
3. 检查数据字段名是否正确（可能是 "barcode"、"data"、"scanResult" 等）
4. 确认广播接收器已正确注册
5. 检查页面生命周期中是否正确处理注册和注销

**调试方法：**

```javascript
onReceive: function(context, intent) {
    plus.android.importClass(intent);
    
    // 打印所有可能的字段
    console.log('Intent Action:', intent.getAction());
    
    // 尝试不同的字段名
    const fields = ['barcode', 'data', 'scanResult', 'code'];
    fields.forEach(field => {
        const value = intent.getStringExtra(field);
        console.log(field + ':', value);
    });
}
```

------

### Q2: 如何区分扫描数据类型？

**A:** 扫描数据通常只返回字符串，需要根据数据格式自行判断：

```javascript
handleScanData(barcode) {
    // 判断是否为URL
    if (barcode.startsWith('http://') || barcode.startsWith('https://')) {
        console.log('这是一个网址');
        // 处理URL
    }
    // 判断是否为数字条码
    else if (/^\d+$/.test(barcode)) {
        console.log('这是一个数字条码');
        // 处理商品条码
    }
    // 判断是否为JSON
    else if (barcode.startsWith('{') || barcode.startsWith('[')) {
        try {
            const jsonData = JSON.parse(barcode);
            console.log('这是JSON数据');
            // 处理JSON数据
        } catch (e) {
            console.log('JSON解析失败');
        }
    }
    else {
        console.log('其他类型数据');
    }
}
```

------

### Q3: 如何实现连续扫描？

**A:** 默认情况下，每次按下扫描键都会触发一次扫描。如果需要实现连续扫描：

```javascript
data() {
    return {
        isScanning: false,
        scanHistory: []
    }
},

methods: {
    handleScanData(barcode) {
        if (!this.isScanning) return;
        
        // 添加到扫描历史
        this.scanHistory.push({
            data: barcode,
            time: new Date().toLocaleString()
        });
        
        // 继续扫描（自动）
        // 无需额外操作，保持扫描键按下即可
    },
    
    startContinuousScan() {
        this.isScanning = true;
        this.scanHistory = [];
        uni.showToast({
            title: '开始连续扫描',
            icon: 'none'
        });
    },
    
    stopContinuousScan() {
        this.isScanning = false;
        uni.showToast({
            title: '停止扫描',
            icon: 'none'
        });
    }
}
```

------

### Q4: 如何避免重复扫描？

**A:** 实现防抖机制：

```javascript
data() {
    return {
        lastScanData: '',
        lastScanTime: 0,
        scanInterval: 2000  // 2秒内相同数据只处理一次
    }
},

methods: {
    handleScanData(barcode) {
        const now = Date.now();
        
        // 检查是否为重复扫描
        if (barcode === this.lastScanData && 
            now - this.lastScanTime < this.scanInterval) {
            console.log('忽略重复扫描');
            return;
        }
        
        // 更新最后扫描信息
        this.lastScanData = barcode;
        this.lastScanTime = now;
        
        // 处理扫描数据
        this.processScanData(barcode);
    }
}
```

------

## 7. 最佳实践

### 7.1 初始化配置模板

```javascript
onLoad() {
    const plugin = uni.requireNativePlugin('UniScan');
    
    // 基础配置
    plugin.isOpenScan();
    plugin.setDecodeTipVibrator(true);   // 震动反馈
    plugin.setInputMode(0);               // 广播模式
    
    // 灯光配置（可选）
    plugin.setIllPowerLevel(5);           // 中等补光
    plugin.setAim(true);                  // 开启瞄准灯
}
```

### 7.2 生命周期管理

```javascript
created() {
    this.initBroadcast();
    this.registerReceiver();
},

onHide() {
    this.unregisterReceiver();
},

onBackPress() {
    this.unregisterReceiver();
    return false;
},

destroyed() {
    this.unregisterReceiver();
}
```

### 7.3 错误处理

```javascript
methods: {
    registerReceiver() {
        try {
            // #ifdef APP-PLUS
            if (this.main && this.receiver && this.filter) {
                this.main.registerReceiver(this.receiver, this.filter);
                console.log('✓ 广播接收器注册成功');
            } else {
                console.error('✗ 广播接收器注册失败：缺少必要对象');
            }
            // #endif
        } catch (e) {
            console.error('✗ 注册广播接收器异常:', e);
        }
    },
    
    unregisterReceiver() {
        try {
            // #ifdef APP-PLUS
            if (this.main && this.receiver) {
                this.main.unregisterReceiver(this.receiver);
                console.log('✓ 广播接收器注销成功');
            }
            // #endif
        } catch (e) {
            console.error('✗ 注销广播接收器异常:', e);
        }
    }
}
```

------

## 8. 附录

### 8.1 常见广播 Action 列表

不同厂商设备可能使用不同的广播 Action：

```javascript
// 常见的扫描广播Action
const commonActions = [
    "android.scanservice.action.UPLOAD_BARCODE_DATA",  // 通用
    "com.android.server.scannerservice.broadcast",     // 某些设备
    "scan.rcv.message",                                 // 某些PDA设备
    "android.intent.ACTION_DECODE_DATA"                 // 某些扫描枪
];
```

### 8.2 常见数据字段名称

```javascript
// 常见的扫描数据字段名
const commonFields = [
    "barcode",      // 最常见
    "data",         // 通用字段
    "scanResult",   // 扫描结果
    "code",         // 码值
    "SCAN_BARCODE1" // 某些设备
];
```

### 8.3 设备兼容性检查

```javascript
methods: {
    checkDeviceCompatibility() {
        try {
            const plugin = uni.requireNativePlugin('UniScan');
            const isOpen = plugin.isOpenScan();
            
            if (isOpen) {
                console.log('✓ 设备支持扫描功能');
                return true;
            } else {
                console.log('✗ 设备不支持扫描功能');
                uni.showToast({
                    title: '设备不支持扫描',
                    icon: 'none'
                });
                return false;
            }
        } catch (e) {
            console.error('✗ 扫描插件不可用:', e);
            uni.showToast({
                title: '扫描功能不可用',
                icon: 'none'
            });
            return false;
        }
    }
}
```

------

## 9. 总结

UniScan 扫描插件提供了完整的条码/二维码扫描功能，主要特点：

✅ **支持多种输入模式：** 广播、输入框、API回调 ✅ **灵活的灯光控制：** 补光灯和瞄准灯可独立控制 ✅ **震动反馈：** 提供良好的用户体验 ✅ **扩展功能：** 支持测温等附加功能

**推荐使用广播模式** 的原因：

- 数据处理灵活
- 可以实现复杂业务逻辑
- 不依赖输入框焦点
- 便于调试和问题追踪

记得在页面生命周期中正确管理广播接收器的注册和注销，避免内存泄漏！
