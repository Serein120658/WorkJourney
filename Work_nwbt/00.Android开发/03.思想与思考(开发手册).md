# RFID Android 应用学习笔记

## 一、AndroidManifest.xml 配置详解

### 核心思想

类似于 **uni-app 中的 pages.json**，AndroidManifest.xml 是 Android 应用的配置清单文件，用于：

- 声明应用的所有组件（Activity、Service等）
- 配置应用权限
- 设置应用图标、主题
- 指定启动页面

### 参数详解

```xml
<application
    android:allowBackup="true"              <!-- 允许应用数据备份 -->
    android:dataExtractionRules="..."       <!-- Android 12+ 数据提取规则 -->
    android:fullBackupContent="..."         <!-- 完整备份内容配置 -->
    android:icon="@drawable/uhf"            <!-- 应用图标 -->
    android:label="@string/app_name"        <!-- 应用名称 -->
    android:roundIcon="@drawable/uhf"       <!-- 圆形图标（适配某些启动器）-->
    android:supportsRtl="true"              <!-- 支持从右到左布局（如阿拉伯语）-->
    android:theme="@style/Theme.TestUHFAPI" <!-- 应用主题样式 -->
    tools:targetApi="31">                   <!-- 目标 API 级别（Android 12）-->
```

### Activity 配置说明

```xml
<activity
    android:name=".MainActivity"           <!-- Activity 类名 -->
    android:exported="true">               <!-- 是否可被外部应用启动 -->
    <intent-filter>                        <!-- 意图过滤器 -->
        <action android:name="android.intent.action.MAIN" />      <!-- 主要动作 -->
        <category android:name="android.intent.category.LAUNCHER" /> <!-- 启动器类别 -->
    </intent-filter>
</activity>
```

**关键点：**

- `android:exported="true"` 的 MainActivity 配置了 LAUNCHER，表示它是应用启动时的**入口页面**
- 其他 Activity 的 `exported="false"` 表示只能从应用内部访问

------

## 二、页面跳转机制

### 1. 从 MainActivity 跳转到 SettingActivity

**在 MainActivity.java 中：**

```java
@Override
public void onClick(View view) {
    int id = view.getId();
    if(id == R.id.settingBtn){
        // 创建意图（Intent）
        Intent intent = new Intent(this, SettingActivity.class);
        // 启动新的 Activity
        startActivity(intent);
    }
}
```

### 2. 从列表项跳转到 ReadWriteLockActivity

**点击 ListView 中的标签卡片：**

```java
@Override
public void onItemClick(AdapterView<?> adapterView, View view, int i, long l) {
    // 获取被点击项的 EPC 值
    TextView itemEpc = view.findViewById(R.id.epcvalue);
    // 保存到全局配置中
    DefaultConfigure.currentEpc = itemEpc.getText().toString();
    // 跳转到读写锁定页面
    Intent intent = new Intent(MainActivity.this, ReadWriteLockActivity.class);
    startActivity(intent);
}
```

### 跳转机制总结

- **Intent（意图）** 是 Android 页面跳转的核心
- 显式 Intent：`new Intent(当前页面, 目标页面.class)`
- 通过 `startActivity(intent)` 执行跳转
- 可以通过 Intent 传递数据（这里通过 DefaultConfigure 静态变量传递）

------

## 三、RFID 核心概念完整解析

### 1. 上电（Power On）与下电（Power Off）

```java
@Override
protected void onResume() {
    // 上电：给 RFID 模块供电
    UHFEngine.getEngine().powerOn();
    
    // 连接模块
    Reader.READER_ERR er = UHFEngine.getEngine().connectModule(
        DefaultConfigure.UART_DEV_PATH, 1
    );
    
    if(er == Reader.READER_ERR.MT_OK_ERR){
        // 连接成功，初始化模块参数
        DefaultConfigure.defaultInitModule();
    }
}

@Override
protected void onPause() {
    // 断开连接
    UHFEngine.getEngine().disconnectModule();
    // 下电：切断 RFID 模块电源
    UHFEngine.getEngine().powerOff();
}
```

**为什么要上电/下电？**

- **节省电量**：RFID 模块功耗较大，不使用时应关闭
- **资源管理**：避免多个应用同时占用 RFID 模块
- **生命周期管理**：页面不可见时释放硬件资源

------

### 2. 盘点（Inventory）

**定义：** **<font color = red >读写器向工作区域内的所有标签发送查询指令，标签依次响应并返回 EPC 数据的过程。</font>**

**特点：**

- 批量读取：一次可读取多个标签
- 非接触式：无需物理接触，最远可达 10 米
- 高速读取：每秒可读取上百个标签

**应用场景：** 仓库盘点、门禁考勤、车辆管理

```java
Reader.READER_ERR er = UHFEngine.getEngine().startInventory(params, RL, REL);
```

------

### 3. 读取（Read）

**定义：** 读取特定标签的特定存储区域的数据。

**RFID 标签存储区域：**

- **RESERVED 区**：存储密码（访问密码、销毁密码）
- **EPC 区**：存储电子产品码（可读写）
- **TID 区**：存储标签唯一识别码（只读，出厂固化）
- **USER 区**：用户自定义数据区（可读写）

**与盘点的区别：**

- 盘点是广播式，读取所有标签的 EPC
- 读取是针对性操作，读取指定标签的指定数据

------

### 4. 写入（Write）

**定义：** 向特定标签的特定存储区域写入数据。

**常见写入操作：**

```java
// 写 EPC（通过现有 EPC 定位标签）
manager.writeEpcByEpcNoPassword(
    new byte[]{0x11,0x22,0x33,0x44,0x55,0x66,0x77,(byte)0x88},  // 新 EPC
    new byte[]{0x01,0x02,0x03,0x04,0x05,0x06,0x07,(byte)0x08}   // 旧 EPC
);

// 写 EPC（通过 TID 定位标签）
manager.writeEpcByTidNoPassword(
    new byte[]{0x11,0x22,0x33,0x44,0x55,0x66,0x77,(byte)0x88},  // 新 EPC
    new byte[]{0x01,0x02,0x03,0x04,0x05,0x06,0x07,(byte)0x08}   // TID
);
```

**注意事项：**

- 写入需要更高的功率
- 可能需要密码（如果标签已加锁）
- 写入距离通常比读取距离短

------

### 5. 锁定（Lock）

**定义：** 锁定标签的特定存储区域，防止未授权的读取或写入。

**锁定类型：**

- **永久锁定（Permalock）**：不可逆，标签被锁定后无法解锁
- **密码锁定**：需要密码才能读写，可用密码解锁

**锁定场景：**

- 防篡改：锁定 EPC 区，防止数据被篡改
- 隐私保护：锁定 USER 区，防止敏感数据泄露
- 安全管理：设置访问密码和销毁密码

------

### 6. 销毁（Kill）

**定义：** 永久性禁用标签，使其无法再被读取或写入。

**销毁条件：**

- 需要正确的销毁密码（Kill Password）
- 销毁后不可恢复

**应用场景：**

- 隐私保护：商品售出后销毁标签，防止追踪
- 回收处理：报废物品的标签销毁

⚠️ **警告：** 销毁操作不可逆，谨慎使用！

------

### 7. EPC（Electronic Product Code）

**定义：** 电子产品代码，存储在标签的 EPC 区，用于标识物品。

**EPC 结构（96 位为例）：**

```
Header(8位) | Filter(3位) | Partition(3位) | Company(24位) | Item(38位) | Serial(24位)
```

**特点：**

- 可读可写
- 长度可变（常见 96 位、128 位）
- 全球唯一编码

**示例：** `E280116060000207001234567890`

------

### 8. TID（Tag Identifier）

**定义：** 标签唯一识别码，存储在标签的 TID 区。

**特点：**

- 出厂固化，**只读不可写**
- 每个标签的 TID 全球唯一
- 用于防伪验证、标签溯源

**TID 结构：**

```
厂商代码(8位) | 标签型号(12位) | 唯一序列号(N位)
```

**示例：** `E200001234567890ABCDEF01`

------

### 9. RSSI（Received Signal Strength Indicator）

**定义：** 接收信号强度指示，表示读写器接收到的标签反射信号的强度。

**取值范围：** 通常为负值，如 -30 到 -80 dBm

**信号强度与距离关系：**

- `-30 dBm`：信号非常强，标签很近（< 0.5 米）
- `-50 dBm`：信号良好，中等距离（1-3 米）
- `-70 dBm`：信号较弱，较远距离（5-8 米）
- `-80 dBm`：信号很弱，临界距离（> 10 米）

**应用：**

- 定位：通过 RSSI 估算标签距离
- 筛选：只读取信号强的标签（近距离标签）

------

### 10. 频率（Frequency）

**定义：** RFID 工作频率，不同地区使用不同的频段。

**UHF RFID 频段：**

- **中国（RG_PRC）**：920.125 - 924.875 MHz
- **北美（RG_NA）**：902 - 928 MHz
- **欧洲（RG_EU）**：865 - 868 MHz
- **日本**：952 - 955 MHz

**为什么会显示频率？**

- 读写器在允许的频段内跳频工作（避免干扰）
- 每次读取标签时使用的具体频点会记录下来

**代码中的频率：** `item.Frequency = tagInfo.Frequency;` // 单位：kHz

------

### 11. 天线（Antenna）

**定义：** 发射和接收射频信号的硬件组件。

**PDA 设备特点：**

- 通常只有 **1 个天线**（内置）
- 固定式读写器可能有 4 个、8 个甚至更多天线

**天线参数配置：**

```java
Reader.AntPowerConf apcf = new Reader.AntPowerConf();
apcf.antcnt = 1;  // 天线数量
Reader.AntPower jaap = new Reader.AntPower();
jaap.antid = 1;   // 天线 ID
```

**多天线作用：**

- 扩大读取范围
- 减少盲区
- 提高读取成功率

------

### 12. 功率（Power）

**定义：** 读写器发射射频信号的能量强度。

**两种功率：**

- **读功率（Read Power）**：盘点、读取时使用
- **写功率（Write Power）**：写入、锁定时使用（通常更高）

**功率单位：** dBm（分贝毫瓦）或 0.01 dBm

- 代码中 `3300` = 33.00 dBm ≈ 2W

**功率影响：**

| 功率         | 读取距离 | 能耗 | 干扰 |
| ------------ | -------- | ---- | ---- |
| 低（10 dBm） | 0.5-1 米 | 低   | 小   |
| 中（20 dBm） | 3-5 米   | 中   | 中   |
| 高（33 dBm） | 8-12 米  | 高   | 大   |

⚠️ **注意：** 功率不是越大越好，要根据场景调整

------

### 13. Session

**定义：** EPC Gen2 协议中的标签状态管理机制，控制标签在盘点过程中的响应行为。

**Session 值：** 0、1、2、3

**工作原理：** 每个标签有 4 个 Session 标志位（S0、S1、S2、S3），每个标志位有两种状态：

- **A 状态**：标签会响应读写器
- **B 状态**：标签不响应读写器（或根据 Target 设置响应）

**Session 对比：**

| Session | 超时时间     | 适用场景     | 特点                          |
| ------- | ------------ | ------------ | ----------------------------- |
| **S0**  | 极短（50ms） | 少量标签     | 速度最快，标签很快恢复 A 状态 |
| **S1**  | 短（500ms）  | 中等数量标签 | 平衡速度和防重读              |
| **S2**  | 长（2秒）    | 大量标签     | 防止重复读取                  |
| **S3**  | 永久         | 特殊应用     | 除非断电否则保持状态          |

**使用建议：**

```java
// 场景 1：快速盘点少量标签（< 50 个）
setGen2Session(InventoryModeParams.SESSION.SESSION0);

// 场景 2：仓库盘点（50-200 个标签）
setGen2Session(InventoryModeParams.SESSION.SESSION1);  // 推荐

// 场景 3：大量密集标签（> 200 个）
setGen2Session(InventoryModeParams.SESSION.SESSION2);
```

------

### 14. Target

**定义：** 指定读写器查询哪种状态的标签（A 状态或 B 状态）。

**Target 选项：**

- **A**：只查询 A 状态的标签
- **B**：只查询 B 状态的标签
- **A_2_B**：先查询 A 状态，读取后将标签转为 B 状态（推荐）

**Target 与 Session 配合：**

```java
// 完整盘点策略（推荐）
setGen2Session(InventoryModeParams.SESSION.SESSION1);
setGen2Target(InventoryModeParams.TARGET.A_2_B);
```

![image-20251022163634140](03.思想与思考(开发手册).assets/image-20251022163634140.png)

**工作流程（A_2_B）：**

1. 读写器查询 A 状态标签
2. 标签响应并返回 EPC
3. 标签状态从 A 转换到 B
4. 下次盘点时不再响应（避免重复）
5. 超时后标签自动恢复到 A 状态

**对比：**

| Target | 优点               | 缺点           | 适用场景     |
| ------ | ------------------ | -------------- | ------------ |
| A      | 读取快             | 容易重复读取   | 单次快速盘点 |
| B      | 读取遗漏标签       | 需要先转换状态 | 二次盘点补漏 |
| A_2_B  | 防止重复，完整盘点 | 稍慢           | 大多数场景   |

------

### 15. 区域（Region）

**定义：** RFID 工作的频段范围，不同国家/地区有不同的法规要求。

**可选区域：**

```java
// 中国（920.125 - 924.875 MHz）
setRegionConf(Reader.Region_Conf.RG_PRC);

// 北美（902 - 928 MHz）
setRegionConf(Reader.Region_Conf.RG_NA);

// 欧洲（865 - 868 MHz）
setRegionConf(Reader.Region_Conf.RG_EU);

// 全频段（慎用，可能违规）
setRegionConf(Reader.Region_Conf.RG_OPEN);
```

**为什么要设置区域？**

- **合法合规**：各国对无线电频谱有严格管理
- **避免干扰**：使用指定频段不会干扰其他设备
- **优化性能**：匹配当地标签频率

⚠️ **重要：** 在中国使用必须设置为 `RG_PRC`，否则可能违反《无线电管理条例》

------

### <font color = red>16. 盘点模式（Inventory Mode）(重要)</font>

**定义：** 不同的盘点策略，适应不同的应用需求。

**常见模式：**

| 模式       | 说明         | 速度 | TID 读取 | 适用场景 |
| ---------- | ------------ | ---- | -------- | -------- |
| **NORMAL** | 普通模式     | 快   | 可选     | 一般盘点 |
| **FAST**   | 快速模式     | 极快 | 否       | 实时监控 |
| **DENSE**  | 密集模式     | 中   | 可选     | 大量标签 |
| **TID**    | TID 专用模式 | 慢   | 是       | 防伪验证 |

**代码示例：**

```java
InventoryParams params = InventoryModeParams.getParams(
    DefaultConfigure.inventorymode,       // 模式
    DefaultConfigure.inventoryParams,     // 参数
    DefaultConfigure.inventorywithtid     // 是否读 TID
);
```

------

1. 参数1：模式一般是放在常量里面的(参考提供过来的testUHFApi(E701))  常见的模式如上面的表格
2. 参数2：这个参数与模式对应，不同模式对应需要的参数是不一致的
   **去MainActivity.java对比查看：示例中给的是多标签模式，设置了一个默认的配置**
3. 参数3：表示是否读取RFID标签的TID  这个是厂家出厂时候设置好的固定值，常用于防伪

### 17. 多标签防碰撞（Anti-collision）

**定义：** 当多个标签同时响应读写器时，如何避免信号冲突的机制。

**碰撞问题：**

- 多个标签同时发送数据，信号叠加导致无法识别
- 类似于多人同时说话，听不清楚

**EPC Gen2 防碰撞算法：**

1. **时隙 ALOHA 算法**：读写器将时间划分为多个时隙
2. **Q 值调整**：动态调整时隙数量（Q = 时隙数量的指数）
3. **标签随机选择**：标签随机选择时隙响应

**Q 值影响：**

- **Q 小**（如 Q=2，4 个时隙）：适合少量标签，速度快
- **Q 大**（如 Q=8，256 个时隙）：适合大量标签，减少冲突

**自动调整：**

```java
// SDK 通常会自动调整 Q 值，开发者无需手动设置
// 但在 DENSE 模式下，会使用更大的 Q 值
```

------

### 18. 读取速率（Read Rate）

**定义：** 单位时间内读取到的标签数量。

**影响因素：**

- 功率：功率越大，读取范围越广
- Session：Session0 最快，Session3 最慢
- 标签数量：标签越多，碰撞越多，速率越低
- 环境干扰：金属、水、其他射频设备

**典型读取速率：**

- **单标签**：每秒 200+ 次
- **10 个标签**：每秒 100-150 个标签
- **100 个标签**：每秒 50-80 个标签

------

### 19. 读取距离（Read Range）

**定义：** 读写器能够成功读取标签的最大距离。

**影响因素：**

- **功率**：功率越大，距离越远
- **标签类型**：标签天线越大，距离越远
- **环境**：空旷环境距离更远
- **标签方向**：标签与天线平行时距离最远

**典型距离：**

| 标签类型               | 功率   | 读取距离 |
| ---------------------- | ------ | -------- |
| 小型标签（如珠宝标签） | 30 dBm | 1-3 米   |
| 普通标签（如服装标签） | 30 dBm | 5-8 米   |
| 大型标签（如托盘标签） | 30 dBm | 10-15 米 |

**距离不是越远越好：**

- 距离过远可能读取到不该读的标签（如隔壁房间的标签）
- 需要根据实际场景调整功率

------

### 20. 金属屏蔽与抗金属标签

**金属对 RFID 的影响：**

- 金属会反射射频信号，形成屏蔽
- 标签直接贴在金属表面会无法读取

**解决方案：**

1. **抗金属标签**：内置吸波材料，可贴在金属表面
2. **增加间距**：标签与金属间留有空隙
3. **改变角度**：调整读取角度

**应用场景：**

- 金属托盘、金属货架
- 汽车零部件
- IT 设备资产管理

------

### 核心概念总结表

| 概念      | 类型     | 是否可配置 | 重要程度 |
| --------- | -------- | ---------- | -------- |
| 上电/下电 | 硬件控制 | 否         | ⭐⭐⭐⭐⭐    |
| 盘点      | 操作类型 | 否         | ⭐⭐⭐⭐⭐    |
| 读取/写入 | 操作类型 | 否         | ⭐⭐⭐⭐     |
| 锁定/销毁 | 安全操作 | 需密码     | ⭐⭐⭐      |
| EPC       | 数据标识 | 可写       | ⭐⭐⭐⭐⭐    |
| TID       | 唯一标识 | 只读       | ⭐⭐⭐⭐     |
| RSSI      | 信号强度 | 否         | ⭐⭐⭐      |
| 频率      | 工作频段 | 是         | ⭐⭐⭐⭐     |
| 天线      | 硬件     | 部分可配   | ⭐⭐⭐      |
| 功率      | 硬件参数 | 是         | ⭐⭐⭐⭐⭐    |
| Session   | 协议参数 | 是         | ⭐⭐⭐⭐⭐    |
| Target    | 协议参数 | 是         | ⭐⭐⭐⭐     |
| Region    | 频段     | 是         | ⭐⭐⭐⭐⭐    |
| 盘点模式  | 策略     | 是         | ⭐⭐⭐⭐     |
| 防碰撞    | 协议机制 | 自动       | ⭐⭐⭐      |
| 读取速率  | 性能指标 | 否         | ⭐⭐⭐      |
| 读取距离  | 性能指标 | 间接可调   | ⭐⭐⭐⭐     |
| 抗金属    | 物理特性 | 取决于标签 | ⭐⭐⭐      |

------

## 四、RFID 盘点（Inventory）工作流程

### 完整流程图

```
用户按下按钮 
    ↓
设置盘点参数
    ↓
启动盘点 (startInventory)
    ↓
RFID 模块发射射频信号
    ↓
标签接收信号并返回 EPC/TID
    ↓
ReadListener 回调接收数据
    ↓
解析数据并更新 UI
    ↓
播放提示音
    ↓
用户再次按下按钮停止
```

### 详细代码解析

#### 步骤 1：用户点击"开始盘点"按钮

```java
@Override
public void onClick(View view) {
    if(id == R.id.startInventoryBtn){
        if(inventoryRunning){
            // 如果正在盘点，则停止
            UHFEngine.getEngine().stopInventory();
            inventoryRunning = false;
        } else {
            // 开始盘点
            startInventoryProcess();
        }
    }
}
```

#### 步骤 2：配置盘点参数

```java
// 获取盘点模式参数
InventoryParams params = InventoryModeParams.getParams(
    DefaultConfigure.inventorymode,       // 盘点模式
    DefaultConfigure.inventoryParams,     // 参数配置
    DefaultConfigure.inventorywithtid     // 是否读取 TID
);
```

**盘点模式说明：**

- **NORMAL 模式**：普通盘点，速度快
- **TID 模式**：同时读取 TID（标签唯一ID）
- **快速模式**：适合少量标签
- **密集模式**：适合大量标签场景

#### 步骤 3：启动盘点

```java
Reader.READER_ERR er = UHFEngine.getEngine().startInventory(
    params,    // 盘点参数
    RL,        // 读取成功回调
    REL        // 读取异常回调
);
```

#### 步骤 4：RFID 射频通信过程

**物理层面发生的事情：**

1. **发射信号**：RFID 读写器通过天线发射特定频率的射频信号（920-925MHz）
2. **标签供电**：被动式 RFID 标签接收射频能量，为芯片供电
3. **标签响应**：标签调制反射信号，将存储的 EPC 数据发送回读写器
4. **读写器接收**：天线接收反射信号，解调出标签数据

**协议层面：**

- 使用 **EPC Gen2（ISO 18000-6C）** 协议
- Session 参数控制标签应答策略
- Target 参数控制读取哪些标签

#### 步骤 5：数据回调处理

```java
ReadListener RL = new ReadListener() {
    @Override
    public void tagRead(List<Reader.TagInfo> list) {
        if (list == null) return;
        
        for (Reader.TagInfo tagInfo : list) {
            // 1. 解析标签数据
            String epcId = Reader.bytes_Hexstr(tagInfo.EpcId);  // EPC 号
            String tidId = Reader.bytes_Hexstr(tagInfo.EmbededData); // TID
            
            // 2. 创建标签信息对象
            UHFCardInfo item = new UHFCardInfo();
            item.epc = epcId;
            item.tid = tidId;
            item.rssi = tagInfo.RSSI;           // 信号强度
            item.Frequency = tagInfo.Frequency; // 读取频率
            
            // 3. 添加到列表（去重）
            putCardInfoToList(item);
            mCardDeviceList.allcount++;
        }
        
        // 4. 更新 UI
        delayHandler.sendEmptyMessage(UPDATE_LIST);
        
        // 5. 播放提示音
        soundPool.play(1, 1, 1, 0, 0, 1);
    }
};
```

#### 步骤 6：数据去重与统计

```java
private void putCardInfoToList(UHFCardInfo newCard){
    int pos = getCardInfoIndex(newCard);
    
    if(pos != -1){
        // 标签已存在，增加计数
        mCardDeviceList.cardInfos.get(pos).count++;
        // 更新信号强度和频率
        mCardDeviceList.cardInfos.get(pos).rssi = newCard.rssi;
        mCardDeviceList.cardInfos.get(pos).Frequency = newCard.Frequency;
    } else {
        // 新标签，添加到列表
        newCard.count = 1;
        mCardDeviceList.cardInfos.add(newCard);
    }
}
```

#### 步骤 7：UI 更新

```java
Handler delayHandler = new Handler() {
    @Override
    public void handleMessage(Message msg) {
        switch (msg.what) {
            case UPDATE_LIST:
                // 刷新列表
                mCardInfoAdaptar.notifyDataSetChanged();
                // 更新统计信息
                tagscount.setText(
                    "Tags Count:" + mCardDeviceList.cardInfos.size() + 
                    "  Tags Times:" + mCardDeviceList.allcount
                );
                break;
        }
    }
};
```

------

## 五、关键参数配置规范与最佳实践

### 配置总览

RFID 参数配置遵循 **EPC Gen2（ISO 18000-6C）** 协议标准，主要配置项包括：

- **功率**：决定读取距离和能耗
- **Session**：控制标签响应行为
- **Target**：指定查询哪种状态的标签
- **Region**：符合当地法规的频段
- **盘点模式**：不同应用场景的策略

------

### 1. 功率配置规范

#### 标准配置代码

```java
Reader.AntPowerConf apcf = new Reader.AntPowerConf();
apcf.antcnt = 1;  // 天线数量（PDA 只有一个天线）

Reader.AntPower jaap = new Reader.AntPower();
jaap.readPower = 3300;   // 读功率：33.00 dBm（2W）
jaap.writePower = 3300;  // 写功率：33.00 dBm
jaap.antid = 1;          // 天线 ID

apcf.Powers[0] = jaap;
UHFParamsOperator.getInstance().setAntPowerConf(apcf);
```

#### 功率设置规范表

| 场景               | 读功率 (dBm) | 代码值    | 读取距离 | 适用环境         |
| ------------------ | ------------ | --------- | -------- | ---------------- |
| **近距离精准读取** | 10-15 dBm    | 1000-1500 | 0.5-1 米 | 珠宝店、药品管理 |
| **常规盘点**       | 20-25 dBm    | 2000-2500 | 3-5 米   | 服装店、图书馆   |
| **仓库物流**       | 27-30 dBm    | 2700-3000 | 6-8 米   | 仓库、物流中心   |
| **长距离读取**     | 30-33 dBm    | 3000-3300 | 8-12 米  | 车辆门禁、停车场 |

#### 功率配置原则

✅ **遵循最小功率原则**：能读到就行，不追求最大功率
 ✅ **写功率 ≥ 读功率**：写入需要更多能量
 ✅ **符合法规**：中国最大允许 33 dBm（2W ERP）
 ✅ **防止干扰**：密集环境降低功率避免读到不该读的标签

⚠️ **错误示例：**

```java
jaap.readPower = 5000;  // ❌ 超出最大值 3300
jaap.writePower = 1000; // ❌ 写功率小于读功率
```

------

### 2. Session 配置规范

#### 标准配置代码

```java
UHFParamsOperator.getInstance().setGen2Session(
    InventoryModeParams.SESSION.SESSION1  // 推荐默认值
);
```

#### Session 选择规范表

| Session | 超时时间 | 标签数量 | 读取速度 | 重复率 | 典型场景             |
| ------- | -------- | -------- | -------- | ------ | -------------------- |
| **S0**  | 50ms     | < 50     | 极快 ⚡⚡⚡ | 高     | 单品快速查找         |
| **S1**  | 500ms    | 50-200   | 快 ⚡⚡    | 中     | **通用盘点（推荐）** |
| **S2**  | 2000ms   | 200-500  | 中 ⚡     | 低     | 大量密集标签         |
| **S3**  | 永久     | 特殊     | 慢       | 极低   | 门禁、考勤           |

#### Session 配置原则

✅ **默认使用 SESSION1**：适用于 80% 的场景
 ✅ **标签少用 SESSION0**：追求速度时
 ✅ **标签多用 SESSION2**：避免重复读取
 ✅ **固定场景用 SESSION3**：如门禁通道

⚠️ **常见错误：**

```java
// ❌ 错误：大量标签场景用 SESSION0，导致重复读取严重
setGen2Session(InventoryModeParams.SESSION.SESSION0);  // 会读到大量重复

// ✅ 正确：
setGen2Session(InventoryModeParams.SESSION.SESSION1);
```

------

### 3. Target 配置规范

#### 标准配置代码

```java
UHFParamsOperator.getInstance().setGen2Target(
    InventoryModeParams.TARGET.A_2_B  // 推荐默认值
);
```

#### Target 选择规范表

| Target    | 工作机制        | 优点         | 缺点           | 适用场景             |
| --------- | --------------- | ------------ | -------------- | -------------------- |
| **A**     | 只读 A 状态标签 | 速度快       | 容易漏读       | 快速单次盘点         |
| **B**     | 只读 B 状态标签 | 读取遗漏标签 | 需要先转换状态 | 二次补漏盘点         |
| **A_2_B** | 读 A 后转 B     | 完整、防重复 | 稍慢           | **通用场景（推荐）** |

#### Target 配置原则

✅ **默认使用 A_2_B**：保证完整性和准确性
 ✅ **配合 Session 使用**：A_2_B + SESSION1 是黄金组合
 ✅ **二次盘点策略**：第一次 A_2_B，第二次 B（查漏）

#### 完整盘点配置示例

```java
// 推荐配置：完整盘点
setGen2Session(InventoryModeParams.SESSION.SESSION1);
setGen2Target(InventoryModeParams.TARGET.A_2_B);

// 快速盘点配置
setGen2Session(InventoryModeParams.SESSION.SESSION0);
setGen2Target(InventoryModeParams.TARGET.A);

// 密集标签配置
setGen2Session(InventoryModeParams.SESSION.SESSION2);
setGen2Target(InventoryModeParams.TARGET.A_2_B);
```

------

### 4. Region（区域）配置规范

#### 标准配置代码

```java
UHFParamsOperator.getInstance().setRegionConf(
    Reader.Region_Conf.RG_PRC  // 中国必须使用
);
```

#### 区域频段规范表

| 区域代码     | 地区   | 频率范围              | 信道数 | 法规依据              |
| ------------ | ------ | --------------------- | ------ | --------------------- |
| **RG_PRC**   | 中国   | 920.125 - 924.875 MHz | 16     | 工信部无〔2007〕205号 |
| **RG_NA**    | 北美   | 902 - 928 MHz         | 50     | FCC Part 15           |
| **RG_EU**    | 欧洲   | 865 - 868 MHz         | 15     | ETSI EN 302 208       |
| **RG_JAPAN** | 日本   | 952 - 955 MHz         | 4      | ARIB STD-T89          |
| **RG_OPEN**  | 全频段 | 860 - 960 MHz         | -      | ⚠️ 仅测试用            |

#### Region 配置原则

✅ **严格遵守当地法规**：在中国必须用 RG_PRC
 ✅ **出口设备需配置对应区域**：产品销往哪里用哪个
 ✅ **禁止使用 RG_OPEN**：除非在屏蔽实验室测试
 ✅ **配置后需验证**：读取配置确认是否生效

#### 验证配置代码

```java
// 设置区域
Reader.READER_ERR er = UHFParamsOperator.getInstance()
    .setRegionConf(Reader.Region_Conf.RG_PRC);

// 验证是否设置成功
RegionConfResult result = UHFParamsOperator.getInstance().getRegionConf();
if (result.code == Reader.READER_ERR.MT_OK_ERR) {
    Log.e("Region", "当前区域: " + CoverUtil.CoverRegion(result.value));
} else {
    Log.e("Region", "获取区域失败");
}
```

⚠️ **违规后果：**

- 干扰其他合法无线电业务
- 被无线电管理部门处罚
- 设备被没收或销毁

------

### 5. 盘点模式配置规范

#### 标准配置代码

```java
InventoryParams params = InventoryModeParams.getParams(
    InventoryModeParams.MODE.NORMAL,        // 盘点模式
    InventoryModeParams.inventoryParams,    // 扩展参数
    true                                     // 是否读取 TID
);
```

#### 盘点模式规范表

| 模式       | 读取内容 | 速度     | 功耗 | TID支持 | 适用场景             |
| ---------- | -------- | -------- | ---- | ------- | -------------------- |
| **NORMAL** | EPC      | 快 ⚡⚡    | 中   | 可选    | **通用盘点（推荐）** |
| **FAST**   | EPC      | 极快 ⚡⚡⚡ | 低   | 否      | 快速扫描、实时监控   |
| **DENSE**  | EPC      | 中 ⚡     | 高   | 可选    | 大量密集标签         |
| **TID**    | EPC+TID  | 慢       | 高   | 是      | 防伪验证、溯源       |

#### 是否读取 TID 的选择

**读取 TID 的优点：**

- 防伪：TID 出厂固化，无法篡改
- 溯源：追踪标签来源和批次
- 唯一性：即使 EPC 相同，TID 也不同

**读取 TID 的缺点：**

- 速度慢：读取时间增加 30-50%
- 功耗高：需要更多射频能量
- 距离短：TID 区读取距离约为 EPC 的 70%

#### 配置建议

```java
// 场景 1：普通盘点（不需要 TID）
InventoryParams params = InventoryModeParams.getParams(
    InventoryModeParams.MODE.NORMAL,
    InventoryModeParams.inventoryParams,
    false  // 不读 TID，速度快
);

// 场景 2：防伪验证（需要 TID）
InventoryParams params = InventoryModeParams.getParams(
    InventoryModeParams.MODE.TID,
    InventoryModeParams.inventoryParams,
    true   // 读 TID，可验证真伪
);

// 场景 3：大量标签快速盘点
InventoryParams params = InventoryModeParams.getParams(
    InventoryModeParams.MODE.FAST,
    InventoryModeParams.inventoryParams,
    false  // FAST 模式不支持 TID
);
```

------

### 6. 完整初始化配置规范

#### 标准初始化流程

```java
private void initRFIDModule() {
    // 1. 上电
    UHFEngine.getEngine().powerOn();
    
    // 2. 连接模块
    Reader.READER_ERR er = UHFEngine.getEngine().connectModule(
        DefaultConfigure.UART_DEV_PATH, 1
    );
    
    if (er != Reader.READER_ERR.MT_OK_ERR) {
        Log.e("RFID", "连接失败");
        return;
    }
    
    // 3. 配置功率
    Reader.AntPowerConf apcf = new Reader.AntPowerConf();
    apcf.antcnt = 1;
    Reader.AntPower jaap = new Reader.AntPower();
    jaap.readPower = 3000;   // 30 dBm
    jaap.writePower = 3000;
    jaap.antid = 1;
    apcf.Powers[0] = jaap;
    UHFParamsOperator.getInstance().setAntPowerConf(apcf);
    
    // 4. 配置 Session
    UHFParamsOperator.getInstance().setGen2Session(
        InventoryModeParams.SESSION.SESSION1
    );
    
    // 5. 配置 Target
    UHFParamsOperator.getInstance().setGen2Target(
        InventoryModeParams.TARGET.A_2_B
    );
    
    // 6. 配置区域
    UHFParamsOperator.getInstance().setRegionConf(
        Reader.Region_Conf.RG_PRC
    );
    
    // 7. 验证配置
    verifyConfiguration();
    
    Log.e("RFID", "初始化成功");
}

private void verifyConfiguration() {
    // 验证功率
    AntPowerConfResult powerResult = UHFParamsOperator.getInstance()
        .getAntPowerConf();
    Log.e("Config", "读功率: " + powerResult.value.Powers[0].readPower);
    
    // 验证 Session
    Gen2SessionResult sessionResult = UHFParamsOperator.getInstance()
        .getGen2Session();
    Log.e("Config", "Session: " + sessionResult.value);
    
    // 验证 Target
    Gen2TargetResult targetResult = UHFParamsOperator.getInstance()
        .getGen2Target();
    Log.e("Config", "Target: " + targetResult.value);
    
    // 验证区域
    RegionConfResult regionResult = UHFParamsOperator.getInstance()
        .getRegionConf();
    Log.e("Config", "区域: " + CoverUtil.CoverRegion(regionResult.value));
}
```

------

### 7. 场景化配置方案

#### 方案 1：服装零售店

```java
// 标签数量：50-100 个
// 读取距离：3-5 米
// 速度要求：中等
jaap.readPower = 2500;      // 25 dBm
setGen2Session(SESSION.SESSION1);
setGen2Target(TARGET.A_2_B);
setRegionConf(RG_PRC);
InventoryParams params = getParams(MODE.NORMAL, null, false);
```

#### 方案 2：大型仓库

```java
// 标签数量：200-500 个
// 读取距离：6-10 米
// 速度要求：中低
jaap.readPower = 3000;      // 30 dBm
setGen2Session(SESSION.SESSION2);  // 防止重复
setGen2Target(TARGET.A_2_B);
setRegionConf(RG_PRC);
InventoryParams params = getParams(MODE.DENSE, null, false);
```

#### 方案 3：珠宝管理

```java
// 标签数量：< 20 个
// 读取距离：0.5-1 米
// 速度要求：快速
// 特殊需求：防伪验证
jaap.readPower = 1500;      // 15 dBm（低功率，避免误读）
setGen2Session(SESSION.SESSION0);
setGen2Target(TARGET.A);
setRegionConf(RG_PRC);
InventoryParams params = getParams(MODE.TID, null, true);  // 读 TID 防伪
```

#### 方案 4：停车场门禁

```java
// 标签数量：1-2 个（车辆）
// 读取距离：8-12 米
// 速度要求：极快
// 特殊需求：远距离读取
jaap.readPower = 3300;      // 33 dBm（最大功率）
setGen2Session(SESSION.SESSION0);  // 快速响应
setGen2Target(TARGET.A);
setRegionConf(RG_PRC);
InventoryParams params = getParams(MODE.FAST, null, false);
```

#### 方案 5：图书馆

```java
// 标签数量：100-200 本书
// 读取距离：2-3 米
// 速度要求：中等
// 特殊需求：准确率高
jaap.readPower = 2000;      // 20 dBm
setGen2Session(SESSION.SESSION1);
setGen2Target(TARGET.A_2_B);
setRegionConf(RG_PRC);
InventoryParams params = getParams(MODE.NORMAL, null, false);
```

------

### 8. 参数优化调试流程

#### 步骤 1：基线测试

```java
// 使用默认配置进行测试
jaap.readPower = 2500;
setGen2Session(SESSION.SESSION1);
setGen2Target(TARGET.A_2_B);
// 记录：读取率、重复率、漏读率、读取时间
```

#### 步骤 2：调整功率

```java
// 如果读取率低（< 90%）
jaap.readPower = 3000;  // 增大功率

// 如果误读其他区域标签
jaap.readPower = 2000;  // 降低功率
```

#### 步骤 3：调整 Session

```java
// 如果重复率高（> 20%）
setGen2Session(SESSION.SESSION2);  // 延长超时时间

// 如果速度太慢
setGen2Session(SESSION.SESSION0);  // 缩短超时时间
```

#### 步骤 4：验证配置

```java
// 进行 100 次测试，统计：
// - 平均读取率
// - 平均重复率
// - 平均读取时间
// 如果不满足要求，返回步骤 2
```

------

### 9. 配置常见错误与解决方案

| 问题现象          | 可能原因         | 解决方案                   |
| ----------------- | ---------------- | -------------------------- |
| 读取率低（< 80%） | 功率太小         | 增大读功率到 27-30 dBm     |
|                   | 标签太多碰撞     | 使用 DENSE 模式 + SESSION2 |
|                   | 金属干扰         | 使用抗金属标签或调整角度   |
| 重复读取严重      | Session 超时太短 | SESSION0 → SESSION1        |
|                   | Target 设置错误  | 改用 A_2_B                 |
| 误读其他区域标签  | 功率太大         | 降低功率到 20-25 dBm       |
| 读取距离太近      | 功率太小         | 增大功率                   |
|                   | 标签类型不匹配   | 更换远距离标签             |
| 速度太慢          | 读 TID 导致      | 关闭 TID 读取              |
|                   | Session 超时太长 | SESSION2 → SESSION1        |
| 连接失败          | 未上电           | 先调用 powerOn()           |
|                   | 路径错误         | 检查 UART_DEV_PATH         |
| 配置不生效        | 未验证配置       | 调用 get 方法验证          |

------

### 10. 配置参数速查表

#### 推荐默认配置

```java
// 适用于 80% 的场景
读功率：2500 (25 dBm)
写功率：2500 (25 dBm)
Session：SESSION1
Target：A_2_B
Region：RG_PRC（中国）
Mode：NORMAL
读TID：false
```

#### 快速配置代码模板

```java
public class RFIDConfig {
    // 通用配置
    public static void configureStandard() {
        setPower(2500, 2500);
        setGen2Session(SESSION.SESSION1);
        setGen2Target(TARGET.A_2_B);
        setRegionConf(RG_PRC);
    }
    
    // 高性能配置（速度优先）
    public static void configureHighSpeed() {
        setPower(2000, 2000);
        setGen2Session(SESSION.SESSION0);
        setGen2Target(TARGET.A);
        setRegionConf(RG_PRC);
    }
    
    // 高准确率配置（准确性优先）
    public static void configureHighAccuracy() {
        setPower(3000, 3000);
        setGen2Session(SESSION.SESSION2);
        setGen2Target(TARGET.A_2_B);
        setRegionConf(RG_PRC);
    }
    
    private static void setPower(int read, int write) {
        Reader.AntPowerConf apcf = new Reader.AntPowerConf();
        apcf.antcnt = 1;
        Reader.AntPower jaap = new Reader.AntPower();
        jaap.readPower = read;
        jaap.writePower = write;
        jaap.antid = 1;
        apcf.Powers[0] = jaap;
        UHFParamsOperator.getInstance().setAntPowerConf(apcf);
    }
}
```

------

### 配置规范总结

✅ **必须遵守的规范：**

1. 在中国必须使用 RG_PRC 区域
2. 功率不得超过 33 dBm
3. 写功率必须 ≥ 读功率
4. 配置后必须验证是否生效

✅ **推荐的实践：**

1. 优先使用 SESSION1 + A_2_B 组合
2. 从低功率开始测试，逐步增大
3. 不需要防伪时关闭 TID 读取
4. 定期记录和优化配置参数

✅ **性能优化原则：**

1. 功率：够用即可，不追求最大
2. Session：标签越多超时越长
3. Target：默认用 A_2_B
4. Mode：默认用 NORMAL

这些配置规范遵循 EPC Gen2 协议标准，结合实际应用经验总结而成。

------

## 六、数据导出功能

```java
if(id == R.id.exportBtn){
    String filepath = Environment.getExternalStorageDirectory().getPath();
    int status = ExcelUtil.writeExcel(
        filepath + "/Documents/Export_UHFTags_" + 
        Util.getCurrentTimeFormat() + ".xls",
        mCardDeviceList.cardInfos
    );
    
    if(status == 0){
        Toast.makeText(this, "导出成功！", Toast.LENGTH_SHORT).show();
    }
}
```

**导出位置：** `/sdcard/Documents/Export_UHFTags_YYYYMMDD_HHMMSS.xls`

------

## 七、硬件按键监听

```java
@Override
public boolean onKeyDown(int keyCode, KeyEvent event) {
    // 监听扫描按键（KeyCode 292 或 F1）
    if(!iskeydown && (keyCode == 292 || keyCode == KeyEvent.KEYCODE_F1)){
        if(inventoryRunning){
            stopInventory();
        } else {
            startInventory();
        }
        return true;
    }
    return super.onKeyDown(keyCode, event);
}
```

**说明：** PDA 设备通常有专用的扫描按键，按下可快速启动/停止盘点

------

## 八、常见问题解答

### Q1: 为什么需要 onResume/onPause 中上下电？

**A:** Android 生命周期管理，页面切到后台时释放硬件资源，避免：

- 持续耗电
- 其他应用无法使用 RFID 模块
- 资源泄漏

### Q2: 信号强度（RSSI）是什么？

**A:** Received Signal Strength Indicator，接收信号强度指示

- 值越大（如 -30）表示信号越强，标签离读写器越近
- 值越小（如 -80）表示信号越弱，距离越远

### Q3: EPC 和 TID 有什么区别？

**A:**

- **EPC**：Electronic Product Code，可读写，用户可修改
- **TID**：Tag Identifier，标签唯一 ID，出厂固化，不可修改

### Q4: 为什么要去重？

**A:** RFID 读写器每秒可读取标签数百次，同一标签会被多次读取，去重是为了：

- 显示唯一标签数量
- 统计每个标签的读取次数（count 字段）

### Q5: 如何提高读取率？

**A:**

1. 调整功率（增大读功率）
2. 调整 Session（标签多用 SESSION1）
3. 调整天线角度
4. 减少金属干扰
5. 标签间保持一定距离

------

## 九、项目架构总结

```
MainActivity（主界面）
├── 初始化 RFID 引擎
├── 配置模块参数（功率、Session、Region）
├── 启动/停止盘点
├── 监听标签数据回调
├── 更新 UI 列表
└── 页面跳转
    ├── SettingActivity（设置页面）
    └── ReadWriteLockActivity（读写锁定页面）
```

**数据流：**

```
RFID 标签 → 射频信号 → 读写器 → UHFEngine → ReadListener → 
Handler → UI 更新 → 用户看到结果
```

------

## 十、学习建议

1. **先理解生命周期**：onResume/onPause 的作用
2. **掌握 Intent 跳转**：页面间如何传递数据
3. **理解异步回调**：ReadListener 如何工作
4. **熟悉 Handler 机制**：线程间通信，更新 UI
5. **实践参数调优**：不同场景下的 Session、Target 配置

------

## 附录：重要方法速查表

| 方法                | 作用           |
| ------------------- | -------------- |
| `powerOn()`         | RFID 模块上电  |
| `powerOff()`        | RFID 模块下电  |
| `connectModule()`   | 连接 RFID 模块 |
| `startInventory()`  | 开始盘点       |
| `stopInventory()`   | 停止盘点       |
| `setAntPowerConf()` | 设置天线功率   |
| `setGen2Session()`  | 设置 Session   |
| `setGen2Target()`   | 设置 Target    |
| `setRegionConf()`   | 设置区域频段   |