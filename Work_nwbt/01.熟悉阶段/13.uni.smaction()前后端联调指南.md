# 架构前后端请求与返回完整指南

## 前端封装方法详解

### 方法签名

```javascript
uni.smaction(cb, param, pobj)
```

### 参数说明

| 参数  | 类型     | 必填 | 说明                                             |
| ----- | -------- | ---- | ------------------------------------------------ |
| cb    | Function | 否   | 回调函数，格式：`function(data, error, rawData)` |
| param | Object   | 是   | 请求参数，JSON对象格式                           |
| pobj  | Object   | 是   | 配置对象，包含route、action等                    |

**pobj配置项：**

```javascript
{
    route: 'uniwarehouse',        // 必填：微服务名称
    action: 'inventory/findByEpc', // 必填：Controller路径
    method: 'POST',                // 可选：默认GET
    datastring: true               // 可选：是否将param转为JSON字符串
}
```

------

### 完整封装  --- smaction()   App.vue

```js
/**
			 * 请求controller的方法
			 * @param {Object} cb 调用结束后的回调
			 * @param {Object} param 请求的参数 json对象格式
			 * @param {Object} pobj 必填，包含route(路由，既微服务名称)、action(controller路径)，其他key自定。 例如：{route:'bzn-xcx-tbpt', action: 'yey/list'}
			 */
smaction: function(cb, param, pobj) {
    if (typeof cb == 'object') {
        var arrtemp = cb;
        cb = param;
        param = arrtemp;
    }
    if (!pobj) {
        pobj = {};
    }
    if (!pobj || !pobj.action) {
        return cb(null, '路由不能为空');
    }
    var token = uni.getStorageSync('token');
    if (token) {
        param.Authorization = 'Bearer ' + token;
    }
    var url = '/' + pobj.route + '/' + pobj.action;
    uni.request({
        // #ifdef H5
        url: url,
        // #endif
        // #ifndef H5
        url: _this.globalData.geturl(pobj.route || "", pobj.action),
        // #endif				
        //请求方式
        method: pobj.method || "GET",
        //请求数据
        data: pobj.datastring ? JSON.stringify(param) : param,
        // #ifndef H5
        header: _this.globalData.headers,
        // #endif
        //处理session问题
        success: function(res) {
            //console.log(res);
            if (res.data) {
                if (res.data.code) {
                    var result = res.data && res.data.data ? JSON.parse(res.data.data) : {};
                    if (res.data.code == 200) {
                        return cb(result || res.data.msg, null, result || res.data.msg);
                    } else {
                        return cb(null, res.data.msg, result);
                    }
                }
                var strtype = Object.prototype.toString.apply(res.data.data);

                if (strtype == '[object Array]') {
                    cb(res.data);
                } else if (strtype == '[object Object]') {
                    if (res.data.error || res.data.code == 500) {
                        console.log('请求数据', param);
                        console.log('请求服务', pobj);
                        console.log(res.data);
                        if (res.data.error == "nologin") {
                            return uni.navigateTo({
                                url: "/pages/login/login"
                            })
                        }

                        if (typeof res.data == 'object') {
                            if (res.data.mess) {}
                        }

                        cb(res.data, res.data.error || res.data.msg, res.data);
                    } else {
                        cb(res.data.re || res.data, res.data.error, res.data);
                    }
                } else {
                    cb(null, res.data.error || res.data.msg, res.data);
                }
            } else {
                cb(null, '请求失败');
            }
        },
        fail: function(res) {
            cb(null, '请求失败');
        }
    });
},
```

### 调用示例

#### 示例1：完整写法（推荐）

```javascript
uni.smaction(
    // 回调函数
    function(data, error, rawData) {
        if (error) {
            console.log('请求失败：', error);
            uni.showToast({
                title: error,
                icon: 'none'
            });
        } else {
            console.log('请求成功：', data);
            console.log('标签列表：', data.tagList);
        }
    },
    // 请求参数
    {
        tagList: JSON.stringify(['tag1', 'tag2', 'tag3'])
    },
    // 配置对象
    {
        route: 'uniwarehouse',
        action: 'inventory/findByEpc',
        method: 'POST',
        datastring: true
    }
);
```

文件中的写法：

```js
uni.smaction(function(re, err) {
    if (err) {
        console.log(err)
        return uni.msg(err);
    }
    console.log(re)
}, { tagList }, {
    route: uni.svs.auth,
    action: 'inventory/findProduct/selectByEpcList', // 盘点到的物品详情
    method: 'POST'
});
```

#### 示例2：省略回调（适用于不需要处理返回值的场景）

```javascript
uni.smaction(
    {tagList: JSON.stringify(tags)},
    {
        route: 'uniwarehouse',
        action: 'inventory/findByEpc',
        method: 'POST',
        datastring: true
    }
);
```

------

### 内部工作流程

#### 第1步：参数兼容处理

```javascript
if (typeof cb == 'object') {
    // 用户省略了回调函数，调整参数位置
    var arrtemp = cb;
    cb = param;
    param = arrtemp;
}
```

**说明**：允许灵活调用，`smaction(param, pobj)` 会被转换为 `smaction(null, param, pobj)`

------

#### 第2步：自动添加Token

```javascript
var token = uni.getStorageSync('token');
if(token){
    param.Authorization = 'Bearer ' + token;
}
```

**说明**：

- 从本地存储读取token
- 自动添加到请求参数中
- **后端可以通过 `@RequestHeader` 或 `@RequestParam` 接收**

------

#### 第3步：发起HTTP请求

```javascript
uni.request({
    url: '/' + pobj.route + '/' + pobj.action,
    method: pobj.method || "GET",
    data: pobj.datastring ? JSON.stringify(param) : param,
    success: function(res) { /* 处理响应 */ },
    fail: function(res) { /* 处理失败 */ }
});
```

**重要配置项：**

- **datastring: true** → 发送 `JSON.stringify(param)`，后端用 `@RequestBody String` 接收
- **datastring: false** → 发送普通对象，后端用 `@RequestParam` 接收

------

#### 第4步：响应处理逻辑

**标准返回格式（后端必须遵守）：**

```json
{
    "code": 200,
    "data": "{\"tagList\":[\"tag1\",\"tag2\"]}",  // 注意：这是字符串！
    "msg": "success"
}
```

**前端处理流程：**

```javascript
if (res.data.code) {
    // 解析data字段（从字符串转为对象）
    var result = res.data.data ? JSON.parse(res.data.data) : {};
    
    if (res.data.code == 200) {
        // 成功：cb(数据, null, 数据)
        return cb(result, null, result);
    } else {
        // 失败：cb(null, 错误信息, 数据)
        return cb(null, res.data.msg, result);
    }
}
```

**回调函数参数说明：**

```javascript
cb(data, error, rawData)
```

- `data`：成功时的解析后数据，失败时为 `null`
- `error`：错误信息，成功时为 `null`
- `rawData`：原始数据对象

------

## 参数传递方式详解

### 核心概念

在 `smaction` 中，参数的传递方式取决于两个关键因素：

1. **请求方法**：`GET` 或 `POST`
2. **datastring配置**：`true`（JSON格式）或 `false`（表单格式/URL参数）

------

### 传递方式对照表<font color = red >（注意事项）</font>

| 请求方法 | datastring | 数据位置    | Content-Type                      | 后端接收              |
| -------- | ---------- | ----------- | --------------------------------- | --------------------- |
| GET      | -          | URL查询参数 | -                                 | `@RequestParam`       |
| POST     | false      | 表单数据    | application/x-www-form-urlencoded | `@RequestParam`       |
| POST     | true       | 请求体      | application/json                  | `@RequestBody String` |

------

### 方式1：GET请求 - URL参数传递

**适用场景**：简单查询、列表获取、分页查询

#### 前端调用

```javascript
uni.smaction(
    function(data, error) {
        if (!error) {
            console.log('查询结果：', data);
        }
    },
    {
        status: 'active',
        category: 'electronics',
        page: 1,
        pageSize: 20
    },
    {
        route: 'uniwarehouse',
        action: 'product/list',
        method: 'GET'  // GET请求
        // 不设置 datastring 或 datastring: false
    }
);
```

#### 实际HTTP请求

```http
GET /uniwarehouse/product/list?status=active&category=electronics&page=1&pageSize=20 HTTP/1.1
Host: your-domain.com
```

#### 后端接收

```java
@GetMapping("/list")
public AjaxResult list(@RequestParam Map<String, String> param) {
    String status = param.get("status");      // "active"
    String category = param.get("category");  // "electronics"
    Integer page = Integer.parseInt(param.get("page"));  // 1
    
    List<Product> products = productService.list(status, category, page);
    return AjaxResult.success("查询成功", JSON.toJSONString(products));
}

// 或者使用具体参数
@GetMapping("/list")
public AjaxResult list(
    @RequestParam(required = false) String status,
    @RequestParam(required = false) String category,
    @RequestParam(defaultValue = "1") Integer page,
    @RequestParam(defaultValue = "20") Integer pageSize
) {
    // 直接使用参数
    return AjaxResult.success("查询成功", JSON.toJSONString(products));
}
```

------

### 方式2：POST + 表单格式（datastring: false）

**适用场景**：简单表单提交、更新操作

#### 前端调用

```javascript
uni.smaction(
    function(data, error) {
        if (!error) {
            uni.showToast({title: '提交成功'});
        }
    },
    {
        productName: '新产品',
        price: '99.99',
        stock: '100',
        description: '这是一个新产品'
    },
    {
        route: 'uniwarehouse',
        action: 'product/add',
        method: 'POST',
        datastring: false  // 表单格式（默认值）
    }
);
```

#### 实际HTTP请求

```http
POST /uniwarehouse/product/add HTTP/1.1
Content-Type: application/x-www-form-urlencoded

productName=新产品&price=99.99&stock=100&description=这是一个新产品
```

#### 后端接收

```java
@PostMapping("/add")
public AjaxResult add(@RequestParam Map<String, String> param) {
    String productName = param.get("productName");
    String price = param.get("price");
    String stock = param.get("stock");
    String description = param.get("description");
    
    Product product = new Product(productName, price, stock, description);
    productService.add(product);
    
    return AjaxResult.success("添加成功");
}

// 或者定义DTO对象
@PostMapping("/add")
public AjaxResult add(ProductDTO productDTO) {
    // Spring自动将参数绑定到对象
    productService.add(productDTO);
    return AjaxResult.success("添加成功");
}
```

------

### 方式3：POST + JSON格式（datastring: true）⭐

**适用场景**：复杂数据、数组传递、嵌套对象（你的项目主要使用这种方式）

#### 前端调用

```javascript
uni.smaction(
    function(data, error) {
        if (!error) {
            console.log('处理结果：', data);
        }
    },
    {
        tagList: JSON.stringify(['E280691500004', 'E280691500005', 'E280691500006']),
        type: 'product',
        filters: JSON.stringify({
            status: 'active',
            minPrice: 100,
            maxPrice: 1000
        })
    },
    {
        route: 'uniwarehouse',
        action: 'inventory/findByEpc',
        method: 'POST',
        datastring: true  // 关键配置：转为JSON格式
    }
);
```

#### 实际HTTP请求

```http
POST /uniwarehouse/inventory/findByEpc HTTP/1.1
Content-Type: application/json

{
    "tagList": "[\"E280691500004\",\"E280691500005\",\"E280691500006\"]",
    "type": "product",
    "filters": "{\"status\":\"active\",\"minPrice\":100,\"maxPrice\":1000}",
    "Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}
```

#### 后端接收

```java
@PostMapping("/findByEpc")
public AjaxResult findByEpc(
    @RequestBody String postdata,           // 接收整个JSON字符串
    @RequestParam Map<String, String> param // 注意：这里是空的！数据都在body里
) {
    try {
        // 解析JSON
        JSONObject jsonObject = JSONObject.parseObject(postdata);
        
        // 提取并解析tagList（字符串 → 数组）
        String tagListStr = jsonObject.getString("tagList");
        List<String> tagList = JSONArray.parseArray(tagListStr).toJavaList(String.class);
        
        // 提取type
        String type = jsonObject.getString("type");
        
        // 提取并解析filters（字符串 → 对象）
        String filtersStr = jsonObject.getString("filters");
        JSONObject filters = JSONObject.parseObject(filtersStr);
        String status = filters.getString("status");
        Integer minPrice = filters.getInteger("minPrice");
        
        // 业务处理
        List<Product> products = productService.findByTags(tagList, type, filters);
        
        // 构建返回结果
        JSONObject result = new JSONObject();
        result.put("products", products);
        result.put("total", products.size());
        
        return AjaxResult.success("查询成功", result.toJSONString());
        
    } catch (Exception e) {
        log.error("处理失败", e);
        return AjaxResult.error("处理失败：" + e.getMessage());
    }
}
```

------

### 方式4：混合传递（URL参数 + Body数据）

**适用场景**：分页查询 + 复杂过滤条件

#### 前端调用

```javascript
uni.smaction(
    function(data, error) {
        if (!error) {
            console.log('分页数据：', data);
        }
    },
    {
        tagList: JSON.stringify(['tag1', 'tag2']),
        searchText: '关键词'
    },
    {
        route: 'uniwarehouse',
        action: 'inventory/search?page=1&pageSize=10&sortBy=createTime',  // URL参数
        method: 'POST',
        datastring: true
    }
);
```

#### 实际HTTP请求

```http
POST /uniwarehouse/inventory/search?page=1&pageSize=10&sortBy=createTime HTTP/1.1
Content-Type: application/json

{
    "tagList": "[\"tag1\",\"tag2\"]",
    "searchText": "关键词",
    "Authorization": "Bearer xxx"
}
```

#### 后端接收

```java
@PostMapping("/search")
public AjaxResult search(
    @RequestParam Map<String, String> param,  // 接收URL参数
    @RequestBody String postdata              // 接收Body数据
) {
    // ========== 处理URL参数 ==========
    Integer page = Integer.parseInt(param.getOrDefault("page", "1"));
    Integer pageSize = Integer.parseInt(param.getOrDefault("pageSize", "10"));
    String sortBy = param.getOrDefault("sortBy", "createTime");
    
    log.info("分页参数 - page:{}, pageSize:{}, sortBy:{}", page, pageSize, sortBy);
    
    // ========== 处理Body数据 ==========
    JSONObject jsonObject = JSONObject.parseObject(postdata);
    
    String tagListStr = jsonObject.getString("tagList");
    List<String> tagList = JSONArray.parseArray(tagListStr).toJavaList(String.class);
    
    String searchText = jsonObject.getString("searchText");
    
    log.info("搜索条件 - tagList:{}, searchText:{}", tagList, searchText);
    
    // ========== 业务处理 ==========
    PageInfo<Product> pageInfo = productService.search(
        tagList, searchText, page, pageSize, sortBy
    );
    
    // ========== 构建返回 ==========
    JSONObject result = new JSONObject();
    result.put("list", pageInfo.getList());
    result.put("total", pageInfo.getTotal());
    result.put("currentPage", page);
    result.put("pageSize", pageSize);
    
    return AjaxResult.success("查询成功", result.toJSONString());
}
```

------

### 关键源码解析

在 `smaction` 方法中，参数传递的核心代码：

```javascript
uni.request({
    url: '/' + pobj.route + '/' + pobj.action,  // URL路径（可能包含查询参数）
    method: pobj.method || "GET",                // 请求方法
    data: pobj.datastring ? JSON.stringify(param) : param,  // 关键！
    success: function(res) { /* ... */ }
});
```

#### data字段的处理逻辑

```javascript
// 场景1：datastring: true
data: JSON.stringify(param)
// 输入：{tagList: "[...]", type: "product"}
// 输出：'{"tagList":"[...]","type":"product"}'
// 结果：作为 Request Body 发送，Content-Type: application/json

// 场景2：datastring: false（或不设置）
data: param
// 输入：{id: "123", name: "产品"}
// 输出：{id: "123", name: "产品"}
// 结果：
//   - GET请求 → 转为URL参数：?id=123&name=产品
//   - POST请求 → 表单格式：id=123&name=产品
```

------

### 实战案例对比

#### 案例1：商品列表查询（推荐GET）

```javascript
// 前端
uni.smaction(
    callback,
    {
        category: '电子产品',
        status: 'active',
        page: 1,
        pageSize: 20
    },
    {
        route: 'uniwarehouse',
        action: 'product/list',
        method: 'GET'
    }
);

// 后端
@GetMapping("/list")
public AjaxResult list(
    @RequestParam(required = false) String category,
    @RequestParam(defaultValue = "active") String status,
    @RequestParam(defaultValue = "1") Integer page,
    @RequestParam(defaultValue = "20") Integer pageSize
) {
    PageInfo<Product> pageInfo = productService.getList(category, status, page, pageSize);
    return AjaxResult.success("查询成功", JSON.toJSONString(pageInfo));
}
```

**特点**：

- ✅ URL可见，方便调试
- ✅ 可以直接在浏览器访问
- ✅ 适合简单查询

------

#### 案例2：添加商品（推荐POST + 表单）

```javascript
// 前端
uni.smaction(
    callback,
    {
        productName: '新手机',
        brand: '华为',
        price: '3999',
        stock: '50'
    },
    {
        route: 'uniwarehouse',
        action: 'product/add',
        method: 'POST',
        datastring: false
    }
);

// 后端
@PostMapping("/add")
public AjaxResult add(
    @RequestParam String productName,
    @RequestParam String brand,
    @RequestParam String price,
    @RequestParam String stock
) {
    Product product = new Product(productName, brand, price, stock);
    productService.add(product);
    return AjaxResult.success("添加成功");
}
```

**特点**：

- ✅ 简单直观
- ✅ 适合表单提交
- ✅ 后端接收简单

------

#### 案例3：批量查询（推荐POST + JSON）

```javascript
// 前端
uni.smaction(
    callback,
    {
        epcList: JSON.stringify(['EPC001', 'EPC002', 'EPC003', 'EPC004', 'EPC005']),
        includeDetails: true,
        fields: JSON.stringify(['name', 'price', 'stock', 'location'])
    },
    {
        route: 'uniwarehouse',
        action: 'inventory/batchQuery',
        method: 'POST',
        datastring: true  // 必须用JSON格式
    }
);

// 后端
@PostMapping("/batchQuery")
public AjaxResult batchQuery(@RequestBody String postdata) {
    JSONObject jsonObject = JSONObject.parseObject(postdata);
    
    // 解析EPC列表
    List<String> epcList = JSONArray.parseArray(
        jsonObject.getString("epcList")
    ).toJavaList(String.class);
    
    // 解析字段列表
    List<String> fields = JSONArray.parseArray(
        jsonObject.getString("fields")
    ).toJavaList(String.class);
    
    Boolean includeDetails = jsonObject.getBoolean("includeDetails");
    
    // 批量查询
    List<Product> products = inventoryService.batchQuery(epcList, fields, includeDetails);
    
    JSONObject result = new JSONObject();
    result.put("products", products);
    result.put("count", products.size());
    
    return AjaxResult.success("查询成功", result.toJSONString());
}
```

**特点**：

- ✅ 支持复杂数据结构
- ✅ 可以传递数组、嵌套对象
- ✅ 适合大量数据

------

#### 案例4：高级搜索（混合方式）

```javascript
// 前端
uni.smaction(
    callback,
    {
        keyword: '手机',
        filters: JSON.stringify({
            brands: ['华为', '小米', '苹果'],
            priceRange: {min: 1000, max: 5000},
            tags: ['5G', '大屏']
        })
    },
    {
        route: 'uniwarehouse',
        action: 'product/search?page=1&pageSize=20&sortBy=price&order=asc',
        method: 'POST',
        datastring: true
    }
);

// 后端
@PostMapping("/search")
public AjaxResult search(
    @RequestParam Integer page,
    @RequestParam Integer pageSize,
    @RequestParam String sortBy,
    @RequestParam String order,
    @RequestBody String postdata
) {
    // URL参数：分页和排序
    log.info("分页：page={}, pageSize={}", page, pageSize);
    log.info("排序：sortBy={}, order={}", sortBy, order);
    
    // Body参数：搜索条件
    JSONObject jsonObject = JSONObject.parseObject(postdata);
    String keyword = jsonObject.getString("keyword");
    
    JSONObject filters = JSONObject.parseObject(jsonObject.getString("filters"));
    List<String> brands = filters.getJSONArray("brands").toJavaList(String.class);
    JSONObject priceRange = filters.getJSONObject("priceRange");
    List<String> tags = filters.getJSONArray("tags").toJavaList(String.class);
    
    // 执行搜索
    SearchResult result = productService.advancedSearch(
        keyword, brands, priceRange, tags, page, pageSize, sortBy, order
    );
    
    return AjaxResult.success("搜索成功", JSON.toJSONString(result));
}
```

**特点**：

- ✅ 分离关注点：URL参数管分页，Body管搜索条件
- ✅ 灵活性高
- ✅ 适合复杂业务场景

------

### 参数传递最佳实践

#### 1. 选择合适的传递方式

| 数据特征           | 推荐方式    | 原因               |
| ------------------ | ----------- | ------------------ |
| 简单键值对（≤5个） | GET         | 直观、可缓存       |
| 表单数据           | POST + 表单 | 标准做法           |
| 包含数组           | POST + JSON | 表单格式不支持数组 |
| 包含嵌套对象       | POST + JSON | 表单格式不支持嵌套 |
| 敏感数据           | POST + JSON | 不在URL显示        |
| 大量数据           | POST + JSON | URL有长度限制      |

#### 2. 前端编码规范

```javascript
// ✅ 好的做法
uni.smaction(
    callback,
    {
        // 数组必须转字符串
        tags: JSON.stringify(['tag1', 'tag2']),
        // 对象必须转字符串
        filters: JSON.stringify({status: 'active'}),
        // 简单值直接传
        keyword: 'test'
    },
    {
        route: 'uniwarehouse',
        action: 'product/search',
        method: 'POST',
        datastring: true  // 明确指定
    }
);

// ❌ 错误做法
uni.smaction(
    callback,
    {
        tags: ['tag1', 'tag2'],  // 错误：数组没有转字符串
        filters: {status: 'active'}  // 错误：对象没有转字符串
    },
    {
        route: 'uniwarehouse',
        action: 'product/search',
        method: 'POST',
        datastring: true
    }
);
```

#### 3. 后端接收规范

```java
// 方案1：简单参数（推荐）
@GetMapping("/list")
public AjaxResult list(
    @RequestParam(defaultValue = "1") Integer page,
    @RequestParam(required = false) String keyword
) {
    // 参数清晰明确
}

// 方案2：Map接收（灵活但类型需转换）
@PostMapping("/update")
public AjaxResult update(@RequestParam Map<String, String> param) {
    // 需要手动转换类型
    Integer id = Integer.parseInt(param.get("id"));
}

// 方案3：DTO对象（推荐，类型安全）
@PostMapping("/add")
public AjaxResult add(ProductDTO productDTO) {
    // Spring自动绑定和类型转换
}

// 方案4：JSON字符串（复杂数据）
@PostMapping("/search")
public AjaxResult search(@RequestBody String postdata) {
    // 手动解析，灵活性最高
    JSONObject json = JSONObject.parseObject(postdata);
}
```

#### 4. 调试技巧

```java
// 在后端添加日志查看参数
@PostMapping("/test")
public AjaxResult test(
    @RequestParam Map<String, String> param,
    @RequestBody String postdata
) {
    log.info("========== 参数调试 ==========");
    log.info("URL参数：{}", param);
    log.info("Body原始数据：{}", postdata);
    
    try {
        JSONObject json = JSONObject.parseObject(postdata);
        log.info("Body解析后：{}", json.toJSONString());
        
        // 逐个字段调试
        json.keySet().forEach(key -> {
            log.info("字段 {} 的值：{}, 类型：{}", 
                key, 
                json.get(key), 
                json.get(key).getClass().getName()
            );
        });
    } catch (Exception e) {
        log.error("解析失败", e);
    }
    
    return AjaxResult.success("调试完成");
}
```

------

### 快速决策流程图

```
开始
  ↓
需要传递数组或对象？
  ↓
是 → 使用 POST + datastring: true → @RequestBody String
  ↓
否 → 参数少于5个？
  ↓
是 → 使用 GET → @RequestParam
  ↓
否 → 使用 POST + datastring: false → @RequestParam
  ↓
结束
```

------

## 后端接收与处理

### Controller层

```java
@RestController
@RequestMapping("/inventory")
public class InventoryController {
    
    @Autowired
    private InventoryService inventoryService;
    
    /**
     * 根据EPC列表查询产品
     * 
     * 前端调用示例：
     * uni.smaction(callback, {tagList: "[...]"}, {
     *     route: 'uniwarehouse',
     *     action: 'inventory/findByEpc',
     *     method: 'POST',
     *     datastring: true
     * });
     */
    @RequestMapping(value = "/findByEpc", method = {RequestMethod.GET, RequestMethod.POST})
    public AjaxResult findProductByEpcList(
            @RequestHeader() Map<String, String> header,    // 接收请求头（包含Authorization）
            @RequestParam() Map<String, String> param,       // 接收URL参数
            @RequestBody String postdata                     // 接收请求体（JSON字符串）
    ) {
        return inventoryService.findProductByEpcList(header, param, postdata);
    }
}
```

------

### 关键问题解答

#### Q1：为什么 `@RequestBody` 用 String 类型？

**答案**：由于前端的特殊处理，必须用 `String` 接收。

**原因分析：**

```javascript
// 前端发送的数据（datastring: true）
{
    "tagList": "[\"tag1\",\"tag2\"]",  // 字符串形式的JSON数组
    "Authorization": "Bearer xxx"
}
```

如果后端用 `@RequestBody Map<String, Object>` 或 `@RequestBody JSONObject`：

- ✅ 可以接收到完整数据
- ❌ 但 `tagList` 的值仍然是**字符串**，不是数组
- ❌ 需要二次解析才能得到数组

如果后端用 `@RequestBody String`：

- ✅ 接收整个JSON字符串
- ✅ 手动解析，更灵活
- ✅ 可以处理各种复杂格式

**最佳实践：**

```java
// 方式1：使用String（推荐，灵活性高）
@RequestBody String postdata

// 方式2：定义DTO类（适合固定格式）
public class EpcListRequest {
    private String tagList;  // 注意：仍然是String类型
    private String Authorization;
}
@RequestBody EpcListRequest request
```

------

### Service层实现

```java
@Service
public class InventoryServiceImpl implements InventoryService {
    
    @Override
    public AjaxResult findProductByEpcList(
            Map<String, String> header, 
            Map<String, String> param, 
            String postdata
    ) {
        try {
            // ========== 第1步：解析外层JSON ==========
            JSONObject jsonObject = JSONObject.parseObject(postdata);
            
            // ========== 第2步：提取tagList字段（它是字符串） ==========
            String tagListStr = jsonObject.getString("tagList");
            log.info("提取的tagList字符串：{}", tagListStr);
            // 输出示例：["tag1","tag2","tag3"]
            
            // ========== 第3步：将字符串解析为数组 ==========
            JSONArray jsonArray = JSONArray.parseArray(tagListStr);
            List<String> tagList = jsonArray.toJavaList(String.class);
            log.info("解析后的tagList数组：{}", tagList);
            // 输出示例：[tag1, tag2, tag3]
            
            // ========== 第4步：业务处理 ==========
            // 这里进行你的业务逻辑，比如批量查询数据库
            List<Product> products = productMapper.selectByEpcList(tagList);
            
            // ========== 第5步：构建返回数据 ==========
            JSONObject result = new JSONObject();
            result.put("tagList", tagList);
            result.put("products", products);
            
            // ========== 第6步：返回（注意转为字符串） ==========
            // 关键：必须调用 toJSONString() 转为字符串
            return AjaxResult.success("查询成功", result.toJSONString());
            
        } catch (Exception e) {
            log.error("处理失败", e);
            return AjaxResult.error("处理失败：" + e.getMessage());
        }
    }
}
```

------

### AjaxResult 返回规范

```java
/**
 * 成功返回
 * 最终格式：
 * {
 *   "code": 200,
 *   "msg": "查询成功",
 *   "data": "{\"tagList\":[...],\"products\":[...]}"  // 字符串格式
 * }
 */
return AjaxResult.success("查询成功", result.toJSONString());

/**
 * 失败返回
 * 最终格式：
 * {
 *   "code": 500,
 *   "msg": "处理失败：xxx",
 *   "data": null
 * }
 */
return AjaxResult.error("处理失败：" + e.getMessage());
```

**⚠️ 关键点：`data` 字段必须是 JSON 字符串，不能是对象！**

------

## 数据流转全流程

### 完整示例：从前端到后端

#### 步骤1：前端发起请求

```javascript
uni.smaction(
    function(data, error) {
        if (!error) {
            console.log('标签列表：', data.tagList);
            console.log('产品列表：', data.products);
        }
    },
    {
        tagList: JSON.stringify(['E280691500004', 'E280691500005', 'E280691500006'])
    },
    {
        route: 'uniwarehouse',
        action: 'inventory/findByEpc',
        method: 'POST',
        datastring: true
    }
);
```

#### 步骤2：实际发送的HTTP请求

```http
POST /uniwarehouse/inventory/findByEpc HTTP/1.1
Content-Type: application/json

{
    "tagList": "[\"E280691500004\",\"E280691500005\",\"E280691500006\"]",
    "Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}
```

#### 步骤3：后端接收

```java
// postdata 的值：
{
    "tagList": "[\"E280691500004\",\"E280691500005\",\"E280691500006\"]",
    "Authorization": "Bearer eyJ..."
}
```

#### 步骤4：后端解析

```java
// 第一次解析：得到外层对象
JSONObject jsonObject = JSONObject.parseObject(postdata);

// 提取tagList字段（字符串）
String tagListStr = jsonObject.getString("tagList");
// tagListStr = ["E280691500004","E280691500005","E280691500006"]

// 第二次解析：字符串 → 数组
List<String> tagList = JSONArray.parseArray(tagListStr).toJavaList(String.class);
// tagList = [E280691500004, E280691500005, E280691500006]
```

#### 步骤5：后端返回

```java
JSONObject result = new JSONObject();
result.put("tagList", tagList);
result.put("products", products);

// 转为字符串后返回
return AjaxResult.success("查询成功", result.toJSONString());
```

#### 步骤6：HTTP响应

```json
{
    "code": 200,
    "msg": "查询成功",
    "data": "{\"tagList\":[\"E280691500004\",\"E280691500005\"],\"products\":[{\"id\":1,\"name\":\"产品A\"}]}"
}
```

#### 步骤7：前端接收并解析

```javascript
// 前端自动执行：
var result = JSON.parse(res.data.data);

// 回调函数接收到的 data：
{
    tagList: ["E280691500004", "E280691500005"],
    products: [{id: 1, name: "产品A"}]
}
```

------

## 常见问题解答

### Q1：为什么data字段要是字符串？

**答**：前端框架设计如此。前端会自动执行 `JSON.parse(res.data.data)`，如果后端直接返回对象，前端解析时会报错。

### Q2：能不能后端直接返回对象？

**答**：不行。必须调用 `.toJSONString()` 转为字符串。否则前端会报 `Unexpected token` 错误。

### Q3：tagList为什么要解析两次？

**答**：因为前端使用了 `JSON.stringify()`，导致数组被转为字符串。后端需要：

1. 第一次解析：整体JSON → 提取 tagList 字段
2. 第二次解析：tagList 字符串 → 数组

### Q4：能否优化前端避免二次解析？

**答**：可以，但需要修改前端调用方式：

```javascript
// 不推荐：需要后端二次解析
{tagList: JSON.stringify(tags)}

// 推荐：直接传数组（需要去掉 datastring: true）
{tagList: tags}

// 但注意：这样改会影响后端接收方式
// 后端需要改用 @RequestBody Map<String, Object>
```

### Q5：批量查询如何优化性能？

**答**：

```java
// 方式1：使用 IN 查询（推荐）
SELECT * FROM product WHERE epc IN (?, ?, ?)

// 方式2：如果数量超过1000，分批查询
int batchSize = 1000;
for (int i = 0; i < tagList.size(); i += batchSize) {
    List<String> batch = tagList.subList(i, Math.min(i + batchSize, tagList.size()));
    List<Product> batchResult = mapper.selectByEpcList(batch);
    allResults.addAll(batchResult);
}
```

### Q6：如何调试数据格式问题？

**答**：在关键位置添加日志：

```java
log.info("原始postdata：{}", postdata);
log.info("解析后的jsonObject：{}", jsonObject);
log.info("tagList字符串：{}", tagListStr);
log.info("tagList数组：{}", tagList);
log.info("返回的result：{}", result.toJSONString());
```

------

## 快速参考表

### 前端 → 后端映射关系

| 前端配置            | 后端接收方式           | 数据格式   |
| ------------------- | ---------------------- | ---------- |
| `datastring: true`  | `@RequestBody String`  | JSON字符串 |
| `datastring: false` | `@RequestParam Map`    | 键值对     |
| `param.xxx`         | `@RequestParam("xxx")` | 单个参数   |
| `header` 中的值     | `@RequestHeader`       | 请求头     |

### 返回格式对照

| 场景   | code | data             | msg       |
| ------ | ---- | ---------------- | --------- |
| 成功   | 200  | 字符串格式的JSON | "success" |
| 失败   | 500  | null 或 "{}"     | 错误信息  |
| 未登录 | 401  | null             | "未登录"  |

------

## 总结

### 核心要点

1. ✅ 前端 `datastring: true` → 后端 `@RequestBody String`
2. ✅ 后端 `data` 字段必须用 `.toJSONString()` 转为字符串
3. ✅ `tagList` 需要二次解析（外层JSON → 内层数组字符串 → 数组）
4. ✅ 回调函数：`cb(data, error, rawData)`，成功时 error 为 null